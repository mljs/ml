!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).ML={})}(this,(function(exports){"use strict";const toString=Object.prototype.toString;function isAnyArray(t){return toString.call(t).endsWith("Array]")}function max(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,n=void 0===r?0:r,i=e.toIndex,o=void 0===i?t.length:i;if(n<0||n>=t.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(o<=n||o>t.length||!Number.isInteger(o))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var s=t[n],a=n+1;a<o;a++)t[a]>s&&(s=t[a]);return s}function min(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,n=void 0===r?0:r,i=e.toIndex,o=void 0===i?t.length:i;if(n<0||n>=t.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(o<=n||o>t.length||!Number.isInteger(o))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var s=t[n],a=n+1;a<o;a++)t[a]<s&&(s=t[a]);return s}function rescale(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!isAnyArray(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var n=min(t),i=max(t);if(n===i)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var o=r.min,s=void 0===o?r.autoMinMax?n:0:o,a=r.max,l=void 0===a?r.autoMinMax?i:1:a;if(s>=l)throw new RangeError("min option must be smaller than max option");for(var h=(l-s)/(i-n),u=0;u<t.length;u++)e[u]=(t[u]-n)*h+s;return e}const indent=" ".repeat(2),indentData=" ".repeat(4);function inspectMatrix(){return inspectMatrixWithOptions(this)}function inspectMatrixWithOptions(t,e={}){const{maxRows:r=15,maxColumns:n=10,maxNumSize:i=8}=e;return`${t.constructor.name} {\n${indent}[\n${indentData}${inspectData(t,r,n,i)}\n${indent}]\n${indent}rows: ${t.rows}\n${indent}columns: ${t.columns}\n}`}function inspectData(t,e,r,n){const{rows:i,columns:o}=t,s=Math.min(i,e),a=Math.min(o,r),l=[];for(let e=0;e<s;e++){let r=[];for(let i=0;i<a;i++)r.push(formatNumber(t.get(e,i),n));l.push(""+r.join(" "))}return a!==o&&(l[l.length-1]+=` ... ${o-r} more columns`),s!==i&&l.push(`... ${i-e} more rows`),l.join("\n"+indentData)}function formatNumber(t,e){const r=String(t);if(r.length<=e)return r.padEnd(e," ");const n=t.toPrecision(e-2);if(n.length<=e)return n;const i=t.toExponential(e-2),o=i.indexOf("e"),s=i.slice(o);return i.slice(0,e-s.length)+s}function installMathOperations(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}function checkRowIndex(t,e,r){let n=r?t.rows:t.rows-1;if(e<0||e>n)throw new RangeError("Row index out of range")}function checkColumnIndex(t,e,r){let n=r?t.columns:t.columns-1;if(e<0||e>n)throw new RangeError("Column index out of range")}function checkRowVector(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function checkColumnVector(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function checkIndices(t,e,r){return{row:checkRowIndices(t,e),column:checkColumnIndices(t,r)}}function checkRowIndices(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for row indices");if(e.some((e=>e<0||e>=t.rows)))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function checkColumnIndices(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for column indices");if(e.some((e=>e<0||e>=t.columns)))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function checkRange(t,e,r,n,i){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",e),checkNumber("endRow",r),checkNumber("startColumn",n),checkNumber("endColumn",i),e>r||n>i||e<0||e>=t.rows||r<0||r>=t.rows||n<0||n>=t.columns||i<0||i>=t.columns)throw new RangeError("Submatrix indices are out of range")}function newArray(t,e=0){let r=[];for(let n=0;n<t;n++)r.push(e);return r}function checkNumber(t,e){if("number"!=typeof e)throw new TypeError(t+" must be a number")}function sumByRow(t){let e=newArray(t.rows);for(let r=0;r<t.rows;++r)for(let n=0;n<t.columns;++n)e[r]+=t.get(r,n);return e}function sumByColumn(t){let e=newArray(t.columns);for(let r=0;r<t.rows;++r)for(let n=0;n<t.columns;++n)e[n]+=t.get(r,n);return e}function sumAll(t){let e=0;for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)e+=t.get(r,n);return e}function productByRow(t){let e=newArray(t.rows,1);for(let r=0;r<t.rows;++r)for(let n=0;n<t.columns;++n)e[r]*=t.get(r,n);return e}function productByColumn(t){let e=newArray(t.columns,1);for(let r=0;r<t.rows;++r)for(let n=0;n<t.columns;++n)e[n]*=t.get(r,n);return e}function productAll(t){let e=1;for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)e*=t.get(r,n);return e}function varianceByRow(t,e,r){const n=t.rows,i=t.columns,o=[];for(let s=0;s<n;s++){let n=0,a=0,l=0;for(let e=0;e<i;e++)l=t.get(s,e)-r[s],n+=l,a+=l*l;e?o.push((a-n*n/i)/(i-1)):o.push((a-n*n/i)/i)}return o}function varianceByColumn(t,e,r){const n=t.rows,i=t.columns,o=[];for(let s=0;s<i;s++){let i=0,a=0,l=0;for(let e=0;e<n;e++)l=t.get(e,s)-r[s],i+=l,a+=l*l;e?o.push((a-i*i/n)/(n-1)):o.push((a-i*i/n)/n)}return o}function varianceAll(t,e,r){const n=t.rows,i=t.columns,o=n*i;let s=0,a=0,l=0;for(let e=0;e<n;e++)for(let n=0;n<i;n++)l=t.get(e,n)-r,s+=l,a+=l*l;return e?(a-s*s/o)/(o-1):(a-s*s/o)/o}function centerByRow(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e[r])}function centerByColumn(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e[n])}function centerAll(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)-e)}function getScaleByRow(t){const e=[];for(let r=0;r<t.rows;r++){let n=0;for(let e=0;e<t.columns;e++)n+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(n))}return e}function scaleByRow(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e[r])}function getScaleByColumn(t){const e=[];for(let r=0;r<t.columns;r++){let n=0;for(let e=0;e<t.rows;e++)n+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(n))}return e}function scaleByColumn(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e[n])}function getScaleAll(t){const e=t.size-1;let r=0;for(let n=0;n<t.columns;n++)for(let i=0;i<t.rows;i++)r+=Math.pow(t.get(i,n),2)/e;return Math.sqrt(r)}function scaleAll(t,e){for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)t.set(r,n,t.get(r,n)/e)}class AbstractMatrix{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let n=new Matrix(t,e);for(let i=0;i<t;i++)for(let t=0;t<e;t++)n.set(i,t,r[i*e+t]);return n}static rowVector(t){let e=new Matrix(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new Matrix(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new Matrix(t,e)}static ones(t,e){return new Matrix(t,e).fill(1)}static rand(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{random:n=Math.random}=r;let i=new Matrix(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)i.set(r,t,n());return i}static randInt(t,e,r={}){if("object"!=typeof r)throw new TypeError("options must be an object");const{min:n=0,max:i=1e3,random:o=Math.random}=r;if(!Number.isInteger(n))throw new TypeError("min must be an integer");if(!Number.isInteger(i))throw new TypeError("max must be an integer");if(n>=i)throw new RangeError("min must be smaller than max");let s=i-n,a=new Matrix(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=n+Math.round(o()*s);a.set(r,t,e)}return a}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let n=Math.min(t,e),i=this.zeros(t,e);for(let t=0;t<n;t++)i.set(t,t,r);return i}static diag(t,e,r){let n=t.length;void 0===e&&(e=n),void 0===r&&(r=e);let i=Math.min(n,e,r),o=this.zeros(e,r);for(let e=0;e<i;e++)o.set(e,e,t[e]);return o}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,n=t.columns,i=new Matrix(r,n);for(let o=0;o<r;o++)for(let r=0;r<n;r++)i.set(o,r,Math.min(t.get(o,r),e.get(o,r)));return i}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,n=t.columns,i=new this(r,n);for(let o=0;o<r;o++)for(let r=0;r<n;r++)i.set(o,r,Math.max(t.get(o,r),e.get(o,r)));return i}static checkMatrix(t){return AbstractMatrix.isMatrix(t)?t:new Matrix(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,n=!0,i=!1;for(;t<this.rows&&n;){for(e=0,i=!1;e<this.columns&&!1===i;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(i=!0,r=e):(n=!1,i=!0);t++}return n}isReducedEchelonForm(){let t=0,e=0,r=-1,n=!0,i=!1;for(;t<this.rows&&n;){for(e=0,i=!1;e<this.columns&&!1===i;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(i=!0,r=e):(n=!1,i=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(n=!1);t++}return n}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let n=e;for(let i=e;i<t.rows;i++)t.get(i,r)>t.get(n,r)&&(n=i);if(0===t.get(n,r))r++;else{t.swapRows(e,n);let i=t.get(e,r);for(let n=r;n<t.columns;n++)t.set(e,n,t.get(e,n)/i);for(let n=e+1;n<t.rows;n++){let i=t.get(n,r)/t.get(e,r);t.set(n,r,0);for(let o=r+1;o<t.columns;o++)t.set(n,o,t.get(n,o)-t.get(e,o)*i)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,n=r-1;for(;n>=0;)if(0===t.maxRow(n))n--;else{let i=0,o=!1;for(;i<r&&!1===o;)1===t.get(n,i)?o=!0:i++;for(let r=0;r<n;r++){let o=t.get(r,i);for(let s=i;s<e;s++){let e=t.get(r,s)-o*t.get(n,s);t.set(r,s,e)}}n--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let n=new Matrix(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)n.setSubMatrix(this,this.rows*t,this.columns*e);return n}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){checkRowIndex(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return Matrix.rowVector(this.getRow(t))}setRow(t,e){checkRowIndex(this,t),e=checkRowVector(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){checkRowIndex(this,t),checkRowIndex(this,e);for(let r=0;r<this.columns;r++){let n=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,n)}return this}getColumn(t){checkColumnIndex(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return Matrix.columnVector(this.getColumn(t))}setColumn(t,e){checkColumnIndex(this,t),e=checkColumnVector(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){checkColumnIndex(this,t),checkColumnIndex(this,e);for(let r=0;r<this.rows;r++){let n=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,n)}return this}addRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){checkRowIndex(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){checkColumnIndex(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let n=0;n<this.columns;n++)this.get(r,n)>t&&(t=this.get(r,n),e[0]=r,e[1]=n);return e}min(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let n=0;n<this.columns;n++)this.get(r,n)<t&&(t=this.get(r,n),e[0]=r,e[1]=n);return e}maxRow(t){checkRowIndex(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){checkRowIndex(this,t);let e=this.get(t,0),r=[t,0];for(let n=1;n<this.columns;n++)this.get(t,n)>e&&(e=this.get(t,n),r[1]=n);return r}minRow(t){checkRowIndex(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){checkRowIndex(this,t);let e=this.get(t,0),r=[t,0];for(let n=1;n<this.columns;n++)this.get(t,n)<e&&(e=this.get(t,n),r[1]=n);return r}maxColumn(t){checkColumnIndex(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){checkColumnIndex(this,t);let e=this.get(0,t),r=[0,t];for(let n=1;n<this.rows;n++)this.get(n,t)>e&&(e=this.get(n,t),r[0]=n);return r}minColumn(t){checkColumnIndex(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){checkColumnIndex(this,t);let e=this.get(0,t),r=[0,t];for(let n=1;n<this.rows;n++)this.get(n,t)<e&&(e=this.get(n,t),r[0]=n);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(t="frobenius"){let e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError("unknown norm type: "+t)}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){AbstractMatrix.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let n=0;n<e.length;n++)r+=e[n]*t[n];return r}mmul(t){t=Matrix.checkMatrix(t);let e=this.rows,r=this.columns,n=t.columns,i=new Matrix(e,n),o=new Float64Array(r);for(let s=0;s<n;s++){for(let e=0;e<r;e++)o[e]=t.get(e,s);for(let t=0;t<e;t++){let e=0;for(let n=0;n<r;n++)e+=this.get(t,n)*o[n];i.set(t,s,e)}}return i}strassen2x2(t){t=Matrix.checkMatrix(t);let e=new Matrix(2,2);const r=this.get(0,0),n=t.get(0,0),i=this.get(0,1),o=t.get(0,1),s=this.get(1,0),a=t.get(1,0),l=this.get(1,1),h=t.get(1,1),u=(r+l)*(n+h),c=(s+l)*n,m=r*(o-h),f=l*(a-n),g=(r+i)*h,p=u+f-g+(i-l)*(a+h),d=m+g,w=c+f,x=u-c+m+(s-r)*(n+o);return e.set(0,0,p),e.set(0,1,d),e.set(1,0,w),e.set(1,1,x),e}strassen3x3(t){t=Matrix.checkMatrix(t);let e=new Matrix(3,3);const r=this.get(0,0),n=this.get(0,1),i=this.get(0,2),o=this.get(1,0),s=this.get(1,1),a=this.get(1,2),l=this.get(2,0),h=this.get(2,1),u=this.get(2,2),c=t.get(0,0),m=t.get(0,1),f=t.get(0,2),g=t.get(1,0),p=t.get(1,1),d=t.get(1,2),w=t.get(2,0),x=t.get(2,1),y=t.get(2,2),M=(r-o)*(-m+p),v=(-r+o+s)*(c-m+p),b=(o+s)*(-c+m),S=r*c,A=(-r+l+h)*(c-f+d),E=(-r+l)*(f-d),R=(l+h)*(-c+f),k=(-i+h+u)*(p+w-x),N=(i-u)*(p-x),C=i*w,T=(h+u)*(-w+x),I=(-i+s+a)*(d+w-y),O=(i-a)*(d-y),L=(s+a)*(-w+y),F=S+C+n*g,P=(r+n+i-o-s-h-u)*p+v+b+S+k+C+T,V=S+A+R+(r+n+i-s-a-l-h)*d+C+I+L,D=M+s*(-c+m+g-p-d-w+y)+v+S+C+I+O,z=M+v+b+S+a*x,_=C+I+O+L+o*f,$=S+A+E+h*(-c+f+g-p-d-w+x)+k+N+C,q=k+N+C+T+l*m,B=S+A+E+R+u*y;return e.set(0,0,F),e.set(0,1,P),e.set(0,2,V),e.set(1,0,D),e.set(1,1,z),e.set(1,2,_),e.set(2,0,$),e.set(2,1,q),e.set(2,2,B),e}mmulStrassen(t){t=Matrix.checkMatrix(t);let e=this.clone(),r=e.rows,n=e.columns,i=t.rows,o=t.columns;function s(t,e,r){let n=t.rows,i=t.columns;if(n===e&&i===r)return t;{let n=AbstractMatrix.zeros(e,r);return n=n.setSubMatrix(t,0,0),n}}n!==i&&console.warn(`Multiplying ${r} x ${n} and ${i} x ${o} matrix: dimensions do not match.`);let a=Math.max(r,i),l=Math.max(n,o);return e=s(e,a,l),function t(e,r,n,i){if(n<=512||i<=512)return e.mmul(r);n%2==1&&i%2==1?(e=s(e,n+1,i+1),r=s(r,n+1,i+1)):n%2==1?(e=s(e,n+1,i),r=s(r,n+1,i)):i%2==1&&(e=s(e,n,i+1),r=s(r,n,i+1));let o=parseInt(e.rows/2,10),a=parseInt(e.columns/2,10),l=e.subMatrix(0,o-1,0,a-1),h=r.subMatrix(0,o-1,0,a-1),u=e.subMatrix(0,o-1,a,e.columns-1),c=r.subMatrix(0,o-1,a,r.columns-1),m=e.subMatrix(o,e.rows-1,0,a-1),f=r.subMatrix(o,r.rows-1,0,a-1),g=e.subMatrix(o,e.rows-1,a,e.columns-1),p=r.subMatrix(o,r.rows-1,a,r.columns-1),d=t(AbstractMatrix.add(l,g),AbstractMatrix.add(h,p),o,a),w=t(AbstractMatrix.add(m,g),h,o,a),x=t(l,AbstractMatrix.sub(c,p),o,a),y=t(g,AbstractMatrix.sub(f,h),o,a),M=t(AbstractMatrix.add(l,u),p,o,a),v=t(AbstractMatrix.sub(m,l),AbstractMatrix.add(h,c),o,a),b=t(AbstractMatrix.sub(u,g),AbstractMatrix.add(f,p),o,a),S=AbstractMatrix.add(d,y);S.sub(M),S.add(b);let A=AbstractMatrix.add(x,M),E=AbstractMatrix.add(w,y),R=AbstractMatrix.sub(d,w);R.add(x),R.add(v);let k=AbstractMatrix.zeros(2*S.rows,2*S.columns);return k=k.setSubMatrix(S,0,0),k=k.setSubMatrix(A,S.rows,0),k=k.setSubMatrix(E,0,S.columns),k=k.setSubMatrix(R,S.rows,S.columns),k.subMatrix(0,n-1,0,i-1)}(e,t=s(t,a,l),a,l)}scaleRows(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let n=new Matrix(this.rows,this.columns);for(let t=0;t<this.rows;t++){const i=this.getRow(t);rescale(i,{min:e,max:r,output:i}),n.setRow(t,i)}return n}scaleColumns(t={}){if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let n=new Matrix(this.rows,this.columns);for(let t=0;t<this.columns;t++){const i=this.getColumn(t);rescale(i,{min:e,max:r,output:i}),n.setColumn(t,i)}return n}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),n=this.get(e,this.columns-1-r);this.set(e,r,n),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),n=this.get(this.rows-1-r,e);this.set(r,e,n),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=Matrix.checkMatrix(t);let e=this.rows,r=this.columns,n=t.rows,i=t.columns,o=new Matrix(e*n,r*i);for(let s=0;s<e;s++)for(let e=0;e<r;e++)for(let r=0;r<n;r++)for(let a=0;a<i;a++)o.set(n*s+r,i*e+a,this.get(s,e)*t.get(r,a));return o}transpose(){let t=new Matrix(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(t=compareNumbers){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(t=compareNumbers){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,n){checkRange(this,t,e,r,n);let i=new Matrix(e-t+1,n-r+1);for(let o=t;o<=e;o++)for(let e=r;e<=n;e++)i.set(o-t,e-r,this.get(o,e));return i}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let n=new Matrix(t.length,r-e+1);for(let i=0;i<t.length;i++)for(let o=e;o<=r;o++){if(t[i]<0||t[i]>=this.rows)throw new RangeError("Row index out of range: "+t[i]);n.set(i,o-e,this.get(t[i],o))}return n}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let n=new Matrix(r-e+1,t.length);for(let i=0;i<t.length;i++)for(let o=e;o<=r;o++){if(t[i]<0||t[i]>=this.columns)throw new RangeError("Column index out of range: "+t[i]);n.set(o-e,i,this.get(o,t[i]))}return n}setSubMatrix(t,e,r){checkRange(this,e,e+(t=Matrix.checkMatrix(t)).rows-1,r,r+t.columns-1);for(let n=0;n<t.rows;n++)for(let i=0;i<t.columns;i++)this.set(e+n,r+i,t.get(n,i));return this}selection(t,e){let r=checkIndices(this,t,e),n=new Matrix(t.length,e.length);for(let t=0;t<r.row.length;t++){let e=r.row[t];for(let i=0;i<r.column.length;i++){let o=r.column[i];n.set(t,i,this.get(e,o))}}return n}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new Matrix(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return sumByRow(this);case"column":return sumByColumn(this);case void 0:return sumAll(this);default:throw new Error("invalid option: "+t)}}product(t){switch(t){case"row":return productByRow(this);case"column":return productByColumn(this);case void 0:return productAll(this);default:throw new Error("invalid option: "+t)}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error("invalid option: "+t)}}variance(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:n=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!Array.isArray(n))throw new TypeError("mean must be an array");return varianceByRow(this,r,n);case"column":if(!Array.isArray(n))throw new TypeError("mean must be an array");return varianceByColumn(this,r,n);case void 0:if("number"!=typeof n)throw new TypeError("mean must be a number");return varianceAll(this,r,n);default:throw new Error("invalid option: "+t)}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!Array.isArray(r))throw new TypeError("center must be an array");return centerByRow(this,r),this;case"column":if(!Array.isArray(r))throw new TypeError("center must be an array");return centerByColumn(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return centerAll(this,r),this;default:throw new Error("invalid option: "+t)}}scale(t,e={}){if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=getScaleByRow(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return scaleByRow(this,r),this;case"column":if(void 0===r)r=getScaleByColumn(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return scaleByColumn(this,r),this;case void 0:if(void 0===r)r=getScaleAll(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return scaleAll(this,r),this;default:throw new Error("invalid option: "+t)}}toString(t){return inspectMatrixWithOptions(this,t)}}function compareNumbers(t,e){return t-e}AbstractMatrix.prototype.klass="Matrix","undefined"!=typeof Symbol&&(AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")]=inspectMatrix),AbstractMatrix.random=AbstractMatrix.rand,AbstractMatrix.randomInt=AbstractMatrix.randInt,AbstractMatrix.diagonal=AbstractMatrix.diag,AbstractMatrix.prototype.diagonal=AbstractMatrix.prototype.diag,AbstractMatrix.identity=AbstractMatrix.eye,AbstractMatrix.prototype.negate=AbstractMatrix.prototype.neg,AbstractMatrix.prototype.tensorProduct=AbstractMatrix.prototype.kroneckerProduct;class Matrix extends AbstractMatrix{constructor(t,e){if(super(),Matrix.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>0){if(this.data=[],!(Number.isInteger(e)&&e>0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!Array.isArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if(t=r.length,"number"!=typeof(e=r[0].length)||0===e)throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let n=0;n<t;n++){if(r[n].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[n]))}}}return this.rows=t,this.columns=e,this}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){if(checkRowIndex(this,t),1===this.rows)throw new RangeError("A matrix cannot have less than one row");return this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),checkRowIndex(this,t,!0),e=Float64Array.from(checkRowVector(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){if(checkColumnIndex(this,t),1===this.columns)throw new RangeError("A matrix cannot have less than one column");for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let n=0;n<t;n++)r[n]=this.data[e][n];for(let n=t+1;n<this.columns;n++)r[n-1]=this.data[e][n];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),checkColumnIndex(this,t,!0),e=checkColumnVector(this,e);for(let r=0;r<this.rows;r++){const n=new Float64Array(this.columns+1);let i=0;for(;i<t;i++)n[i]=this.data[r][i];for(n[i++]=e[r];i<this.columns+1;i++)n[i]=this.data[r][i-1];this.data[r]=n}return this.columns+=1,this}}installMathOperations(AbstractMatrix,Matrix);class BaseView extends AbstractMatrix{constructor(t,e,r){super(),this.matrix=t,this.rows=e,this.columns=r}}class MatrixColumnView extends BaseView{constructor(t,e){checkColumnIndex(t,e),super(t,t.rows,1),this.column=e}set(t,e,r){return this.matrix.set(t,this.column,r),this}get(t){return this.matrix.get(t,this.column)}}class MatrixColumnSelectionView extends BaseView{constructor(t,e){e=checkColumnIndices(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,r){return this.matrix.set(t,this.columnIndices[e],r),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}}class MatrixFlipColumnView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(t,this.columns-e-1,r),this}get(t,e){return this.matrix.get(t,this.columns-e-1)}}class MatrixFlipRowView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(this.rows-t-1,e,r),this}get(t,e){return this.matrix.get(this.rows-t-1,e)}}class MatrixRowView extends BaseView{constructor(t,e){checkRowIndex(t,e),super(t,1,t.columns),this.row=e}set(t,e,r){return this.matrix.set(this.row,e,r),this}get(t,e){return this.matrix.get(this.row,e)}}class MatrixRowSelectionView extends BaseView{constructor(t,e){super(t,(e=checkRowIndices(t,e)).length,t.columns),this.rowIndices=e}set(t,e,r){return this.matrix.set(this.rowIndices[t],e,r),this}get(t,e){return this.matrix.get(this.rowIndices[t],e)}}class MatrixSelectionView extends BaseView{constructor(t,e,r){let n=checkIndices(t,e,r);super(t,n.row.length,n.column.length),this.rowIndices=n.row,this.columnIndices=n.column}set(t,e,r){return this.matrix.set(this.rowIndices[t],this.columnIndices[e],r),this}get(t,e){return this.matrix.get(this.rowIndices[t],this.columnIndices[e])}}class MatrixSubView extends BaseView{constructor(t,e,r,n,i){checkRange(t,e,r,n,i),super(t,r-e+1,i-n+1),this.startRow=e,this.startColumn=n}set(t,e,r){return this.matrix.set(this.startRow+t,this.startColumn+e,r),this}get(t,e){return this.matrix.get(this.startRow+t,this.startColumn+e)}}class MatrixTransposeView extends BaseView{constructor(t){super(t,t.columns,t.rows)}set(t,e,r){return this.matrix.set(e,t,r),this}get(t,e){return this.matrix.get(e,t)}}class WrapperMatrix1D extends AbstractMatrix{constructor(t,e={}){const{rows:r=1}=e;if(t.length%r!=0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=t.length/r,this.data=t}set(t,e,r){let n=this._calculateIndex(t,e);return this.data[n]=r,this}get(t,e){let r=this._calculateIndex(t,e);return this.data[r]}_calculateIndex(t,e){return t*this.columns+e}}class WrapperMatrix2D extends AbstractMatrix{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}function wrap(t,e){if(Array.isArray(t))return t[0]&&Array.isArray(t[0])?new WrapperMatrix2D(t):new WrapperMatrix1D(t,e);throw new Error("the argument is not an array")}class LuDecomposition{constructor(t){let e,r,n,i,o,s,a,l,h,u=(t=WrapperMatrix2D.checkMatrix(t)).clone(),c=u.rows,m=u.columns,f=new Float64Array(c),g=1;for(e=0;e<c;e++)f[e]=e;for(l=new Float64Array(c),r=0;r<m;r++){for(e=0;e<c;e++)l[e]=u.get(e,r);for(e=0;e<c;e++){for(h=Math.min(e,r),o=0,n=0;n<h;n++)o+=u.get(e,n)*l[n];l[e]-=o,u.set(e,r,l[e])}for(i=r,e=r+1;e<c;e++)Math.abs(l[e])>Math.abs(l[i])&&(i=e);if(i!==r){for(n=0;n<m;n++)s=u.get(i,n),u.set(i,n,u.get(r,n)),u.set(r,n,s);a=f[i],f[i]=f[r],f[r]=a,g=-g}if(r<c&&0!==u.get(r,r))for(e=r+1;e<c;e++)u.set(e,r,u.get(e,r)/u.get(r,r))}this.LU=u,this.pivotVector=f,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=Matrix.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,n,i,o=t.columns,s=t.subMatrixRow(this.pivotVector,0,o-1),a=e.columns;for(i=0;i<a;i++)for(r=i+1;r<a;r++)for(n=0;n<o;n++)s.set(r,n,s.get(r,n)-s.get(i,n)*e.get(r,i));for(i=a-1;i>=0;i--){for(n=0;n<o;n++)s.set(i,n,s.get(i,n)/e.get(i,i));for(r=0;r<i;r++)for(n=0;n<o;n++)s.set(r,n,s.get(r,n)-s.get(i,n)*e.get(r,i))}return s}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let n=0;n<r;n++)e*=t.get(n,n);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,n=new Matrix(e,r);for(let i=0;i<e;i++)for(let e=0;e<r;e++)i>e?n.set(i,e,t.get(i,e)):i===e?n.set(i,e,1):n.set(i,e,0);return n}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,n=new Matrix(e,r);for(let i=0;i<e;i++)for(let e=0;e<r;e++)i<=e?n.set(i,e,t.get(i,e)):n.set(i,e,0);return n}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function hypotenuse(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class QrDecomposition{constructor(t){let e,r,n,i,o=(t=WrapperMatrix2D.checkMatrix(t)).clone(),s=t.rows,a=t.columns,l=new Float64Array(a);for(n=0;n<a;n++){let t=0;for(e=n;e<s;e++)t=hypotenuse(t,o.get(e,n));if(0!==t){for(o.get(n,n)<0&&(t=-t),e=n;e<s;e++)o.set(e,n,o.get(e,n)/t);for(o.set(n,n,o.get(n,n)+1),r=n+1;r<a;r++){for(i=0,e=n;e<s;e++)i+=o.get(e,n)*o.get(e,r);for(i=-i/o.get(n,n),e=n;e<s;e++)o.set(e,r,o.get(e,r)+i*o.get(e,n))}}l[n]=-t}this.QR=o,this.Rdiag=l}solve(t){t=Matrix.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let n,i,o,s,a=t.columns,l=t.clone(),h=e.columns;for(o=0;o<h;o++)for(i=0;i<a;i++){for(s=0,n=o;n<r;n++)s+=e.get(n,o)*l.get(n,i);for(s=-s/e.get(o,o),n=o;n<r;n++)l.set(n,i,l.get(n,i)+s*e.get(n,o))}for(o=h-1;o>=0;o--){for(i=0;i<a;i++)l.set(o,i,l.get(o,i)/this.Rdiag[o]);for(n=0;n<o;n++)for(i=0;i<a;i++)l.set(n,i,l.get(n,i)-l.get(o,i)*e.get(n,o))}return l.subMatrix(0,h-1,0,a-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,n=r.columns,i=new Matrix(n,n);for(t=0;t<n;t++)for(e=0;e<n;e++)t<e?i.set(t,e,r.get(t,e)):t===e?i.set(t,e,this.Rdiag[t]):i.set(t,e,0);return i}get orthogonalMatrix(){let t,e,r,n,i=this.QR,o=i.rows,s=i.columns,a=new Matrix(o,s);for(r=s-1;r>=0;r--){for(t=0;t<o;t++)a.set(t,r,0);for(a.set(r,r,1),e=r;e<s;e++)if(0!==i.get(r,r)){for(n=0,t=r;t<o;t++)n+=i.get(t,r)*a.get(t,e);for(n=-n/i.get(r,r),t=r;t<o;t++)a.set(t,e,a.get(t,e)+n*i.get(t,r))}}return a}}class SingularValueDecomposition{constructor(t,e={}){let r=(t=WrapperMatrix2D.checkMatrix(t)).rows,n=t.columns;const{computeLeftSingularVectors:i=!0,computeRightSingularVectors:o=!0,autoTranspose:s=!1}=e;let a,l=Boolean(i),h=Boolean(o),u=!1;if(r<n)if(s){a=t.transpose(),r=a.rows,n=a.columns,u=!0;let e=l;l=h,h=e}else a=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else a=t.clone();let c=Math.min(r,n),m=Math.min(r+1,n),f=new Float64Array(m),g=new Matrix(r,c),p=new Matrix(n,n),d=new Float64Array(n),w=new Float64Array(r),x=new Float64Array(m);for(let t=0;t<m;t++)x[t]=t;let y=Math.min(r-1,n),M=Math.max(0,Math.min(n-2,r)),v=Math.max(y,M);for(let t=0;t<v;t++){if(t<y){f[t]=0;for(let e=t;e<r;e++)f[t]=hypotenuse(f[t],a.get(e,t));if(0!==f[t]){a.get(t,t)<0&&(f[t]=-f[t]);for(let e=t;e<r;e++)a.set(e,t,a.get(e,t)/f[t]);a.set(t,t,a.get(t,t)+1)}f[t]=-f[t]}for(let e=t+1;e<n;e++){if(t<y&&0!==f[t]){let n=0;for(let i=t;i<r;i++)n+=a.get(i,t)*a.get(i,e);n=-n/a.get(t,t);for(let i=t;i<r;i++)a.set(i,e,a.get(i,e)+n*a.get(i,t))}d[e]=a.get(t,e)}if(l&&t<y)for(let e=t;e<r;e++)g.set(e,t,a.get(e,t));if(t<M){d[t]=0;for(let e=t+1;e<n;e++)d[t]=hypotenuse(d[t],d[e]);if(0!==d[t]){d[t+1]<0&&(d[t]=0-d[t]);for(let e=t+1;e<n;e++)d[e]/=d[t];d[t+1]+=1}if(d[t]=-d[t],t+1<r&&0!==d[t]){for(let e=t+1;e<r;e++)w[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<n;r++)w[e]+=d[r]*a.get(e,r);for(let e=t+1;e<n;e++){let n=-d[e]/d[t+1];for(let i=t+1;i<r;i++)a.set(i,e,a.get(i,e)+n*w[i])}}if(h)for(let e=t+1;e<n;e++)p.set(e,t,d[e])}}let b=Math.min(n,r+1);if(y<n&&(f[y]=a.get(y,y)),r<b&&(f[b-1]=0),M+1<b&&(d[M]=a.get(M,b-1)),d[b-1]=0,l){for(let t=y;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=y-1;t>=0;t--)if(0!==f[t]){for(let e=t+1;e<c;e++){let n=0;for(let i=t;i<r;i++)n+=g.get(i,t)*g.get(i,e);n=-n/g.get(t,t);for(let i=t;i<r;i++)g.set(i,e,g.get(i,e)+n*g.get(i,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(h)for(let t=n-1;t>=0;t--){if(t<M&&0!==d[t])for(let e=t+1;e<n;e++){let r=0;for(let i=t+1;i<n;i++)r+=p.get(i,t)*p.get(i,e);r=-r/p.get(t+1,t);for(let i=t+1;i<n;i++)p.set(i,e,p.get(i,e)+r*p.get(i,t))}for(let e=0;e<n;e++)p.set(e,t,0);p.set(t,t,1)}let S=b-1,A=Number.EPSILON;for(;b>0;){let t,e;for(t=b-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+A*Math.abs(f[t]+Math.abs(f[t+1]));if(Math.abs(d[t])<=e||Number.isNaN(d[t])){d[t]=0;break}}if(t===b-2)e=4;else{let r;for(r=b-1;r>=t&&r!==t;r--){let e=(r!==b?Math.abs(d[r]):0)+(r!==t+1?Math.abs(d[r-1]):0);if(Math.abs(f[r])<=A*e){f[r]=0;break}}r===t?e=3:r===b-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=d[b-2];d[b-2]=0;for(let r=b-2;r>=t;r--){let i=hypotenuse(f[r],e),o=f[r]/i,s=e/i;if(f[r]=i,r!==t&&(e=-s*d[r-1],d[r-1]=o*d[r-1]),h)for(let t=0;t<n;t++)i=o*p.get(t,r)+s*p.get(t,b-1),p.set(t,b-1,-s*p.get(t,r)+o*p.get(t,b-1)),p.set(t,r,i)}break}case 2:{let e=d[t-1];d[t-1]=0;for(let n=t;n<b;n++){let i=hypotenuse(f[n],e),o=f[n]/i,s=e/i;if(f[n]=i,e=-s*d[n],d[n]=o*d[n],l)for(let e=0;e<r;e++)i=o*g.get(e,n)+s*g.get(e,t-1),g.set(e,t-1,-s*g.get(e,n)+o*g.get(e,t-1)),g.set(e,n,i)}break}case 3:{const e=Math.max(Math.abs(f[b-1]),Math.abs(f[b-2]),Math.abs(d[b-2]),Math.abs(f[t]),Math.abs(d[t])),i=f[b-1]/e,o=f[b-2]/e,s=d[b-2]/e,a=f[t]/e,u=d[t]/e,c=((o+i)*(o-i)+s*s)/2,m=i*s*(i*s);let w=0;0===c&&0===m||(w=c<0?0-Math.sqrt(c*c+m):Math.sqrt(c*c+m),w=m/(c+w));let x=(a+i)*(a-i)+w,y=a*u;for(let e=t;e<b-1;e++){let i=hypotenuse(x,y);0===i&&(i=Number.MIN_VALUE);let o=x/i,s=y/i;if(e!==t&&(d[e-1]=i),x=o*f[e]+s*d[e],d[e]=o*d[e]-s*f[e],y=s*f[e+1],f[e+1]=o*f[e+1],h)for(let t=0;t<n;t++)i=o*p.get(t,e)+s*p.get(t,e+1),p.set(t,e+1,-s*p.get(t,e)+o*p.get(t,e+1)),p.set(t,e,i);if(i=hypotenuse(x,y),0===i&&(i=Number.MIN_VALUE),o=x/i,s=y/i,f[e]=i,x=o*d[e]+s*f[e+1],f[e+1]=-s*d[e]+o*f[e+1],y=s*d[e+1],d[e+1]=o*d[e+1],l&&e<r-1)for(let t=0;t<r;t++)i=o*g.get(t,e)+s*g.get(t,e+1),g.set(t,e+1,-s*g.get(t,e)+o*g.get(t,e+1)),g.set(t,e,i)}d[b-2]=x;break}case 4:if(f[t]<=0&&(f[t]=f[t]<0?-f[t]:0,h))for(let e=0;e<=S;e++)p.set(e,t,-p.get(e,t));for(;t<S&&!(f[t]>=f[t+1]);){let e=f[t];if(f[t]=f[t+1],f[t+1]=e,h&&t<n-1)for(let r=0;r<n;r++)e=p.get(r,t+1),p.set(r,t+1,p.get(r,t)),p.set(r,t,e);if(l&&t<r-1)for(let n=0;n<r;n++)e=g.get(n,t+1),g.set(n,t+1,g.get(n,t)),g.set(n,t,e);t++}b--}}if(u){let t=p;p=g,g=t}this.m=r,this.n=n,this.s=f,this.U=g,this.V=p}solve(t){let e=t,r=this.threshold,n=this.s.length,i=Matrix.zeros(n,n);for(let t=0;t<n;t++)Math.abs(this.s[t])<=r?i.set(t,t,0):i.set(t,t,1/this.s[t]);let o=this.U,s=this.rightSingularVectors,a=s.mmul(i),l=s.rows,h=o.rows,u=Matrix.zeros(l,h);for(let t=0;t<l;t++)for(let e=0;e<h;e++){let r=0;for(let i=0;i<n;i++)r+=a.get(t,i)*o.get(e,i);u.set(t,e,r)}return u.mmul(e)}solveForDiagonal(t){return this.solve(Matrix.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,n=t.columns,i=new Matrix(r,this.s.length);for(let o=0;o<r;o++)for(let r=0;r<n;r++)Math.abs(this.s[r])>e&&i.set(o,r,t.get(o,r)/this.s[r]);let o=this.U,s=o.rows,a=o.columns,l=new Matrix(r,s);for(let t=0;t<r;t++)for(let e=0;e<s;e++){let r=0;for(let n=0;n<a;n++)r+=i.get(t,n)*o.get(e,n);l.set(t,e,r)}return l}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let n=0,i=r.length;n<i;n++)r[n]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix.diag(this.s)}}function inverse(t,e=!1){return t=WrapperMatrix2D.checkMatrix(t),e?new SingularValueDecomposition(t).inverse():solve(t,Matrix.eye(t.rows))}function solve(t,e,r=!1){return t=WrapperMatrix2D.checkMatrix(t),e=WrapperMatrix2D.checkMatrix(e),r?new SingularValueDecomposition(t).solve(e):t.isSquare()?new LuDecomposition(t).solve(e):new QrDecomposition(t).solve(e)}function determinant(t){if((t=Matrix.checkMatrix(t)).isSquare()){let e,r,n,i;if(2===t.columns)return e=t.get(0,0),r=t.get(0,1),n=t.get(1,0),i=t.get(1,1),e*i-r*n;if(3===t.columns){let i,o,s;return i=new MatrixSelectionView(t,[1,2],[1,2]),o=new MatrixSelectionView(t,[1,2],[0,2]),s=new MatrixSelectionView(t,[1,2],[0,1]),e=t.get(0,0),r=t.get(0,1),n=t.get(0,2),e*determinant(i)-r*determinant(o)+n*determinant(s)}return new LuDecomposition(t).determinant}throw Error("determinant can only be calculated for a square matrix")}function xrange(t,e){let r=[];for(let n=0;n<t;n++)n!==e&&r.push(n);return r}function dependenciesOneRow(t,e,r,n=1e-9,i=1e-9){if(t>i)return new Array(e.rows+1).fill(0);{let t=e.addRow(r,[0]);for(let e=0;e<t.rows;e++)Math.abs(t.get(e,0))<n&&t.set(e,0,0);return t.to1DArray()}}function linearDependencies(t,e={}){const{thresholdValue:r=1e-9,thresholdError:n=1e-9}=e;let i=(t=Matrix.checkMatrix(t)).rows,o=new Matrix(i,i);for(let e=0;e<i;e++){let s=Matrix.columnVector(t.getRow(e)),a=t.subMatrixRow(xrange(i,e)).transpose(),l=new SingularValueDecomposition(a).solve(s),h=Matrix.sub(s,a.mmul(l)).abs().max();o.setRow(e,dependenciesOneRow(h,l,e,r,n))}return o}function pseudoInverse(t,e=Number.EPSILON){t=Matrix.checkMatrix(t);let r=new SingularValueDecomposition(t,{autoTranspose:!0}),n=r.leftSingularVectors,i=r.rightSingularVectors,o=r.diagonal;for(let t=0;t<o.length;t++)Math.abs(o[t])>e?o[t]=1/o[t]:o[t]=0;return i.mmul(Matrix.diag(o).mmul(n.transpose()))}function covariance(t,e=t,r={}){t=new Matrix(t);let n=!1;if("object"!=typeof e||Matrix.isMatrix(e)||Array.isArray(e)?e=new Matrix(e):(r=e,e=t,n=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:i=!0}=r;i&&(t=t.center("column"),n||(e=e.center("column")));const o=t.transpose().mmul(e);for(let e=0;e<o.rows;e++)for(let r=0;r<o.columns;r++)o.set(e,r,o.get(e,r)*(1/(t.rows-1)));return o}function correlation(t,e=t,r={}){t=new Matrix(t);let n=!1;if("object"!=typeof e||Matrix.isMatrix(e)||Array.isArray(e)?e=new Matrix(e):(r=e,e=t,n=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:i=!0,scale:o=!0}=r;i&&(t.center("column"),n||e.center("column")),o&&(t.scale("column"),n||e.scale("column"));const s=t.standardDeviation("column",{unbiased:!0}),a=n?s:e.standardDeviation("column",{unbiased:!0}),l=t.transpose().mmul(e);for(let e=0;e<l.rows;e++)for(let r=0;r<l.columns;r++)l.set(e,r,l.get(e,r)*(1/(s[e]*a[r]))*(1/(t.rows-1)));return l}class EigenvalueDecomposition{constructor(t,e={}){const{assumeSymmetric:r=!1}=e;if(!(t=WrapperMatrix2D.checkMatrix(t)).isSquare())throw new Error("Matrix is not a square matrix");let n,i,o=t.columns,s=new Matrix(o,o),a=new Float64Array(o),l=new Float64Array(o),h=t,u=!1;if(u=!!r||t.isSymmetric(),u){for(n=0;n<o;n++)for(i=0;i<o;i++)s.set(n,i,h.get(n,i));tred2(o,l,a,s),tql2(o,l,a,s)}else{let t=new Matrix(o,o),e=new Float64Array(o);for(i=0;i<o;i++)for(n=0;n<o;n++)t.set(n,i,h.get(n,i));orthes(o,t,e,s),hqr2(o,l,a,s,t)}this.n=o,this.e=l,this.d=a,this.V=s}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t,e,r=this.n,n=this.e,i=this.d,o=new Matrix(r,r);for(t=0;t<r;t++){for(e=0;e<r;e++)o.set(t,e,0);o.set(t,t,i[t]),n[t]>0?o.set(t,t+1,n[t]):n[t]<0&&o.set(t,t-1,n[t])}return o}}function tred2(t,e,r,n){let i,o,s,a,l,h,u,c;for(l=0;l<t;l++)r[l]=n.get(t-1,l);for(a=t-1;a>0;a--){for(c=0,s=0,h=0;h<a;h++)c+=Math.abs(r[h]);if(0===c)for(e[a]=r[a-1],l=0;l<a;l++)r[l]=n.get(a-1,l),n.set(a,l,0),n.set(l,a,0);else{for(h=0;h<a;h++)r[h]/=c,s+=r[h]*r[h];for(i=r[a-1],o=Math.sqrt(s),i>0&&(o=-o),e[a]=c*o,s-=i*o,r[a-1]=i-o,l=0;l<a;l++)e[l]=0;for(l=0;l<a;l++){for(i=r[l],n.set(l,a,i),o=e[l]+n.get(l,l)*i,h=l+1;h<=a-1;h++)o+=n.get(h,l)*r[h],e[h]+=n.get(h,l)*i;e[l]=o}for(i=0,l=0;l<a;l++)e[l]/=s,i+=e[l]*r[l];for(u=i/(s+s),l=0;l<a;l++)e[l]-=u*r[l];for(l=0;l<a;l++){for(i=r[l],o=e[l],h=l;h<=a-1;h++)n.set(h,l,n.get(h,l)-(i*e[h]+o*r[h]));r[l]=n.get(a-1,l),n.set(a,l,0)}}r[a]=s}for(a=0;a<t-1;a++){if(n.set(t-1,a,n.get(a,a)),n.set(a,a,1),s=r[a+1],0!==s){for(h=0;h<=a;h++)r[h]=n.get(h,a+1)/s;for(l=0;l<=a;l++){for(o=0,h=0;h<=a;h++)o+=n.get(h,a+1)*n.get(h,l);for(h=0;h<=a;h++)n.set(h,l,n.get(h,l)-o*r[h])}}for(h=0;h<=a;h++)n.set(h,a+1,0)}for(l=0;l<t;l++)r[l]=n.get(t-1,l),n.set(t-1,l,0);n.set(t-1,t-1,1),e[0]=0}function tql2(t,e,r,n){let i,o,s,a,l,h,u,c,m,f,g,p,d,w,x,y;for(s=1;s<t;s++)e[s-1]=e[s];e[t-1]=0;let M=0,v=0,b=Number.EPSILON;for(h=0;h<t;h++){for(v=Math.max(v,Math.abs(r[h])+Math.abs(e[h])),u=h;u<t&&!(Math.abs(e[u])<=b*v);)u++;if(u>h)do{for(i=r[h],c=(r[h+1]-i)/(2*e[h]),m=hypotenuse(c,1),c<0&&(m=-m),r[h]=e[h]/(c+m),r[h+1]=e[h]*(c+m),f=r[h+1],o=i-r[h],s=h+2;s<t;s++)r[s]-=o;for(M+=o,c=r[u],g=1,p=g,d=g,w=e[h+1],x=0,y=0,s=u-1;s>=h;s--)for(d=p,p=g,y=x,i=g*e[s],o=g*c,m=hypotenuse(c,e[s]),e[s+1]=x*m,x=e[s]/m,g=c/m,c=g*r[s]-x*i,r[s+1]=o+x*(g*i+x*r[s]),l=0;l<t;l++)o=n.get(l,s+1),n.set(l,s+1,x*n.get(l,s)+g*o),n.set(l,s,g*n.get(l,s)-x*o);c=-x*y*d*w*e[h]/f,e[h]=x*c,r[h]=g*c}while(Math.abs(e[h])>b*v);r[h]=r[h]+M,e[h]=0}for(s=0;s<t-1;s++){for(l=s,c=r[s],a=s+1;a<t;a++)r[a]<c&&(l=a,c=r[a]);if(l!==s)for(r[l]=r[s],r[s]=c,a=0;a<t;a++)c=n.get(a,s),n.set(a,s,n.get(a,l)),n.set(a,l,c)}}function orthes(t,e,r,n){let i,o,s,a,l,h,u,c=t-1;for(h=1;h<=c-1;h++){for(u=0,a=h;a<=c;a++)u+=Math.abs(e.get(a,h-1));if(0!==u){for(s=0,a=c;a>=h;a--)r[a]=e.get(a,h-1)/u,s+=r[a]*r[a];for(o=Math.sqrt(s),r[h]>0&&(o=-o),s-=r[h]*o,r[h]=r[h]-o,l=h;l<t;l++){for(i=0,a=c;a>=h;a--)i+=r[a]*e.get(a,l);for(i/=s,a=h;a<=c;a++)e.set(a,l,e.get(a,l)-i*r[a])}for(a=0;a<=c;a++){for(i=0,l=c;l>=h;l--)i+=r[l]*e.get(a,l);for(i/=s,l=h;l<=c;l++)e.set(a,l,e.get(a,l)-i*r[l])}r[h]=u*r[h],e.set(h,h-1,u*o)}}for(a=0;a<t;a++)for(l=0;l<t;l++)n.set(a,l,a===l?1:0);for(h=c-1;h>=1;h--)if(0!==e.get(h,h-1)){for(a=h+1;a<=c;a++)r[a]=e.get(a,h-1);for(l=h;l<=c;l++){for(o=0,a=h;a<=c;a++)o+=r[a]*n.get(a,l);for(o=o/r[h]/e.get(h,h-1),a=h;a<=c;a++)n.set(a,l,n.get(a,l)+o*r[a])}}}function hqr2(t,e,r,n,i){let o,s,a,l,h,u,c,m,f,g,p,d,w,x,y,M=t-1,v=t-1,b=Number.EPSILON,S=0,A=0,E=0,R=0,k=0,N=0,C=0,T=0;for(o=0;o<t;o++)for((o<0||o>v)&&(r[o]=i.get(o,o),e[o]=0),s=Math.max(o-1,0);s<t;s++)A+=Math.abs(i.get(o,s));for(;M>=0;){for(l=M;l>0&&(N=Math.abs(i.get(l-1,l-1))+Math.abs(i.get(l,l)),0===N&&(N=A),!(Math.abs(i.get(l,l-1))<b*N));)l--;if(l===M)i.set(M,M,i.get(M,M)+S),r[M]=i.get(M,M),e[M]=0,M--,T=0;else if(l===M-1){if(c=i.get(M,M-1)*i.get(M-1,M),E=(i.get(M-1,M-1)-i.get(M,M))/2,R=E*E+c,C=Math.sqrt(Math.abs(R)),i.set(M,M,i.get(M,M)+S),i.set(M-1,M-1,i.get(M-1,M-1)+S),m=i.get(M,M),R>=0){for(C=E>=0?E+C:E-C,r[M-1]=m+C,r[M]=r[M-1],0!==C&&(r[M]=m-c/C),e[M-1]=0,e[M]=0,m=i.get(M,M-1),N=Math.abs(m)+Math.abs(C),E=m/N,R=C/N,k=Math.sqrt(E*E+R*R),E/=k,R/=k,s=M-1;s<t;s++)C=i.get(M-1,s),i.set(M-1,s,R*C+E*i.get(M,s)),i.set(M,s,R*i.get(M,s)-E*C);for(o=0;o<=M;o++)C=i.get(o,M-1),i.set(o,M-1,R*C+E*i.get(o,M)),i.set(o,M,R*i.get(o,M)-E*C);for(o=0;o<=v;o++)C=n.get(o,M-1),n.set(o,M-1,R*C+E*n.get(o,M)),n.set(o,M,R*n.get(o,M)-E*C)}else r[M-1]=m+E,r[M]=m+E,e[M-1]=C,e[M]=-C;M-=2,T=0}else{if(m=i.get(M,M),f=0,c=0,l<M&&(f=i.get(M-1,M-1),c=i.get(M,M-1)*i.get(M-1,M)),10===T){for(S+=m,o=0;o<=M;o++)i.set(o,o,i.get(o,o)-m);N=Math.abs(i.get(M,M-1))+Math.abs(i.get(M-1,M-2)),m=f=.75*N,c=-.4375*N*N}if(30===T&&(N=(f-m)/2,N=N*N+c,N>0)){for(N=Math.sqrt(N),f<m&&(N=-N),N=m-c/((f-m)/2+N),o=0;o<=M;o++)i.set(o,o,i.get(o,o)-N);S+=N,m=f=c=.964}for(T+=1,h=M-2;h>=l&&(C=i.get(h,h),k=m-C,N=f-C,E=(k*N-c)/i.get(h+1,h)+i.get(h,h+1),R=i.get(h+1,h+1)-C-k-N,k=i.get(h+2,h+1),N=Math.abs(E)+Math.abs(R)+Math.abs(k),E/=N,R/=N,k/=N,h!==l)&&!(Math.abs(i.get(h,h-1))*(Math.abs(R)+Math.abs(k))<b*(Math.abs(E)*(Math.abs(i.get(h-1,h-1))+Math.abs(C)+Math.abs(i.get(h+1,h+1)))));)h--;for(o=h+2;o<=M;o++)i.set(o,o-2,0),o>h+2&&i.set(o,o-3,0);for(a=h;a<=M-1&&(x=a!==M-1,a!==h&&(E=i.get(a,a-1),R=i.get(a+1,a-1),k=x?i.get(a+2,a-1):0,m=Math.abs(E)+Math.abs(R)+Math.abs(k),0!==m&&(E/=m,R/=m,k/=m)),0!==m);a++)if(N=Math.sqrt(E*E+R*R+k*k),E<0&&(N=-N),0!==N){for(a!==h?i.set(a,a-1,-N*m):l!==h&&i.set(a,a-1,-i.get(a,a-1)),E+=N,m=E/N,f=R/N,C=k/N,R/=E,k/=E,s=a;s<t;s++)E=i.get(a,s)+R*i.get(a+1,s),x&&(E+=k*i.get(a+2,s),i.set(a+2,s,i.get(a+2,s)-E*C)),i.set(a,s,i.get(a,s)-E*m),i.set(a+1,s,i.get(a+1,s)-E*f);for(o=0;o<=Math.min(M,a+3);o++)E=m*i.get(o,a)+f*i.get(o,a+1),x&&(E+=C*i.get(o,a+2),i.set(o,a+2,i.get(o,a+2)-E*k)),i.set(o,a,i.get(o,a)-E),i.set(o,a+1,i.get(o,a+1)-E*R);for(o=0;o<=v;o++)E=m*n.get(o,a)+f*n.get(o,a+1),x&&(E+=C*n.get(o,a+2),n.set(o,a+2,n.get(o,a+2)-E*k)),n.set(o,a,n.get(o,a)-E),n.set(o,a+1,n.get(o,a+1)-E*R)}}}if(0!==A){for(M=t-1;M>=0;M--)if(E=r[M],R=e[M],0===R)for(l=M,i.set(M,M,1),o=M-1;o>=0;o--){for(c=i.get(o,o)-E,k=0,s=l;s<=M;s++)k+=i.get(o,s)*i.get(s,M);if(e[o]<0)C=c,N=k;else if(l=o,0===e[o]?i.set(o,M,0!==c?-k/c:-k/(b*A)):(m=i.get(o,o+1),f=i.get(o+1,o),R=(r[o]-E)*(r[o]-E)+e[o]*e[o],u=(m*N-C*k)/R,i.set(o,M,u),i.set(o+1,M,Math.abs(m)>Math.abs(C)?(-k-c*u)/m:(-N-f*u)/C)),u=Math.abs(i.get(o,M)),b*u*u>1)for(s=o;s<=M;s++)i.set(s,M,i.get(s,M)/u)}else if(R<0)for(l=M-1,Math.abs(i.get(M,M-1))>Math.abs(i.get(M-1,M))?(i.set(M-1,M-1,R/i.get(M,M-1)),i.set(M-1,M,-(i.get(M,M)-E)/i.get(M,M-1))):(y=cdiv(0,-i.get(M-1,M),i.get(M-1,M-1)-E,R),i.set(M-1,M-1,y[0]),i.set(M-1,M,y[1])),i.set(M,M-1,0),i.set(M,M,1),o=M-2;o>=0;o--){for(g=0,p=0,s=l;s<=M;s++)g+=i.get(o,s)*i.get(s,M-1),p+=i.get(o,s)*i.get(s,M);if(c=i.get(o,o)-E,e[o]<0)C=c,k=g,N=p;else if(l=o,0===e[o]?(y=cdiv(-g,-p,c,R),i.set(o,M-1,y[0]),i.set(o,M,y[1])):(m=i.get(o,o+1),f=i.get(o+1,o),d=(r[o]-E)*(r[o]-E)+e[o]*e[o]-R*R,w=2*(r[o]-E)*R,0===d&&0===w&&(d=b*A*(Math.abs(c)+Math.abs(R)+Math.abs(m)+Math.abs(f)+Math.abs(C))),y=cdiv(m*k-C*g+R*p,m*N-C*p-R*g,d,w),i.set(o,M-1,y[0]),i.set(o,M,y[1]),Math.abs(m)>Math.abs(C)+Math.abs(R)?(i.set(o+1,M-1,(-g-c*i.get(o,M-1)+R*i.get(o,M))/m),i.set(o+1,M,(-p-c*i.get(o,M)-R*i.get(o,M-1))/m)):(y=cdiv(-k-f*i.get(o,M-1),-N-f*i.get(o,M),C,R),i.set(o+1,M-1,y[0]),i.set(o+1,M,y[1]))),u=Math.max(Math.abs(i.get(o,M-1)),Math.abs(i.get(o,M))),b*u*u>1)for(s=o;s<=M;s++)i.set(s,M-1,i.get(s,M-1)/u),i.set(s,M,i.get(s,M)/u)}for(o=0;o<t;o++)if(o<0||o>v)for(s=o;s<t;s++)n.set(o,s,i.get(o,s));for(s=t-1;s>=0;s--)for(o=0;o<=v;o++){for(C=0,a=0;a<=Math.min(s,v);a++)C+=n.get(o,a)*i.get(a,s);n.set(o,s,C)}}}function cdiv(t,e,r,n){let i,o;return Math.abs(r)>Math.abs(n)?(i=n/r,o=r+i*n,[(t+i*e)/o,(e-i*t)/o]):(i=r/n,o=n+i*r,[(i*t+e)/o,(i*e-t)/o])}class CholeskyDecomposition{constructor(t){if(!(t=WrapperMatrix2D.checkMatrix(t)).isSymmetric())throw new Error("Matrix is not symmetric");let e,r,n,i=t,o=i.rows,s=new Matrix(o,o),a=!0;for(r=0;r<o;r++){let t=0;for(n=0;n<r;n++){let o=0;for(e=0;e<n;e++)o+=s.get(n,e)*s.get(r,e);o=(i.get(r,n)-o)/s.get(n,n),s.set(r,n,o),t+=o*o}for(t=i.get(r,r)-t,a&=t>0,s.set(r,r,Math.sqrt(Math.max(t,0))),n=r+1;n<o;n++)s.set(r,n,0)}this.L=s,this.positiveDefinite=Boolean(a)}isPositiveDefinite(){return this.positiveDefinite}solve(t){t=WrapperMatrix2D.checkMatrix(t);let e=this.L,r=e.rows;if(t.rows!==r)throw new Error("Matrix dimensions do not match");if(!1===this.isPositiveDefinite())throw new Error("Matrix is not positive definite");let n,i,o,s=t.columns,a=t.clone();for(o=0;o<r;o++)for(i=0;i<s;i++){for(n=0;n<o;n++)a.set(o,i,a.get(o,i)-a.get(n,i)*e.get(o,n));a.set(o,i,a.get(o,i)/e.get(o,o))}for(o=r-1;o>=0;o--)for(i=0;i<s;i++){for(n=o+1;n<r;n++)a.set(o,i,a.get(o,i)-a.get(n,i)*e.get(n,o));a.set(o,i,a.get(o,i)/e.get(o,o))}return a}get lowerTriangularMatrix(){return this.L}}class nipals{constructor(t,e={}){t=WrapperMatrix2D.checkMatrix(t);let{Y:r}=e;const{scaleScores:n=!1,maxIterations:i=1e3,terminationCriteria:o=1e-10}=e;let s;if(r){if(r=Array.isArray(r)&&"number"==typeof r[0]?Matrix.columnVector(r):WrapperMatrix2D.checkMatrix(r),!r.isColumnVector()||r.rows!==t.rows)throw new Error("Y must be a column vector of length X.rows");s=r}else s=t.getColumnVector(0);let a,l,h,u,c=1;for(let e=0;e<i&&c>o;e++)h=t.transpose().mmul(s).div(s.transpose().mmul(s).get(0,0)),h=h.div(h.norm()),a=t.mmul(h).div(h.transpose().mmul(h).get(0,0)),e>0&&(c=a.clone().sub(u).pow(2).sum()),u=a.clone(),r?(l=r.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),l=l.div(l.norm()),s=r.mmul(l).div(l.transpose().mmul(l).get(0,0))):s=a;if(r){let e=t.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0));e=e.div(e.norm());let n=t.clone().sub(a.clone().mmul(e.transpose())),i=s.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),o=r.clone().sub(a.clone().mulS(i.get(0,0)).mmul(l.transpose()));this.t=a,this.p=e.transpose(),this.w=h.transpose(),this.q=l,this.u=s,this.s=a.transpose().mmul(a),this.xResidual=n,this.yResidual=o,this.betas=i}else this.w=h.transpose(),this.s=a.transpose().mmul(a).sqrt(),this.t=n?a.clone().div(this.s.get(0,0)):a,this.xResidual=t.sub(a.mmul(h.transpose()))}}var MatrixLib=Object.freeze({__proto__:null,AbstractMatrix:AbstractMatrix,default:Matrix,Matrix:Matrix,wrap:wrap,WrapperMatrix1D:WrapperMatrix1D,WrapperMatrix2D:WrapperMatrix2D,solve:solve,inverse:inverse,determinant:determinant,linearDependencies:linearDependencies,pseudoInverse:pseudoInverse,covariance:covariance,correlation:correlation,SingularValueDecomposition:SingularValueDecomposition,SVD:SingularValueDecomposition,EigenvalueDecomposition:EigenvalueDecomposition,EVD:EigenvalueDecomposition,CholeskyDecomposition:CholeskyDecomposition,CHO:CholeskyDecomposition,LuDecomposition:LuDecomposition,LU:LuDecomposition,QrDecomposition:QrDecomposition,QR:QrDecomposition,Nipals:nipals,NIPALS:nipals,MatrixColumnView:MatrixColumnView,MatrixColumnSelectionView:MatrixColumnSelectionView,MatrixFlipColumnView:MatrixFlipColumnView,MatrixFlipRowView:MatrixFlipRowView,MatrixRowView:MatrixRowView,MatrixRowSelectionView:MatrixRowSelectionView,MatrixSelectionView:MatrixSelectionView,MatrixSubView:MatrixSubView,MatrixTransposeView:MatrixTransposeView});const toString$1=Object.prototype.toString;function isAnyArray$1(t){return toString$1.call(t).endsWith("Array]")}function sum(t){if(!isAnyArray$1(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0;r<t.length;r++)e+=t[r];return e}function mean(t){return sum(t)/t.length}function toDiscreteDistribution(t,e){let r=new Array(e).fill(0);for(let e=0;e<t.length;++e)r[t[e]]+=1/t.length;return Matrix.rowVector(r)}function giniImpurity(t){if(0===t.length)return 0;let e=toDiscreteDistribution(t,getNumberOfClasses(t)).getRow(0),r=0;for(let t=0;t<e.length;++t)r+=e[t]*e[t];return 1-r}function getNumberOfClasses(t){return t.filter((function(t,e,r){return r.indexOf(t)===e})).map((t=>t+1)).reduce(((t,e)=>Math.max(t,e)))}function giniGain(t,e){let r=0,n=["greater","lesser"];for(let i=0;i<n.length;++i){let o=e[n[i]];r+=giniImpurity(o)*o.length/t.length}return giniImpurity(t)-r}function squaredError(t){let e=t.length,r=mean(t),n=0;for(let i=0;i<e;++i){let e=t[i];n+=(e-r)*(e-r)}return n}function regressionError(t,e){let r=0,n=["greater","lesser"];for(let t=0;t<n.length;++t){r+=squaredError(e[n[t]])}return r}function matrixSplitter(t,e,r,n){let i=[],o=[],s=[],a=[];for(let l=0;l<t.rows;++l)t.get(l,r)<n?(i.push(t.getRow(l)),s.push(e[l])):(o.push(t.getRow(l)),a.push(e[l]));return{greaterX:o,greaterY:a,lesserX:i,lesserY:s}}function mean$1(t,e){return(t+e)/2}function zip(t,e){if(t.length!==e.length)throw new TypeError(`Error on zip: the size of a: ${t.length} is different from b: ${e.length}`);let r=new Array(t.length);for(let n=0;n<t.length;++n)r[n]=[t[n],e[n]];return r}const gainFunctions={gini:giniGain,regression:regressionError},splitFunctions={mean:mean$1};class TreeNode{constructor(t){this.kind=t.kind,this.gainFunction=t.gainFunction,this.splitFunction=t.splitFunction,this.minNumSamples=t.minNumSamples,this.maxDepth=t.maxDepth}bestSplit(t,e){let r,n,i="classifier"===this.kind?-1/0:1/0,o="classifier"===this.kind?(t,e)=>t>e:(t,e)=>t<e;for(let s=0;s<t.rows;++s){let a=t.getRow(s),l=this.featureSplit(a,e);for(let t=0;t<l.length;++t){let h=l[t],u=this.split(a,e,h),c=gainFunctions[this.gainFunction](e,u);o(c,i)&&(r=s,n=h,i=c)}}return{maxGain:i,maxColumn:r,maxValue:n}}split(t,e,r){let n=[],i=[];for(let o=0;o<t.length;++o)t[o]<r?n.push(e[o]):i.push(e[o]);return{greater:i,lesser:n}}featureSplit(t,e){let r=[],n=zip(t,e);n.sort((function(t,e){return t[0]-e[0]}));for(let t=1;t<n.length;++t)n[t-1][1]!==n[t][1]&&r.push(splitFunctions[this.splitFunction](n[t-1][0],n[t][0]));return r}calculatePrediction(t){if("classifier"===this.kind){if(this.distribution=toDiscreteDistribution(t,getNumberOfClasses(t)),0===this.distribution.columns)throw new TypeError("Error on calculate the prediction")}else this.distribution=mean(t)}train(t,e,r,n){if(t.rows<=this.minNumSamples)return void this.calculatePrediction(e);void 0===n&&(n=0);let i=t.transpose(),o=this.bestSplit(i,e);this.splitValue=o.maxValue,this.splitColumn=o.maxColumn,this.gain=o.maxGain;let s=matrixSplitter(t,e,this.splitColumn,this.splitValue);if(r<this.maxDepth&&this.gain>.01&&this.gain!==n&&s.lesserX.length>0&&s.greaterX.length>0){this.left=new TreeNode(this),this.right=new TreeNode(this);let t=new Matrix(s.lesserX),e=new Matrix(s.greaterX);this.left.train(t,s.lesserY,r+1,this.gain),this.right.train(e,s.greaterY,r+1,this.gain)}else this.calculatePrediction(e)}classify(t){return this.right&&this.left?t[this.splitColumn]<this.splitValue?this.left.classify(t):this.right.classify(t):this.distribution}setNodeParameters(t){void 0!==t.distribution?this.distribution=t.distribution.constructor===Array?new Matrix(t.distribution):t.distribution:(this.distribution=void 0,this.splitValue=t.splitValue,this.splitColumn=t.splitColumn,this.gain=t.gain,this.left=new TreeNode(this),this.right=new TreeNode(this),t.left!=={}&&this.left.setNodeParameters(t.left),t.right!=={}&&this.right.setNodeParameters(t.right))}}const defaultOptions={gainFunction:"gini",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class DecisionTreeClassifier{constructor(t,e){!0===t?(this.options=e.options,this.root=new TreeNode(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},defaultOptions,t),this.options.kind="classifier")}train(t,e){this.root=new TreeNode(this.options),t=Matrix.checkMatrix(t),this.root.train(t,e,0,null)}predict(t){t=Matrix.checkMatrix(t);let e=new Array(t.rows);for(let r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r)).maxRowIndex(0)[1];return e}toJSON(){return{options:this.options,root:this.root,name:"DTClassifier"}}static load(t){if("DTClassifier"!==t.name)throw new RangeError("Invalid model: "+t.name);return new DecisionTreeClassifier(!0,t)}}const defaultOptions$1={gainFunction:"regression",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class DecisionTreeRegression{constructor(t,e){!0===t?(this.options=e.options,this.root=new TreeNode(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},defaultOptions$1,t),this.options.kind="regression")}train(t,e){this.root=new TreeNode(this.options),t=void 0!==t[0]&&void 0===t[0].length?Matrix.columnVector(t):Matrix.checkMatrix(t),this.root.train(t,e,0)}predict(t){void 0!==t[0]&&void 0===t[0].length&&(t=Matrix.columnVector(t)),t=Matrix.checkMatrix(t);let e=new Array(t.rows);for(let r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r));return e}toJSON(){return{options:this.options,root:this.root,name:"DTRegression"}}static load(t){if("DTRegression"!==t.name)throw new RangeError("Invalid model:"+t.name);return new DecisionTreeRegression(!0,t)}}const SMALLEST_UNSAFE_INTEGER=9007199254740992,LARGEST_SAFE_INTEGER=SMALLEST_UNSAFE_INTEGER-1,UINT32_MAX=-1>>>0,UINT32_SIZE=UINT32_MAX+1,INT32_SIZE=UINT32_SIZE/2,INT32_MAX=INT32_SIZE-1,UINT21_SIZE=1<<21,UINT21_MAX=UINT21_SIZE-1;function int32(t){return 0|t.next()}function add(t,e){return 0===e?t:r=>t(r)+e}function int53(t){const e=0|t.next(),r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r+(e&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}function int53Full(t){for(;;){const e=0|t.next();if(!(4194304&e)){const r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r+(e&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}if(4194304==(8388607&e)&&0==(0|t.next()))return SMALLEST_UNSAFE_INTEGER}}function uint32(t){return t.next()>>>0}function uint53(t){const e=t.next()&UINT21_MAX,r=t.next()>>>0;return e*UINT32_SIZE+r}function uint53Full(t){for(;;){const e=0|t.next();if(!(e&UINT21_SIZE)){const r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r}if(0==(e&UINT21_MAX)&&0==(0|t.next()))return SMALLEST_UNSAFE_INTEGER}}function isPowerOfTwoMinusOne(t){return 0==(t+1&t)}function bitmask(t){return e=>e.next()&t}function downscaleToLoopCheckedRange(t){const e=t+1,r=e*Math.floor(UINT32_SIZE/e);return t=>{let n=0;do{n=t.next()>>>0}while(n>=r);return n%e}}function downscaleToRange(t){return isPowerOfTwoMinusOne(t)?bitmask(t):downscaleToLoopCheckedRange(t)}function isEvenlyDivisibleByMaxInt32(t){return 0==(0|t)}function upscaleWithHighMasking(t){return e=>{const r=e.next()&t,n=e.next()>>>0;return r*UINT32_SIZE+n}}function upscaleToLoopCheckedRange(t){const e=t*Math.floor(SMALLEST_UNSAFE_INTEGER/t);return r=>{let n=0;do{const t=r.next()&UINT21_MAX,e=r.next()>>>0;n=t*UINT32_SIZE+e}while(n>=e);return n%t}}function upscaleWithinU53(t){const e=t+1;if(isEvenlyDivisibleByMaxInt32(e)){const t=(e/UINT32_SIZE|0)-1;if(isPowerOfTwoMinusOne(t))return upscaleWithHighMasking(t)}return upscaleToLoopCheckedRange(e)}function upscaleWithinI53AndLoopCheck(t,e){return r=>{let n=0;do{const t=0|r.next(),e=r.next()>>>0;n=(t&UINT21_MAX)*UINT32_SIZE+e+(t&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}while(n<t||n>e);return n}}function integer(t,e){if(t=Math.floor(t),e=Math.floor(e),t<-SMALLEST_UNSAFE_INTEGER||!isFinite(t))throw new RangeError("Expected min to be at least "+-SMALLEST_UNSAFE_INTEGER);if(e>SMALLEST_UNSAFE_INTEGER||!isFinite(e))throw new RangeError("Expected max to be at most "+SMALLEST_UNSAFE_INTEGER);const r=e-t;return r<=0||!isFinite(r)?()=>t:r===UINT32_MAX?0===t?uint32:add(int32,t+INT32_SIZE):r<UINT32_MAX?add(downscaleToRange(r),t):r===LARGEST_SAFE_INTEGER?add(uint53,t):r<LARGEST_SAFE_INTEGER?add(upscaleWithinU53(r),t):e-1-t===LARGEST_SAFE_INTEGER?add(uint53Full,t):t===-SMALLEST_UNSAFE_INTEGER&&e===SMALLEST_UNSAFE_INTEGER?int53Full:t===-SMALLEST_UNSAFE_INTEGER&&e===LARGEST_SAFE_INTEGER?int53:t===-LARGEST_SAFE_INTEGER&&e===SMALLEST_UNSAFE_INTEGER?add(int53,1):e===SMALLEST_UNSAFE_INTEGER?add(upscaleWithinI53AndLoopCheck(t-1,e-1),1):upscaleWithinI53AndLoopCheck(t,e)}const DEFAULT_STRING_POOL="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";function string(t=DEFAULT_STRING_POOL){const e=t.length;if(!e)throw new Error("Expected pool not to be an empty string");const r=integer(0,e-1);return(e,n)=>{let i="";for(let o=0;o<n;++o){const n=r(e);i+=t.charAt(n)}return i}}const LOWER_HEX_POOL="0123456789abcdef",lowerHex=string(LOWER_HEX_POOL),upperHex=string(LOWER_HEX_POOL.toUpperCase()),stringRepeat=(()=>{try{if("xxx"==="x".repeat(3))return(t,e)=>t.repeat(e)}catch(t){}return(t,e)=>{let r="";for(;e>0;)1&e&&(r+=t),e>>=1,t+=t;return r}})(),nativeMath={next:()=>Math.random()*UINT32_SIZE|0},I32Array=(()=>{try{const t=new ArrayBuffer(4),e=new Int32Array(t);if(e[0]=INT32_SIZE,e[0]===-INT32_SIZE)return Int32Array}catch(t){}return Array})();function createEntropy(t=nativeMath,e=16){const r=[];r.push(0|(new Date).getTime());for(let n=1;n<e;++n)r[n]=0|t.next();return r}const imul=(()=>{try{if(-5===Math.imul(UINT32_MAX,5))return Math.imul}catch(t){}const t=65535;return(e,r)=>{const n=e&t,i=r&t;return n*i+((e>>>16&t)*i+n*(r>>>16&t)<<16>>>0)|0}})(),ARRAY_SIZE=624,ARRAY_MAX=ARRAY_SIZE-1,M=397,ARRAY_SIZE_MINUS_M=ARRAY_SIZE-M,A=2567483615;class MersenneTwister19937{constructor(){this.data=new I32Array(ARRAY_SIZE),this.index=0,this.uses=0}static seed(t){return(new MersenneTwister19937).seed(t)}static seedWithArray(t){return(new MersenneTwister19937).seedWithArray(t)}static autoSeed(){return MersenneTwister19937.seedWithArray(createEntropy())}next(){(0|this.index)>=ARRAY_SIZE&&(refreshData(this.data),this.index=0);const t=this.data[this.index];return this.index=this.index+1|0,this.uses+=1,0|temper(t)}getUseCount(){return this.uses}discard(t){if(t<=0)return this;for(this.uses+=t,(0|this.index)>=ARRAY_SIZE&&(refreshData(this.data),this.index=0);t+this.index>ARRAY_SIZE;)t-=ARRAY_SIZE-this.index,refreshData(this.data),this.index=0;return this.index=this.index+t|0,this}seed(t){let e=0;this.data[0]=e=0|t;for(let t=1;t<ARRAY_SIZE;t=t+1|0)this.data[t]=e=imul(e^e>>>30,1812433253)+t|0;return this.index=ARRAY_SIZE,this.uses=0,this}seedWithArray(t){return this.seed(19650218),seedWithArray(this.data,t),this}}function refreshData(t){let e=0,r=0;for(;(0|e)<ARRAY_SIZE_MINUS_M;e=e+1|0)r=t[e]&INT32_SIZE|t[e+1|0]&INT32_MAX,t[e]=t[e+M|0]^r>>>1^(1&r?A:0);for(;(0|e)<ARRAY_MAX;e=e+1|0)r=t[e]&INT32_SIZE|t[e+1|0]&INT32_MAX,t[e]=t[e-ARRAY_SIZE_MINUS_M|0]^r>>>1^(1&r?A:0);r=t[ARRAY_MAX]&INT32_SIZE|t[0]&INT32_MAX,t[ARRAY_MAX]=t[M-1]^r>>>1^(1&r?A:0)}function temper(t){return t^=t>>>11,t^=t<<7&2636928640,(t^=t<<15&4022730752)^t>>>18}function seedWithArray(t,e){let r=1,n=0;const i=e.length;let o=0|Math.max(i,ARRAY_SIZE),s=0|t[0];for(;(0|o)>0;--o)t[r]=s=(t[r]^imul(s^s>>>30,1664525))+(0|e[n])+(0|n)|0,r=r+1|0,++n,(0|r)>ARRAY_MAX&&(t[0]=t[ARRAY_MAX],r=1),n>=i&&(n=0);for(o=ARRAY_MAX;(0|o)>0;--o)t[r]=s=(t[r]^imul(s^s>>>30,1566083941))-r|0,r=r+1|0,(0|r)>ARRAY_MAX&&(t[0]=t[ARRAY_MAX],r=1);t[0]=INT32_SIZE}function checkFloat(t){return t>0&&t<=1}function examplesBaggingWithReplacement(t,e,r){let n,i=integer(0,t.rows-1);if(void 0===r)n=MersenneTwister19937.autoSeed();else{if(!Number.isInteger(r))throw new RangeError("Expected seed must be undefined or integer not "+r);n=MersenneTwister19937.seed(r)}let o=new Array(t.rows),s=new Array(t.rows);for(let r=0;r<t.rows;++r){let a=i(n);o[r]=t.getRow(a),s[r]=e[a]}return{X:new Matrix(o),y:s}}function featureBagging(t,e,r,n){if(t.columns<e)throw new RangeError("N should be less or equal to the number of columns of X");let i,o=integer(0,t.columns-1);if(void 0===n)i=MersenneTwister19937.autoSeed();else{if(!Number.isInteger(n))throw new RangeError("Expected seed must be undefined or integer not "+n);i=MersenneTwister19937.seed(n)}let s,a,l=new Matrix(t.rows,e);if(r){s=new Array(e);for(let r=0;r<e;++r)a=o(i),s[r]=a,l.setColumn(r,t.getColumn(a))}else{s=new Set,a=o(i);for(let r=0;r<e;++r){for(;s.has(a);)a=o(i);l.setColumn(r,t.getColumn(a)),s.add(a)}s=Array.from(s)}return{X:l,usedIndex:s}}class RandomForestBase{constructor(t,e){if(!0===t){this.replacement=e.replacement,this.maxFeatures=e.maxFeatures,this.nEstimators=e.nEstimators,this.treeOptions=e.treeOptions,this.isClassifier=e.isClassifier,this.seed=e.seed,this.n=e.n,this.indexes=e.indexes,this.useSampleBagging=e.useSampleBagging;let t=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression;this.estimators=e.estimators.map((e=>t.load(e)))}else this.replacement=t.replacement,this.maxFeatures=t.maxFeatures,this.nEstimators=t.nEstimators,this.treeOptions=t.treeOptions,this.isClassifier=t.isClassifier,this.seed=t.seed,this.useSampleBagging=t.useSampleBagging}train(t,e){if(t=Matrix.checkMatrix(t),this.maxFeatures=this.maxFeatures||t.columns,checkFloat(this.maxFeatures))this.n=Math.floor(t.columns*this.maxFeatures);else{if(!Number.isInteger(this.maxFeatures))throw new RangeError("Cannot process the maxFeatures parameter "+this.maxFeatures);if(this.maxFeatures>t.columns)throw new RangeError("The maxFeatures parameter should be less than "+t.columns);this.n=this.maxFeatures}let r;r=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression,this.estimators=new Array(this.nEstimators),this.indexes=new Array(this.nEstimators);for(let n=0;n<this.nEstimators;++n){let i=this.useSampleBagging?examplesBaggingWithReplacement(t,e,this.seed):{X:t,y:e},o=i.X,s=i.y;i=featureBagging(o,this.n,this.replacement,this.seed),o=i.X,this.indexes[n]=i.usedIndex,this.estimators[n]=new r(this.treeOptions),this.estimators[n].train(o,s)}}selection(t){throw new Error("Abstract method 'selection' not implemented!")}predict(t){let e=new Array(this.nEstimators);t=Matrix.checkMatrix(t);for(let r=0;r<this.nEstimators;++r){let n=new MatrixColumnSelectionView(t,this.indexes[r]);e[r]=this.estimators[r].predict(n)}e=new MatrixTransposeView(new WrapperMatrix2D(e));let r=new Array(e.rows);for(let t=0;t<e.rows;++t)r[t]=this.selection(e.getRow(t));return r}toJSON(){return{indexes:this.indexes,n:this.n,replacement:this.replacement,maxFeatures:this.maxFeatures,nEstimators:this.nEstimators,treeOptions:this.treeOptions,isClassifier:this.isClassifier,seed:this.seed,estimators:this.estimators.map((t=>t.toJSON())),useSampleBagging:this.useSampleBagging}}}const defaultOptions$2={maxFeatures:1,replacement:!0,nEstimators:10,seed:42,useSampleBagging:!1};class RandomForestClassifier extends RandomForestBase{constructor(t,e){!0===t?super(!0,e.baseModel):((t=Object.assign({},defaultOptions$2,t)).isClassifier=!0,super(t))}selection(t){return mode(t)}toJSON(){return{baseModel:super.toJSON(),name:"RFClassifier"}}static load(t){if("RFClassifier"!==t.name)throw new RangeError("Invalid model: "+t.name);return new RandomForestClassifier(!0,t)}}function mode(t){return t.sort(((e,r)=>t.filter((t=>t===e)).length-t.filter((t=>t===r)).length)).pop()}const toString$2=Object.prototype.toString;function isAnyArray$2(t){return toString$2.call(t).endsWith("Array]")}var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(t,e,r){return t(r={path:e,exports:{},require:function(t,e){return commonjsRequire(t,null==e?r.path:e)}},r.exports),r.exports}function getAugmentedNamespace(t){if(t.__esModule)return t;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(t).forEach((function(r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})})),e}function commonjsRequire(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}var medianQuickselect_min=createCommonjsModule((function(t){!function(){function e(t){for(var e=0,i=t.length-1,o=void 0,s=void 0,a=void 0,l=n(e,i);;){if(i<=e)return t[l];if(i==e+1)return t[e]>t[i]&&r(t,e,i),t[l];for(t[o=n(e,i)]>t[i]&&r(t,o,i),t[e]>t[i]&&r(t,e,i),t[o]>t[e]&&r(t,o,e),r(t,o,e+1),s=e+1,a=i;;){do{s++}while(t[e]>t[s]);do{a--}while(t[a]>t[e]);if(a<s)break;r(t,s,a)}r(t,e,a),a<=l&&(e=s),a>=l&&(i=a-1)}}var r=function(t,e,r){var n;return n=[t[r],t[e]],t[e]=n[0],t[r]=n[1],n},n=function(t,e){return~~((t+e)/2)};t.exports?t.exports=e:window.median=e}()}));function median(t){if(!isAnyArray$2(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");return medianQuickselect_min(t.slice())}const selectionMethods={mean:mean,median:median},defaultOptions$3={maxFeatures:1,replacement:!1,nEstimators:10,treeOptions:{},selectionMethod:"mean",seed:42,useSampleBagging:!1};class RandomForestRegression extends RandomForestBase{constructor(t,e){if(!0===t)super(!0,e.baseModel),this.selectionMethod=e.selectionMethod;else{if("mean"!==(t=Object.assign({},defaultOptions$3,t)).selectionMethod&&"median"!==t.selectionMethod)throw new RangeError("Unsupported selection method "+t.selectionMethod);t.isClassifier=!1,super(t),this.selectionMethod=t.selectionMethod}}selection(t){return selectionMethods[this.selectionMethod](t)}toJSON(){return{baseModel:super.toJSON(),selectionMethod:this.selectionMethod,name:"RFRegression"}}static load(t){if("RFRegression"!==t.name)throw new RangeError("Invalid model: "+t.name);return new RandomForestRegression(!0,t)}}class PCA{constructor(t,e={}){if(!0===t){const t=e;return this.center=t.center,this.scale=t.scale,this.means=t.means,this.stdevs=t.stdevs,this.U=Matrix.checkMatrix(t.U),this.S=t.S,this.R=t.R,void(this.excludedFeatures=t.excludedFeatures||[])}t=new Matrix(t);const{isCovarianceMatrix:r=!1,method:n="SVD",nCompNIPALS:i=2,center:o=!0,scale:s=!1,ignoreZeroVariance:a=!1}=e;if(this.center=o,this.scale=s,this.means=null,this.stdevs=null,this.excludedFeatures=[],r)this._computeFromCovarianceMatrix(t);else switch(this._adjust(t,a),n){case"covarianceMatrix":{const e=new MatrixTransposeView(t).mmul(t).div(t.rows-1);this._computeFromCovarianceMatrix(e);break}case"NIPALS":this._computeWithNIPALS(t,i);break;case"SVD":{const e=new SingularValueDecomposition(t,{computeLeftSingularVectors:!1,computeRightSingularVectors:!0,autoTranspose:!0});this.U=e.rightSingularVectors;const r=e.diagonal,n=[];for(const e of r)n.push(e*e/(t.rows-1));this.S=n;break}default:throw new Error("unknown method: "+n)}}static load(t){if("string"!=typeof t.name)throw new TypeError("model must have a name property");if("PCA"!==t.name)throw new RangeError("invalid model: "+t.name);return new PCA(!0,t)}predict(t,e={}){const{nComponents:r=this.U.columns}=e;if(t=new Matrix(t),this.center&&(t.subRowVector(this.means),this.scale)){for(let e of this.excludedFeatures)t.removeColumn(e);t.divRowVector(this.stdevs)}var n=t.mmul(this.U);return n.subMatrix(0,n.rows-1,0,r-1)}invert(t){var e=(t=Matrix.checkMatrix(t)).mmul(this.U.transpose());return this.center&&(this.scale&&e.mulRowVector(this.stdevs),e.addRowVector(this.means)),e}getExplainedVariance(){var t=0;for(const e of this.S)t+=e;return this.S.map((e=>e/t))}getCumulativeVariance(){for(var t=this.getExplainedVariance(),e=1;e<t.length;e++)t[e]+=t[e-1];return t}getEigenvectors(){return this.U}getEigenvalues(){return this.S}getStandardDeviations(){return this.S.map((t=>Math.sqrt(t)))}getLoadings(){return this.U.transpose()}toJSON(){return{name:"PCA",center:this.center,scale:this.scale,means:this.means,stdevs:this.stdevs,U:this.U,S:this.S,excludedFeatures:this.excludedFeatures}}_adjust(t,e){if(this.center){const r=t.mean("column"),n=this.scale?t.standardDeviation("column",{mean:r}):null;if(this.means=r,t.subRowVector(r),this.scale){for(let r=0;r<n.length;r++)if(0===n[r]){if(!e)throw new RangeError("Cannot scale the dataset (standard deviation is zero at index "+r);t.removeColumn(r),n.splice(r,1),this.excludedFeatures.push(r),r--}this.stdevs=n,t.divRowVector(n)}}}_computeFromCovarianceMatrix(t){const e=new EigenvalueDecomposition(t,{assumeSymmetric:!0});this.U=e.eigenvectorMatrix,this.U.flipRows(),this.S=e.realEigenvalues,this.S.reverse()}_computeWithNIPALS(t,e){this.U=new Matrix(e,t.columns),this.S=[];let r=t;for(let t=0;t<e;t++){let e=new nipals(r);this.U.setRow(t,e.w.transpose()),this.S.push(Math.pow(e.s.get(0,0),2)),r=e.xResidual}this.U=this.U.transpose()}}function squaredEuclidean(t,e){let r=0;for(let n=0;n<t.length;n++)r+=(t[n]-e[n])*(t[n]-e[n]);return r}function euclidean(t,e){return Math.sqrt(squaredEuclidean(t,e))}var euclidean$1=Object.freeze({__proto__:null,squaredEuclidean:squaredEuclidean,euclidean:euclidean});function distanceMatrix(t,e){const r=getMatrix(t.length);for(let n=0;n<t.length;n++)for(let i=0;i<=n;i++)r[n][i]=e(t[n],t[i]),r[i][n]=r[n][i];return r}function getMatrix(t){const e=[];for(let r=0;r<t;r++){const r=[];e.push(r);for(let e=0;e<t;e++)r.push(0)}return e}var heap=createCommonjsModule((function(t,e){(function(){var e,r,n,i,o,s,a,l,h,u,c,m,f,g,p;n=Math.floor,u=Math.min,r=function(t,e){return t<e?-1:t>e?1:0},h=function(t,e,i,o,s){var a;if(null==i&&(i=0),null==s&&(s=r),i<0)throw new Error("lo must be non-negative");for(null==o&&(o=t.length);i<o;)s(e,t[a=n((i+o)/2)])<0?o=a:i=a+1;return[].splice.apply(t,[i,i-i].concat(e)),e},s=function(t,e,n){return null==n&&(n=r),t.push(e),g(t,0,t.length-1,n)},o=function(t,e){var n,i;return null==e&&(e=r),n=t.pop(),t.length?(i=t[0],t[0]=n,p(t,0,e)):i=n,i},l=function(t,e,n){var i;return null==n&&(n=r),i=t[0],t[0]=e,p(t,0,n),i},a=function(t,e,n){var i;return null==n&&(n=r),t.length&&n(t[0],e)<0&&(e=(i=[t[0],e])[0],t[0]=i[1],p(t,0,n)),e},i=function(t,e){var i,o,s,a,l,h;for(null==e&&(e=r),l=[],o=0,s=(a=function(){h=[];for(var e=0,r=n(t.length/2);0<=r?e<r:e>r;0<=r?e++:e--)h.push(e);return h}.apply(this).reverse()).length;o<s;o++)i=a[o],l.push(p(t,i,e));return l},f=function(t,e,n){var i;if(null==n&&(n=r),-1!==(i=t.indexOf(e)))return g(t,0,i,n),p(t,i,n)},c=function(t,e,n){var o,s,l,h,u;if(null==n&&(n=r),!(s=t.slice(0,e)).length)return s;for(i(s,n),l=0,h=(u=t.slice(e)).length;l<h;l++)o=u[l],a(s,o,n);return s.sort(n).reverse()},m=function(t,e,n){var s,a,l,c,m,f,g,p,d;if(null==n&&(n=r),10*e<=t.length){if(!(l=t.slice(0,e).sort(n)).length)return l;for(a=l[l.length-1],c=0,f=(g=t.slice(e)).length;c<f;c++)n(s=g[c],a)<0&&(h(l,s,0,null,n),l.pop(),a=l[l.length-1]);return l}for(i(t,n),d=[],m=0,p=u(e,t.length);0<=p?m<p:m>p;0<=p?++m:--m)d.push(o(t,n));return d},g=function(t,e,n,i){var o,s,a;for(null==i&&(i=r),o=t[n];n>e&&i(o,s=t[a=n-1>>1])<0;)t[n]=s,n=a;return t[n]=o},p=function(t,e,n){var i,o,s,a,l;for(null==n&&(n=r),o=t.length,l=e,s=t[e],i=2*e+1;i<o;)(a=i+1)<o&&!(n(t[i],t[a])<0)&&(i=a),t[e]=t[i],i=2*(e=i)+1;return t[e]=s,g(t,l,e,n)},e=function(){function t(t){this.cmp=null!=t?t:r,this.nodes=[]}return t.push=s,t.pop=o,t.replace=l,t.pushpop=a,t.heapify=i,t.updateItem=f,t.nlargest=c,t.nsmallest=m,t.prototype.push=function(t){return s(this.nodes,t,this.cmp)},t.prototype.pop=function(){return o(this.nodes,this.cmp)},t.prototype.peek=function(){return this.nodes[0]},t.prototype.contains=function(t){return-1!==this.nodes.indexOf(t)},t.prototype.replace=function(t){return l(this.nodes,t,this.cmp)},t.prototype.pushpop=function(t){return a(this.nodes,t,this.cmp)},t.prototype.heapify=function(){return i(this.nodes,this.cmp)},t.prototype.updateItem=function(t){return f(this.nodes,t,this.cmp)},t.prototype.clear=function(){return this.nodes=[]},t.prototype.empty=function(){return 0===this.nodes.length},t.prototype.size=function(){return this.nodes.length},t.prototype.clone=function(){var e;return(e=new t).nodes=this.nodes.slice(0),e},t.prototype.toArray=function(){return this.nodes.slice(0)},t.prototype.insert=t.prototype.push,t.prototype.top=t.prototype.peek,t.prototype.front=t.prototype.peek,t.prototype.has=t.prototype.contains,t.prototype.copy=t.prototype.clone,t}(),t.exports=e}).call(commonjsGlobal)})),heap$1=heap;class Cluster{constructor(){this.children=[],this.height=0,this.size=1,this.index=-1,this.isLeaf=!1}cut(t){if("number"!=typeof t)throw new TypeError("threshold must be a number");if(t<0)throw new RangeError("threshold must be a positive number");let e=[this];const r=[];for(;e.length>0;){const n=e.shift();t>=n.height?r.push(n):e=e.concat(n.children)}return r}group(t){if(!Number.isInteger(t)||t<1)throw new RangeError("groups must be a positive integer");const e=new heap$1(((t,e)=>e.height-t.height));for(e.push(this);e.size()<t;){var r=e.pop();if(0===r.children.length)break;r.children.forEach((t=>e.push(t)))}var n=new Cluster;return n.children=e.toArray(),n.height=this.height,n}traverse(t){!function t(e,r){if(r(e),e.children)for(const n of e.children)t(n,r)}(this,t)}indices(){const t=[];return this.traverse((e=>{e.isLeaf&&t.push(e.index)})),t}}function singleLink(t,e){return Math.min(t,e)}function completeLink(t,e){return Math.max(t,e)}function averageLink(t,e,r,n,i){return n/(n+i)*t+i/(n+i)*e}function weightedAverageLink(t,e){return(t+e)/2}function centroidLink(t,e,r,n,i){return n/(n+i)*t+i/(n+i)*e+-n*i/(n+i)**2*r}function medianLink(t,e,r){return t/2+e/2-r/4}function wardLink(t,e,r,n,i,o){return(n+o)/(n+i+o)*t+(i+o)/(n+i+o)*e+-o/(n+i+o)*r}function wardLink2(t,e,r,n,i,o){const s=(n+o)/(n+i+o),a=(i+o)/(n+i+o),l=-o/(n+i+o);return Math.sqrt(s*t*t+a*e*e+l*r*r)}function agnes(t,e={}){const{distanceFunction:r=euclidean,method:n="complete",isDistanceMatrix:i=!1}=e;let o;i||(t=distanceMatrix(t,r));let s=new Matrix(t);const a=s.rows;if("string"==typeof n)switch(n.toLowerCase()){case"single":o=singleLink;break;case"complete":o=completeLink;break;case"average":case"upgma":o=averageLink;break;case"wpgma":o=weightedAverageLink;break;case"centroid":case"upgmc":o=centroidLink;break;case"median":case"wpgmc":o=medianLink;break;case"ward":o=wardLink;break;case"ward2":o=wardLink2;break;default:throw new RangeError("unknown clustering method: "+n)}else if("function"!=typeof n)throw new TypeError("method must be a string or function");let l=[];for(let t=0;t<a;t++){const e=new Cluster;e.isLeaf=!0,e.index=t,l.push(e)}for(let t=0;t<a-1;t++){const[t,e,r]=getSmallestDistance(s),n=l[t],i=l[e],a=new Cluster;a.size=n.size+i.size,a.children.push(n,i),a.height=r;const h=[a],u=new Matrix(s.rows-1,s.rows-1),c=r=>getPreviousIndex(r,Math.min(t,e),Math.max(t,e));for(let a=1;a<u.rows;a++){const m=c(a),f=l[m];h.push(f);for(let l=0;l<a;l++)if(0===l){const h=o(s.get(t,m),s.get(m,e),r,n.size,i.size,f.size);u.set(a,l,h),u.set(l,a,h)}else{const t=s.get(m,c(l));u.set(a,l,t),u.set(l,a,t)}}l=h,s=u}return l[0]}function getSmallestDistance(t){let e=1/0,r=0,n=0;for(let i=1;i<t.rows;i++)for(let o=0;o<i;o++)t.get(i,o)<e&&(e=t.get(i,o),r=i,n=o);return[r,n,e]}function getPreviousIndex(t,e,r){return(t-=1)>=e&&t++,t>=r&&t++,t}var index=Object.freeze({__proto__:null,agnes:agnes});const defaultOptions$4={distanceFunction:squaredEuclidean};function nearestVector(t,e,r=defaultOptions$4){const n=r.distanceFunction||defaultOptions$4.distanceFunction,i=r.similarityFunction||defaultOptions$4.similarityFunction;let o=-1;if("function"==typeof i){let r=Number.MIN_VALUE;for(let n=0;n<t.length;n++){const s=i(e,t[n]);s>r&&(r=s,o=n)}}else{if("function"!=typeof n)throw new Error("A similarity or distance function it's required");{let r=Number.MAX_VALUE;for(let i=0;i<t.length;i++){const s=n(e,t[i]);s<r&&(r=s,o=i)}}}return o}function calculateDistanceMatrix(t,e){for(var r=new Array(t.length),n=0;n<t.length;++n)for(var i=n;i<t.length;++i){r[n]||(r[n]=new Array(t.length)),r[i]||(r[i]=new Array(t.length));const o=e(t[n],t[i]);r[n][i]=o,r[i][n]=o}return r}function updateClusterID(t,e,r,n){for(var i=0;i<t.length;i++)r[i]=nearestVector(e,t[i],{distanceFunction:n});return r}function updateCenters(t,e,r,n){const i=e[0].length;for(var o=new Array(n),s=new Array(n),a=0;a<n;a++){o[a]=new Array(i),s[a]=0;for(var l=0;l<i;l++)o[a][l]=0}for(var h=0;h<e.length;h++){s[r[h]]++;for(var u=0;u<i;u++)o[r[h]][u]+=e[h][u]}for(var c=0;c<n;c++)for(var m=0;m<i;m++)s[c]?o[c][m]/=s[c]:o[c][m]=t[c][m];return o}function hasConverged(t,e,r,n){for(var i=0;i<t.length;i++)if(r(t[i],e[i])>n)return!1;return!0}const LOOP=8,FLOAT_MUL=1/16777216,sh1=15,sh2=18,sh3=11;function multiply_uint32(t,e){const r=65535&(t>>>=0);return((t-r)*(e>>>=0)>>>0)+r*e>>>0}class XSadd{constructor(t=Date.now()){this.state=new Uint32Array(4),this.init(t),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return(this.getUint32()>>>8)*FLOAT_MUL}init(t){if(!Number.isInteger(t))throw new TypeError("seed must be an integer");this.state[0]=t,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<LOOP;t++)this.state[3&t]^=t+multiply_uint32(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<LOOP;t++)this.nextState()}periodCertification(){0===this.state[0]&&0===this.state[1]&&0===this.state[2]&&0===this.state[3]&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let t=this.state[0];t^=t<<sh1,t^=t>>>sh2,t^=this.state[3]<<sh3,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=t}}const PROB_TOLERANCE=1e-8;function randomChoice(t,e={},r=Math.random){const{size:n=1,replace:i=!1,probabilities:o}=e;let s,a;if(s="number"==typeof t?getArray(t):t.slice(),o){if(!i)throw new Error("choice with probabilities and no replacement is not implemented");if(o.length!==s.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[o[0]];for(let t=1;t<o.length;t++)a[t]=a[t-1]+o[t];if(Math.abs(1-a[a.length-1])>PROB_TOLERANCE)throw new Error("probabilities should sum to 1, but instead sums to "+a[a.length-1])}if(!1===i&&n>s.length)throw new Error("size option is too large");const l=[];for(let t=0;t<n;t++){const t=randomIndex(s.length,r,a);l.push(s[t]),i||s.splice(t,1)}return l}function getArray(t){const e=[];for(let r=0;r<t;r++)e.push(r);return e}function randomIndex(t,e,r){const n=e();if(r){let t=0;for(;n>r[t];)t++;return t}return Math.floor(n*t)}class Random{constructor(t=Math.random){if("number"==typeof t){const e=new XSadd(t);this.randomGenerator=e.random}else this.randomGenerator=t}choice(t,e){return randomChoice(t,e,this.randomGenerator)}random(){return this.randomGenerator()}randInt(t,e){return void 0===e&&(e=t,t=0),t+Math.floor(this.randomGenerator()*(e-t))}randomSample(t){const e=[];for(let r=0;r<t;r++)e.push(this.random());return e}}function random(t,e,r){return new Random(r).choice(t,{size:e})}function mostDistant(t,e,r,n){const i=new Random(n);var o=new Array(e);if(o[0]=Math.floor(i.random()*t.length),e>1){for(var s={dist:-1,index:-1},a=0;a<t.length;++a)r[o[0]][a]>s.dist&&(s.dist=r[o[0]][a],s.index=a);if(o[1]=s.index,e>2)for(var l=2;l<e;++l){for(var h={dist:-1,index:-1},u=0;u<t.length;++u){for(var c={dist:Number.MAX_VALUE,index:-1},m=0;m<l;++m)r[m][u]<c.dist&&-1===o.indexOf(u)&&(c={dist:r[m][u],index:u});c.dist!==Number.MAX_VALUE&&c.dist>h.dist&&(h=Object.assign({},c))}o[l]=h.index}}return o.map((e=>t[e]))}function kmeanspp(t,e,r={}){const n=(t=new Matrix(t)).rows,i=new Random(r.seed),o=[],s=r.localTrials||2+Math.floor(Math.log(e)),a=i.randInt(n);o.push(t.getRow(a));let l=new Matrix(1,t.rows);for(let e=0;e<t.rows;e++)l.set(0,e,squaredEuclidean(t.getRow(e),o[0]));let h=[cumSum(l.getRow(0))];const u=1/h[0][n-1];let c=Matrix.mul(l,u);for(let r=1;r<e;r++){const e=i.choice(n,{replace:!0,size:s,probabilities:c[0]}),a=euclideanDistances(t.selection(e,range(t.columns)),t);let u,m,f;for(let t=0;t<s;t++){const r=Matrix.min(l,[a.getRow(t)]),n=r.sum();(void 0===u||n<m)&&(u=e[t],m=n,f=r)}o[r]=t.getRow(u),l=f,h=[cumSum(l.getRow(0))],c=Matrix.mul(l,1/h[0][n-1])}return o}function euclideanDistances(t,e){const r=new Matrix(t.rows,e.rows);for(let n=0;n<t.rows;n++)for(let i=0;i<e.rows;i++)r.set(n,i,squaredEuclidean(t.getRow(n),e.getRow(i)));return r}function range(t){let e=[];for(let r=0;r<t;r++)e.push(r);return e}function cumSum(t){let e=[t[0]];for(let r=1;r<t.length;r++)e[r]=e[r-1]+t[r];return e}const distanceSymbol=Symbol("distance");class KMeansResult{constructor(t,e,r,n,i){this.clusters=t,this.centroids=e,this.converged=r,this.iterations=n,this[distanceSymbol]=i}nearest(t){const e=new Array(t.length);return updateClusterID(t,this.centroids.map((function(t){return t.centroid})),e,this[distanceSymbol])}computeInformation(t){for(var e=this.centroids.map((function(t){return{centroid:t,error:0,size:0}})),r=0;r<t.length;r++)e[this.clusters[r]].error+=this[distanceSymbol](t[r],this.centroids[this.clusters[r]]),e[this.clusters[r]].size++;for(var n=0;n<this.centroids.length;n++)e[n].size?e[n].error/=e[n].size:e[n].error=null;return new KMeansResult(this.clusters,e,this.converged,this.iterations,this[distanceSymbol])}}const defaultOptions$5={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:squaredEuclidean};function step(t,e,r,n,i,o){var s=updateCenters(t,e,r=updateClusterID(e,t,r,i.distanceFunction),n),a=hasConverged(s,t,i.distanceFunction,i.tolerance);return new KMeansResult(r,s,a,o,i.distanceFunction)}function*kmeansGenerator(t,e,r,n,i){for(var o,s=!1,a=0;!s&&a<i.maxIterations;)o=step(t,e,r,n,i,++a),yield o.computeInformation(e),s=o.converged,t=o.centroids}function kmeans(t,e,r){if(r=Object.assign({},defaultOptions$5,r),e<=0||e>t.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var n;if(Array.isArray(r.initialization)){if(r.initialization.length!==e)throw new Error("The initial centers should have the same length as K");n=r.initialization}else switch(r.initialization){case"kmeans++":n=kmeanspp(t,e,r);break;case"random":n=random(t,e,r.seed);break;case"mostDistant":n=mostDistant(t,e,calculateDistanceMatrix(t,r.distanceFunction),r.seed);break;default:throw new Error(`Unknown initialization method: "${r.initialization}"`)}0===r.maxIterations&&(r.maxIterations=Number.MAX_VALUE);var i=new Array(t.length);if(r.withIterations)return kmeansGenerator(n,t,i,e,r);for(var o,s=!1,a=0;!s&&a<r.maxIterations;)s=(o=step(n,t,i,e,r,++a)).converged,n=o.centroids;return o.computeInformation(t)}function separateClasses(t,e){for(var r=t.columns,n=0,i=new Array(1e4),o=0;o<e.length;o++)void 0===i[e[o]]&&(i[e[o]]=0,n++),i[e[o]]++;var s=new Array(n),a=new Array(n);for(o=0;o<n;++o)s[o]=new Matrix(i[o],r),a[o]=0;for(o=0;o<t.rows;++o)s[e[o]].setRow(a[e[o]],t.getRow(o)),a[e[o]]++;return s}class GaussianNB{constructor(t,e){t&&(this.means=e.means,this.calculateProbabilities=e.calculateProbabilities)}train(t,e){var r=Math.sqrt(2*Math.PI);if((t=Matrix.checkMatrix(t)).rows!==e.length)throw new RangeError("the size of the training set and the training labels must be the same.");var n=separateClasses(t,e),i=new Array(n.length);this.means=new Array(n.length);for(var o=0;o<n.length;++o){var s=n[o].mean("column"),a=n[o].standardDeviation("column",{mean:s}),l=Math.log(n[o].rows/t.rows);i[o]=new Array(s.length+1),i[o][0]=l;for(var h=1;h<s.length+1;++h){var u=a[h-1];i[o][h]=[1/(r*u),-2*u*u]}this.means[o]=s}this.calculateProbabilities=i}predict(t){if((t=Matrix.checkMatrix(t)).rows===this.calculateProbabilities[0].length)throw new RangeError("the dataset must have the same features as the training set");for(var e=new Array(t.rows),r=0;r<e.length;++r)e[r]=getCurrentClass(t.getRow(r),this.means,this.calculateProbabilities);return e}toJSON(){return{modelName:"NaiveBayes",means:this.means,calculateProbabilities:this.calculateProbabilities}}static load(t){if("NaiveBayes"!==t.modelName)throw new RangeError("The current model is not a Multinomial Naive Bayes, current model:",t.name);return new GaussianNB(!0,t)}}function getCurrentClass(t,e,r){for(var n=0,i=-1,o=0;o<r.length;++o){for(var s=r[o][0],a=1;a<r[0][1].length+1;++a)s+=calculateLogProbability(t[a-1],e[o][a-1],r[o][a][0],r[o][a][1]);(s=Math.exp(s))>n&&(n=s,i=o)}return i}function calculateLogProbability(t,e,r,n){return t-=e,Math.log(r*Math.exp(t*t/n))}class MultinomialNB{constructor(t){t&&(this.conditionalProbability=Matrix.checkMatrix(t.conditionalProbability),this.priorProbability=Matrix.checkMatrix(t.priorProbability))}train(t,e){if((t=Matrix.checkMatrix(t)).rows!==e.length)throw new RangeError("the size of the training set and the training labels must be the same.");var r=separateClasses(t,e);this.priorProbability=new Matrix(r.length,1);for(var n=0;n<r.length;++n)this.priorProbability.set(n,0,Math.log(r[n].rows/t.rows));var i=t.columns;for(this.conditionalProbability=new Matrix(r.length,i),n=0;n<r.length;++n){var o=Matrix.checkMatrix(r[n]),s=o.sum()+i;this.conditionalProbability.setRow(n,Matrix.rowVector(o.sum("column")).add(1).div(s).apply(matrixLog))}}predict(t){t=Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=0;r<t.rows;++r){var n=t.getRowVector(r);const i=Matrix.columnVector(this.conditionalProbability.clone().mulRowVector(n).sum("row"));e[r]=i.add(this.priorProbability).maxIndex()[0]}return e}toJSON(){return{name:"MultinomialNB",priorProbability:this.priorProbability,conditionalProbability:this.conditionalProbability}}static load(t){if("MultinomialNB"!==t.name)throw new RangeError(t.name+" is not a Multinomial Naive Bayes");return new MultinomialNB(t)}}function matrixLog(t,e){this.set(t,e,Math.log(this.get(t,e)))}var index$1=Object.freeze({__proto__:null,GaussianNB:GaussianNB,MultinomialNB:MultinomialNB});
/*
   * Original code from:
   *
   * k-d Tree JavaScript - V 1.01
   *
   * https://github.com/ubilabs/kd-tree-javascript
   *
   * @author Mircea Pricop <pricop@ubilabs.net>, 2012
   * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
   * @author Ubilabs http://ubilabs.net, 2012
   * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
   */function Node(t,e,r){this.obj=t,this.left=null,this.right=null,this.parent=r,this.dimension=e}class KDTree{constructor(t,e){if(Array.isArray(t)){this.dimensions=new Array(t[0].length);for(var r=0;r<this.dimensions.length;r++)this.dimensions[r]=r;this.root=buildTree(t,0,null,this.dimensions)}else this.dimensions=t.dimensions,this.root=t,restoreParent(this.root);this.metric=e}toJSON(){const t=toJSONImpl(this.root);return t.dimensions=this.dimensions,t}nearest(t,e,r){const n=this.metric,i=this.dimensions;var o;const s=new BinaryHeap((function(t){return-t[1]}));if(r)for(o=0;o<e;o+=1)s.push([null,r]);this.root&&function r(o){const a=i[o.dimension],l=n(t,o.obj),h={};var u,c,m,f;function g(t,r){s.push([t,r]),s.size()>e&&s.pop()}for(f=0;f<i.length;f+=1)f===o.dimension?h[i[f]]=t[i[f]]:h[i[f]]=o.obj[i[f]];c=n(h,o.obj),null!==o.right||null!==o.left?(r(u=null===o.right?o.left:null===o.left?o.right:t[a]<o.obj[a]?o.left:o.right),(s.size()<e||l<s.peek()[1])&&g(o,l),(s.size()<e||Math.abs(c)<s.peek()[1])&&null!==(m=u===o.left?o.right:o.left)&&r(m)):(s.size()<e||l<s.peek()[1])&&g(o,l)}(this.root);const a=[];for(o=0;o<Math.min(e,s.content.length);o+=1)s.content[o][0]&&a.push([s.content[o][0].obj,s.content[o][1]]);return a}}function toJSONImpl(t){const e=new Node(t.obj,t.dimension,null);return t.left&&(e.left=toJSONImpl(t.left)),t.right&&(e.right=toJSONImpl(t.right)),e}function buildTree(t,e,r,n){const i=e%n.length;if(0===t.length)return null;if(1===t.length)return new Node(t[0],i,r);t.sort(((t,e)=>t[n[i]]-e[n[i]]));const o=Math.floor(t.length/2),s=new Node(t[o],i,r);return s.left=buildTree(t.slice(0,o),e+1,s,n),s.right=buildTree(t.slice(o+1),e+1,s,n),s}function restoreParent(t){t.left&&(t.left.parent=t,restoreParent(t.left)),t.right&&(t.right.parent=t,restoreParent(t.right))}class BinaryHeap{constructor(t){this.content=[],this.scoreFunction=t}push(t){this.content.push(t),this.bubbleUp(this.content.length-1)}pop(){var t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.sinkDown(0)),t}peek(){return this.content[0]}size(){return this.content.length}bubbleUp(t){for(var e=this.content[t];t>0;){const r=Math.floor((t+1)/2)-1,n=this.content[r];if(!(this.scoreFunction(e)<this.scoreFunction(n)))break;this.content[r]=e,this.content[t]=n,t=r}}sinkDown(t){for(var e=this.content.length,r=this.content[t],n=this.scoreFunction(r);;){var i=2*(t+1),o=i-1,s=null;if(o<e){var a=this.content[o],l=this.scoreFunction(a);l<n&&(s=o)}if(i<e){var h=this.content[i];this.scoreFunction(h)<(null===s?n:l)&&(s=i)}if(null===s)break;this.content[t]=this.content[s],this.content[s]=r,t=s}}}class KNN{constructor(t,e,r={}){if(!0===t){const t=e;return this.kdTree=new KDTree(t.kdTree,r),this.k=t.k,this.classes=new Set(t.classes),void(this.isEuclidean=t.isEuclidean)}const n=new Set(e),{distance:i=euclidean,k:o=n.size+1}=r,s=new Array(t.length);for(var a=0;a<s.length;++a)s[a]=t[a].slice();for(a=0;a<e.length;++a)s[a].push(e[a]);this.kdTree=new KDTree(s,i),this.k=o,this.classes=n,this.isEuclidean=i===euclidean}static load(t,e=euclidean){if("KNN"!==t.name)throw new Error("invalid model: "+t.name);if(!t.isEuclidean&&e===euclidean)throw new Error("a custom distance function was used to create the model. Please provide it again");if(t.isEuclidean&&e!==euclidean)throw new Error("the model was created with the default distance function. Do not load it with another one");return new KNN(!0,t,e)}toJSON(){return{name:"KNN",kdTree:this.kdTree,k:this.k,classes:Array.from(this.classes),isEuclidean:this.isEuclidean}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return getSinglePrediction(this,t);if(Array.isArray(t[0])&&"number"==typeof t[0][0]){const r=new Array(t.length);for(var e=0;e<t.length;e++)r[e]=getSinglePrediction(this,t[e]);return r}}throw new TypeError("dataset to predict must be an array or a matrix")}}function getSinglePrediction(t,e){var r=t.kdTree.nearest(e,t.k),n={},i=-1,o=-1,s=r[0][0].length-1;for(var a of t.classes)n[a]=0;for(var l=0;l<r.length;++l){var h=r[l][0][s],u=++n[h];u>o&&(i=h,o=u)}return i}function norm(t){return Math.sqrt(t.clone().apply(pow2array).sum())}function pow2array(t,e){this.set(t,e,this.get(t,e)**2)}function initializeMatrices(t,e){if(e)for(let e=0;e<t.length;++e)for(let r=0;r<t[e].length;++r){let n=t[e][r];t[e][r]=null!==n?new Matrix(t[e][r]):void 0}else for(let e=0;e<t.length;++e)t[e]=new Matrix(t[e]);return t}class PLS{constructor(t,e){if(!0===t)this.meanX=e.meanX,this.stdDevX=e.stdDevX,this.meanY=e.meanY,this.stdDevY=e.stdDevY,this.PBQ=Matrix.checkMatrix(e.PBQ),this.R2X=e.R2X,this.scale=e.scale,this.scaleMethod=e.scaleMethod,this.tolerance=e.tolerance;else{let{tolerance:e=1e-5,scale:r=!0}=t;this.tolerance=e,this.scale=r,this.latentVectors=t.latentVectors}}train(t,e){if(t=Matrix.checkMatrix(t),e=Matrix.checkMatrix(e),t.length!==e.length)throw new RangeError("The number of X rows must be equal to the number of Y rows");this.meanX=t.mean("column"),this.stdDevX=t.standardDeviation("column",{mean:this.meanX,unbiased:!0}),this.meanY=e.mean("column"),this.stdDevY=e.standardDeviation("column",{mean:this.meanY,unbiased:!0}),this.scale&&(t=t.clone().subRowVector(this.meanX).divRowVector(this.stdDevX),e=e.clone().subRowVector(this.meanY).divRowVector(this.stdDevY)),void 0===this.latentVectors&&(this.latentVectors=Math.min(t.rows-1,t.columns));let r,n,i,o,s=t.rows,a=t.columns,l=e.rows,h=e.columns,u=t.clone().mul(t).sum(),c=e.clone().mul(e).sum(),m=this.tolerance,f=this.latentVectors,g=Matrix.zeros(s,f),p=Matrix.zeros(a,f),d=Matrix.zeros(l,f),w=Matrix.zeros(h,f),x=Matrix.zeros(f,f),y=p.clone(),M=0;for(;norm(e)>m&&M<f;){let a=t.transpose(),l=e.transpose(),h=maxSumColIndex(t.clone().mul(t)),u=maxSumColIndex(e.clone().mul(e)),c=t.getColumnVector(h),f=e.getColumnVector(u);for(r=Matrix.zeros(s,1);norm(c.clone().sub(r))>m;)n=a.mmul(f),n.div(norm(n)),r=c,c=t.mmul(n),i=l.mmul(c),i.div(norm(i)),f=e.mmul(i);r=c;let v=a.mmul(r),b=r.transpose().mmul(r).get(0,0);o=v.div(b);let S=norm(o);o.div(S),r.mul(S),n.mul(S),v=f.transpose().mmul(r),b=r.transpose().mmul(r).get(0,0);let A=v.div(b).get(0,0);t.sub(r.mmul(o.transpose())),e.sub(r.clone().mul(A).mmul(i.transpose())),g.setColumn(M,r),p.setColumn(M,o),d.setColumn(M,f),w.setColumn(M,i),y.setColumn(M,n),x.set(M,M,A),M++}M--,g=g.subMatrix(0,g.rows-1,0,M),p=p.subMatrix(0,p.rows-1,0,M),d=d.subMatrix(0,d.rows-1,0,M),w=w.subMatrix(0,w.rows-1,0,M),y=y.subMatrix(0,y.rows-1,0,M),x=x.subMatrix(0,M,0,M),this.ssqYcal=c,this.E=t,this.F=e,this.T=g,this.P=p,this.U=d,this.Q=w,this.W=y,this.B=x,this.PBQ=p.mmul(x).mmul(w.transpose()),this.R2X=r.transpose().mmul(r).mmul(o.transpose().mmul(o)).div(u).get(0,0)}predict(t){let e=Matrix.checkMatrix(t);this.scale&&(e=e.subRowVector(this.meanX).divRowVector(this.stdDevX));let r=e.mmul(this.PBQ);return r=r.mulRowVector(this.stdDevY).addRowVector(this.meanY),r}getExplainedVariance(){return this.R2X}toJSON(){return{name:"PLS",R2X:this.R2X,meanX:this.meanX,stdDevX:this.stdDevX,meanY:this.meanY,stdDevY:this.stdDevY,PBQ:this.PBQ,tolerance:this.tolerance,scale:this.scale}}static load(t){if("PLS"!==t.name)throw new RangeError("Invalid model: "+t.name);return new PLS(!0,t)}}function maxSumColIndex(t){return Matrix.rowVector(t.sum("column")).maxIndex()[0]}class KOPLS{constructor(t,e){if(!0===t)this.trainingSet=new Matrix(e.trainingSet),this.YLoadingMat=new Matrix(e.YLoadingMat),this.SigmaPow=new Matrix(e.SigmaPow),this.YScoreMat=new Matrix(e.YScoreMat),this.predScoreMat=initializeMatrices(e.predScoreMat,!1),this.YOrthLoadingVec=initializeMatrices(e.YOrthLoadingVec,!1),this.YOrthEigen=e.YOrthEigen,this.YOrthScoreMat=initializeMatrices(e.YOrthScoreMat,!1),this.toNorm=initializeMatrices(e.toNorm,!1),this.TURegressionCoeff=initializeMatrices(e.TURegressionCoeff,!1),this.kernelX=initializeMatrices(e.kernelX,!0),this.kernel=e.kernel,this.orthogonalComp=e.orthogonalComp,this.predictiveComp=e.predictiveComp;else{if(void 0===t.predictiveComponents)throw new RangeError("no predictive components found!");if(void 0===t.orthogonalComponents)throw new RangeError("no orthogonal components found!");if(void 0===t.kernel)throw new RangeError("no kernel found!");this.orthogonalComp=t.orthogonalComponents,this.predictiveComp=t.predictiveComponents,this.kernel=t.kernel}}train(t,e){t=Matrix.checkMatrix(t),e=Matrix.checkMatrix(e),this.trainingSet=t.clone();let r=this.kernel.compute(t),n=Matrix.eye(r.rows,r.rows,1),i=r;r=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)r[t]=new Array(this.orthogonalComp+1);r[0][0]=i;let o=new SingularValueDecomposition(e.transpose().mmul(r[0][0]).mmul(e),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1}),s=o.leftSingularVectors,a=o.diagonalMatrix;s=s.subMatrix(0,s.rows-1,0,this.predictiveComp-1),a=a.subMatrix(0,this.predictiveComp-1,0,this.predictiveComp-1);let l=e.mmul(s),h=new Array(this.orthogonalComp+1),u=new Array(this.orthogonalComp+1),c=new Array(this.orthogonalComp),m=new Array(this.orthogonalComp),f=new Array(this.orthogonalComp),g=new Array(this.orthogonalComp),p=Matrix.pow(a,-.5);p.apply((function(t,e){this.get(t,e)===1/0&&this.set(t,e,0)}));for(let t=0;t<this.orthogonalComp;++t){h[t]=r[0][t].transpose().mmul(l).mmul(p);let e=h[t].transpose();u[t]=inverse(e.mmul(h[t])).mmul(e).mmul(l),o=new SingularValueDecomposition(e.mmul(Matrix.sub(r[t][t],h[t].mmul(e))).mmul(h[t]),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1});let i=o.leftSingularVectors,s=o.diagonalMatrix;m[t]=i.subMatrix(0,i.rows-1,0,0),f[t]=s.get(0,0),c[t]=Matrix.sub(r[t][t],h[t].mmul(e)).mmul(h[t]).mmul(m[t]).mul(Math.pow(f[t],-.5));let a=c[t].transpose();g[t]=Matrix.sqrt(a.mmul(c[t])),c[t]=c[t].divRowVector(g[t]);let d=Matrix.sub(n,c[t].mmul(c[t].transpose()));r[0][t+1]=r[0][t].mmul(d),r[t+1][t+1]=d.mmul(r[t][t]).mmul(d)}let d=h[this.orthogonalComp]=r[0][this.orthogonalComp].transpose().mmul(l).mmul(p),w=d.transpose();u[this.orthogonalComp]=inverse(w.mmul(d)).mmul(w).mmul(l),this.YLoadingMat=s,this.SigmaPow=p,this.YScoreMat=l,this.predScoreMat=h,this.YOrthLoadingVec=m,this.YOrthEigen=f,this.YOrthScoreMat=c,this.toNorm=g,this.TURegressionCoeff=u,this.kernelX=r}predict(t){let e=this.kernel.compute(t,this.trainingSet),r=e;e=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)e[t]=new Array(this.orthogonalComp+1);e[0][0]=r;let n,i=new Array(this.orthogonalComp),o=new Array(this.orthogonalComp);for(n=0;n<this.orthogonalComp;++n){o[n]=e[n][0].mmul(this.YScoreMat).mmul(this.SigmaPow),i[n]=Matrix.sub(e[n][n],o[n].mmul(this.predScoreMat[n].transpose())).mmul(this.predScoreMat[n]).mmul(this.YOrthLoadingVec[n]).mul(Math.pow(this.YOrthEigen[n],-.5)),i[n]=i[n].divRowVector(this.toNorm[n]);let t=this.YOrthScoreMat[n].transpose();e[n+1][0]=Matrix.sub(e[n][0],i[n].mmul(t).mmul(this.kernelX[0][n].transpose()));let r=Matrix.sub(e[n][0],e[n][n].mmul(this.YOrthScoreMat[n]).mmul(t)),s=i[n].mmul(t).mmul(this.kernelX[n][n]),a=s.mmul(this.YOrthScoreMat[n]).mmul(t);e[n+1][n+1]=r.sub(s).add(a)}return o[n]=e[n][0].mmul(this.YScoreMat).mmul(this.SigmaPow),{prediction:o[n].mmul(this.TURegressionCoeff[n]).mmul(this.YLoadingMat.transpose()),predScoreMat:o,predYOrthVectors:i}}toJSON(){return{name:"K-OPLS",YLoadingMat:this.YLoadingMat,SigmaPow:this.SigmaPow,YScoreMat:this.YScoreMat,predScoreMat:this.predScoreMat,YOrthLoadingVec:this.YOrthLoadingVec,YOrthEigen:this.YOrthEigen,YOrthScoreMat:this.YOrthScoreMat,toNorm:this.toNorm,TURegressionCoeff:this.TURegressionCoeff,kernelX:this.kernelX,trainingSet:this.trainingSet,orthogonalComp:this.orthogonalComp,predictiveComp:this.predictiveComp}}static load(t,e){if("K-OPLS"!==t.name)throw new RangeError("Invalid model: "+t.name);if(!e)throw new RangeError("You must provide a kernel for the model!");return t.kernel=e,new KOPLS(!0,t)}}class ConfusionMatrix{constructor(t,e){if(t.length!==t[0].length)throw new Error("Confusion matrix must be square");if(e.length!==t.length)throw new Error("Confusion matrix and labels should have the same length");this.labels=e,this.matrix=t}static fromLabels(t,e,r={}){if(e.length!==t.length)throw new Error("predicted and actual must have the same length");let n;n=r.labels?new Set(r.labels):new Set([...t,...e]),n=Array.from(n),r.sort&&n.sort(r.sort);const i=Array.from({length:n.length});for(let t=0;t<i.length;t++)i[t]=new Array(i.length),i[t].fill(0);for(let r=0;r<e.length;r++){const o=n.indexOf(t[r]),s=n.indexOf(e[r]);o>=0&&s>=0&&i[o][s]++}return new ConfusionMatrix(i,n)}getMatrix(){return this.matrix}getLabels(){return this.labels}getTotalCount(){let t=0;for(let e=0;e<this.matrix.length;e++)for(let r=0;r<this.matrix.length;r++)t+=this.matrix[e][r];return t}getTrueCount(){let t=0;for(let e=0;e<this.matrix.length;e++)t+=this.matrix[e][e];return t}getFalseCount(){return this.getTotalCount()-this.getTrueCount()}getTruePositiveCount(t){const e=this.getIndex(t);return this.matrix[e][e]}getTrueNegativeCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)for(let n=0;n<this.matrix.length;n++)t!==e&&n!==e&&(r+=this.matrix[t][n]);return r}getFalsePositiveCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)t!==e&&(r+=this.matrix[t][e]);return r}getFalseNegativeCount(t){const e=this.getIndex(t);let r=0;for(let t=0;t<this.matrix.length;t++)t!==e&&(r+=this.matrix[e][t]);return r}getPositiveCount(t){return this.getTruePositiveCount(t)+this.getFalseNegativeCount(t)}getNegativeCount(t){return this.getTrueNegativeCount(t)+this.getFalsePositiveCount(t)}getIndex(t){const e=this.labels.indexOf(t);if(-1===e)throw new Error("The label does not exist");return e}getTruePositiveRate(t){return this.getTruePositiveCount(t)/this.getPositiveCount(t)}getTrueNegativeRate(t){return this.getTrueNegativeCount(t)/this.getNegativeCount(t)}getPositivePredictiveValue(t){const e=this.getTruePositiveCount(t);return e/(e+this.getFalsePositiveCount(t))}getNegativePredictiveValue(t){const e=this.getTrueNegativeCount(t);return e/(e+this.getFalseNegativeCount(t))}getFalseNegativeRate(t){return 1-this.getTruePositiveRate(t)}getFalsePositiveRate(t){return 1-this.getTrueNegativeRate(t)}getFalseDiscoveryRate(t){const e=this.getFalsePositiveCount(t);return e/(e+this.getTruePositiveCount(t))}getFalseOmissionRate(t){const e=this.getFalseNegativeCount(t);return e/(e+this.getTruePositiveCount(t))}getF1Score(t){const e=this.getTruePositiveCount(t);return 2*e/(2*e+this.getFalsePositiveCount(t)+this.getFalseNegativeCount(t))}getMatthewsCorrelationCoefficient(t){const e=this.getTruePositiveCount(t),r=this.getTrueNegativeCount(t),n=this.getFalsePositiveCount(t),i=this.getFalseNegativeCount(t);return(e*r-n*i)/Math.sqrt((e+n)*(e+i)*(r+n)*(r+i))}getInformedness(t){return this.getTruePositiveRate(t)+this.getTrueNegativeRate(t)-1}getMarkedness(t){return this.getPositivePredictiveValue(t)+this.getNegativePredictiveValue(t)-1}getConfusionTable(t){return[[this.getTruePositiveCount(t),this.getFalseNegativeCount(t)],[this.getFalsePositiveCount(t),this.getTrueNegativeCount(t)]]}getAccuracy(){let t=0,e=0;for(let r=0;r<this.matrix.length;r++)for(let n=0;n<this.matrix.length;n++)r===n?t+=this.matrix[r][n]:e+=this.matrix[r][n];return t/(t+e)}getCount(t,e){const r=this.getIndex(t),n=this.getIndex(e);return this.matrix[r][n]}get accuracy(){return this.getAccuracy()}get total(){return this.getTotalCount()}}var lib=createCommonjsModule((function(t,e){!function(){function e(t,e){return t(e={exports:{}},e.exports),e.exports}var r=e((function(t){!function(e){var r,n=Object.prototype,i=n.hasOwnProperty,o="function"==typeof Symbol?Symbol:{},s=o.iterator||"@@iterator",a=o.asyncIterator||"@@asyncIterator",l=o.toStringTag||"@@toStringTag",h=e.regeneratorRuntime;if(h)t.exports=h;else{(h=e.regeneratorRuntime=t.exports).wrap=y;var u="suspendedStart",c="suspendedYield",m="executing",f="completed",g={},p={};p[s]=function(){return this};var d=Object.getPrototypeOf,w=d&&d(d(I([])));w&&w!==n&&i.call(w,s)&&(p=w);var x=S.prototype=v.prototype=Object.create(p);b.prototype=x.constructor=S,S.constructor=b,S[l]=b.displayName="GeneratorFunction",h.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===b||"GeneratorFunction"===(e.displayName||e.name))},h.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,S):(t.__proto__=S,l in t||(t[l]="GeneratorFunction")),t.prototype=Object.create(x),t},h.awrap=function(t){return{__await:t}},A(E.prototype),E.prototype[a]=function(){return this},h.AsyncIterator=E,h.async=function(t,e,r,n){var i=new E(y(t,e,r,n));return h.isGeneratorFunction(e)?i:i.next().then((function(t){return t.done?t.value:i.next()}))},A(x),x[l]="Generator",x[s]=function(){return this},x.toString=function(){return"[object Generator]"},h.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},h.values=I,T.prototype={constructor:T,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method="next",this.arg=r,this.tryEntries.forEach(C),!t)for(var e in this)"t"===e.charAt(0)&&i.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=r)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function n(n,i){return a.type="throw",a.arg=t,e.next=n,i&&(e.method="next",e.arg=r),!!i}for(var o=this.tryEntries.length-1;o>=0;--o){var s=this.tryEntries[o],a=s.completion;if("root"===s.tryLoc)return n("end");if(s.tryLoc<=this.prev){var l=i.call(s,"catchLoc"),h=i.call(s,"finallyLoc");if(l&&h){if(this.prev<s.catchLoc)return n(s.catchLoc,!0);if(this.prev<s.finallyLoc)return n(s.finallyLoc)}else if(l){if(this.prev<s.catchLoc)return n(s.catchLoc,!0)}else{if(!h)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return n(s.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var n=this.tryEntries[r];if(n.tryLoc<=this.prev&&i.call(n,"finallyLoc")&&this.prev<n.finallyLoc){var o=n;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var s=o?o.completion:{};return s.type=t,s.arg=e,o?(this.method="next",this.next=o.finallyLoc,g):this.complete(s)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),g},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),C(r),g}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;C(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,n){return this.delegate={iterator:I(t),resultName:e,nextLoc:n},"next"===this.method&&(this.arg=r),g}}}function y(t,e,r,n){var i=e&&e.prototype instanceof v?e:v,o=Object.create(i.prototype),s=new T(n||[]);return o._invoke=R(t,r,s),o}function M(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}function v(){}function b(){}function S(){}function A(t){["next","throw","return"].forEach((function(e){t[e]=function(t){return this._invoke(e,t)}}))}function E(t){function e(r,n,o,s){var a=M(t[r],t,n);if("throw"!==a.type){var l=a.arg,h=l.value;return h&&"object"==typeof h&&i.call(h,"__await")?Promise.resolve(h.__await).then((function(t){e("next",t,o,s)}),(function(t){e("throw",t,o,s)})):Promise.resolve(h).then((function(t){l.value=t,o(l)}),s)}s(a.arg)}var r;function n(t,n){function i(){return new Promise((function(r,i){e(t,n,r,i)}))}return r=r?r.then(i,i):i()}this._invoke=n}function R(t,e,r){var n=u;return function(i,o){if(n===m)throw new Error("Generator is already running");if(n===f){if("throw"===i)throw o;return O()}for(r.method=i,r.arg=o;;){var s=r.delegate;if(s){var a=k(s,r);if(a){if(a===g)continue;return a}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===u)throw n=f,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=m;var l=M(t,e,r);if("normal"===l.type){if(n=r.done?f:c,l.arg===g)continue;return{value:l.arg,done:r.done}}"throw"===l.type&&(n=f,r.method="throw",r.arg=l.arg)}}}function k(t,e){var n=t.iterator[e.method];if(n===r){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=r,k(t,e),"throw"===e.method))return g;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return g}var i=M(n,t.iterator,e.arg);if("throw"===i.type)return e.method="throw",e.arg=i.arg,e.delegate=null,g;var o=i.arg;return o?o.done?(e[t.resultName]=o.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=r),e.delegate=null,g):o:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,g)}function N(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function C(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function T(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(N,this),this.reset(!0)}function I(t){if(t){var e=t[s];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,o=function e(){for(;++n<t.length;)if(i.call(t,n))return e.value=t[n],e.done=!1,e;return e.value=r,e.done=!0,e};return o.next=o}}return{next:O}}function O(){return{value:r,done:!0}}}(function(){return this}()||Function("return this")())})),n=function(){return this}()||Function("return this")(),i=n.regeneratorRuntime&&Object.getOwnPropertyNames(n).indexOf("regeneratorRuntime")>=0,o=i&&n.regeneratorRuntime;n.regeneratorRuntime=void 0;var s=r;if(i)n.regeneratorRuntime=o;else try{delete n.regeneratorRuntime}catch(t){n.regeneratorRuntime=void 0}var a=s,l={mode:"index"};t.exports=a.mark((function t(e,r,n){var i,o,s,h,u,c,m,f,g;return a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:for(g=function(){var t,e,r;for(e=1;h[e]<=0;)e++;if(0===h[e-1]){for(t=e-1;1!==t;t--)h[t]=-1;h[e]=0,u=m=0,h[1]=1,c=e-1}else{e>1&&(h[e-1]=0);do{e++}while(h[e]>0);for(r=e-1,t=e;0===h[t];)h[t++]=-1;if(-1===h[t])h[t]=h[r],m=h[r]-1,u=t-1,c=r-1,h[r]=-1;else{if(t===h[0])return 0;h[e]=h[t],m=h[t]-1,h[t]=0,u=e-1,c=t-1}}return 1},n=Object.assign({},l,n),i=new Array(r),o=new Array(e),s=new Array(r),h=new Array(r+2),f=0;f<r;f++)i[f]=f,s[f]=f<r-e?0:1;for(f=0;f<e;f++)o[f]=r-e+f;for(f=0;f<h.length;f++)h[f]=0===f?r+1:f<=r-e?0:f<=r?f-r+e:-2;if("index"!==n.mode){t.next=20;break}return t.next=12,o.slice();case 12:if(!g()){t.next=18;break}return o[m]=i[u],t.next=16,o.slice();case 16:t.next=12;break;case 18:t.next=33;break;case 20:if("mask"!==n.mode){t.next=32;break}return t.next=23,s.slice();case 23:if(!g()){t.next=30;break}return s[u]=1,s[c]=0,t.next=28,s.slice();case 28:t.next=23;break;case 30:t.next=33;break;case 32:throw new Error("Invalid mode");case 33:case"end":return t.stop()}}),t,this)}))}()}));function getFolds(t,e=5){let r=t.length,n=new Array(r);for(let t=0;t<r;t++)n[t]=t;let i=Math.floor(r/e),o=[],s=[];for(;n.length;){let t=Math.floor(Math.random()*n.length);o.push(n[t]),n.splice(t,1),o.length===i&&(s.push(o),o=[])}return o.length&&o.forEach((t=>s[e-1].push(t))),s=s.slice(0,e),s.map(((t,e)=>({testIndex:t,trainIndex:[].concat(...s.filter(((t,r)=>r!==e)))})))}function sampleAClass(t,e){let r=JSON.parse(JSON.stringify(t)),n=Array.from(Array(r.length).keys()).sort(((t,e)=>r[t]<r[e]?-1:r[e]<r[t]|0));r.sort(((t,e)=>t<e?-1:e<t|0));let i={};r.forEach((t=>i[t]=(i[t]||0)+1));let o=[];Object.keys(i).forEach(((t,r)=>{let n=[];Object.values(i).reduce(((t,e,r)=>n[r]=t+e),0);let s=[...Array(i[t]).keys()],a=[];for(let r=0;r<Math.floor(i[t]*e);r++){let t=s[Math.floor(Math.random()*s.length)];a.push(t);let e=s.indexOf(t);s.splice(e,1)}o=0===r?o.concat(a):o.concat(a.map((t=>t+n[r-1])))}));let s=[];o.forEach((t=>s.push(n[t])));let a=[],l=[];return t.forEach(((t,e)=>{s.includes(e)?l.push(!0):(l.push(!1),a.push(e))})),{trainIndex:s,testIndex:a,mask:l}}function leaveOneOut(t,e,r,n){if("function"==typeof r){let n=r;return r=e,leavePOut(e=t,r,1,n)}return leavePOut(t,e,r,n,1)}function leavePOut(t,e,r,n,i){let o;"function"==typeof n&&(o=n,i=r,r=e,e=t),check(e,r);const s=getDistinct(r),a=initMatrix(s.length,s.length);let l=e.length,h=lib(i,l),u=new Array(l);for(let t=0;t<l;t++)u[t]=t;for(const i of h){let l=u.slice();for(let t=i.length-1;t>=0;t--)l.splice(i[t],1);o?validateWithCallback(e,r,i,l,a,s,o):validate(t,e,r,n,i,l,a,s)}return new ConfusionMatrix(a,s)}function kFold(t,e,r,n,i){let o;"function"==typeof n&&(o=n,i=r,r=e,e=t),check(e,r);const s=getDistinct(r),a=initMatrix(s.length,s.length);let l=getFolds(e,i);for(let i=0;i<l.length;i++){let h=l[i].testIndex,u=l[i].trainIndex;o?validateWithCallback(e,r,h,u,a,s,o):validate(t,e,r,n,h,u,a,s)}return new ConfusionMatrix(a,s)}function check(t,e){if(t.length!==e.length)throw new Error("features and labels should have the same length")}function initMatrix(t,e){return new Array(t).fill(0).map((()=>new Array(e).fill(0)))}function getDistinct(t){let e=new Set;for(let r=0;r<t.length;r++)e.add(t[r]);return Array.from(e)}function validate(t,e,r,n,i,o,s,a){const{testFeatures:l,trainFeatures:h,testLabels:u,trainLabels:c}=getTrainTest(e,r,i,o);let m;t.prototype.train?(m=new t(n),m.train(h,c)):m=new t(h,c,n),updateConfusionMatrix(s,u,m.predict(l),a)}function validateWithCallback(t,e,r,n,i,o,s){const{testFeatures:a,trainFeatures:l,testLabels:h,trainLabels:u}=getTrainTest(t,e,r,n);updateConfusionMatrix(i,h,s(l,u,a),o)}function updateConfusionMatrix(t,e,r,n){for(let i=0;i<r.length;i++){const o=n.indexOf(e[i]),s=n.indexOf(r[i]);(o<0||s<0)&&console.warn("ignore unknown predicted label "+r[i]),t[o][s]++}}function getTrainTest(t,e,r,n){return{testFeatures:r.map((function(e){return t[e]})),trainFeatures:n.map((function(e){return t[e]})),testLabels:r.map((function(t){return e[t]})),trainLabels:n.map((function(t){return e[t]}))}}var index$2=Object.freeze({__proto__:null,leaveOneOut:leaveOneOut,leavePOut:leavePOut,kFold:kFold,getTrainTest:getTrainTest,sampleAClass:sampleAClass,getFolds:getFolds});function OPLSNipals(t,e,r={}){const{numberOSC:n=100}=r;let i,o,s,a,l=Matrix.checkMatrix(t),h=Matrix.checkMatrix(e),u=h.getColumnVector(0),c=1;for(let t=0;t<n&&c>1e-10;t++)s=u.transpose().mmul(l).div(u.transpose().mmul(u).get(0,0)),s=s.transpose().div(norm(s)),i=l.mmul(s).div(s.transpose().mmul(s).get(0,0)),o=i.transpose().mmul(h).div(i.transpose().mmul(i).get(0,0)),a=h.mmul(o.transpose()),a=a.div(o.transpose().mmul(o).get(0,0)),t>0&&(c=a.clone().sub(u).pow(2).sum()/a.clone().pow(2).sum()),u=a.clone();let m=i.transpose().mmul(l).div(i.transpose().mmul(i).get(0,0)),f=m.clone().sub(s.transpose().mmul(m.transpose()).div(s.transpose().mmul(s).get(0,0)).mmul(s.transpose()));f.div(norm(f));let g=l.mmul(f.transpose()).div(f.mmul(f.transpose()).get(0,0)),p=g.transpose().mmul(l).div(g.transpose().mmul(g).get(0,0));return{filteredX:l.clone().sub(g.mmul(p)),weightsXOrtho:f,loadingsXOrtho:p,scoresXOrtho:g,weightsXPred:s,loadingsXpred:m,scoresXpred:i,loadingsY:o}}function tss(t){return Matrix.mul(t,t).sum()}class OPLS{constructor(t,e,r={}){if(!0===t){const t=r;return this.center=t.center,this.scale=t.scale,this.means=t.means,this.meansY=t.meansY,this.stdevs=t.stdevs,this.stdevs=t.stdevsY,this.model=t.model,this.tCV=t.tCV,this.tOrthCV=t.tOrthCV,this.yHatCV=t.yHatCV,void(this.mode=t.mode)}let n=t.clone();const{nComp:i=3,center:o=!0,scale:s=!0,cvFolds:a=[]}=r;let l,h;if("number"==typeof e[0])this.mode="regression",l=Matrix.from1DArray(e.length,1,e);else if("string"==typeof e[0])throw this.mode="discriminantAnalysis",l=e,new Error("discriminant analysis is not yet supported");if("Matrix"!==n.constructor.name)throw new TypeError("features must be of class Matrix");this.center=o,this.center?(this.means=n.mean("column"),this.meansY=l.mean("column")):this.stdevs=null,this.scale=s,this.scale?(this.stdevs=n.standardDeviation("column"),this.stdevsY=l.standardDeviation("column")):this.means=null,h=a.length>0?a:getFolds(e,5);let u=[];this.model=[],this.tCV=[],this.tOrthCV=[],this.yHatCV=[];let c,m=[],f=[];for(c=0;c<i;c++){let t=new Matrix(l.rows,1),e=new Matrix(l.rows,1),i=new Matrix(l.rows,1),a=[],g=0;for(let r of h){let h=this._getTrainTest(n,l,r),u=h.testFeatures,f=h.trainFeatures,p=h.trainLabels,d=f.mean("column"),w=f.standardDeviation("column");o&&(f.center("column"),p.center("column")),s&&(f.scale("column"),p.scale("column")),a[g]=OPLSNipals(0===c?f:m[c-1][g].filteredX,p),m[c]=a;let x=new nipals(a[g].filteredX,{Y:p});u.center("column",{center:d}),u.scale("column",{scale:w});let y,M=u;for(let t=0;t<c+1;t++)y=M.mmul(m[t][g].weightsXOrtho.transpose()),M.sub(y.mmul(m[t][g].loadingsXOrtho));let v=M.mmul(x.w.transpose()),b=v.mmul(x.betas);for(let n=0;n<r.testIndex.length;n++)t.setRow(r.testIndex[n],[b.get(n,0)]),e.setRow(r.testIndex[n],[v.get(n,0)]),i.setRow(r.testIndex[n],[y.get(n,0)]);g++}if(this.tCV.push(e),this.tOrthCV.push(i),this.yHatCV.push(t),"regression"===this.mode){let e=tss(l.center("column").scale("column")),r=1-tss(l.clone().sub(t))/e;u.push(r)}else if("discriminantAnalysis"===this.mode)throw new Error("discriminant analysis is not yet supported");f=0===c?this._predictAll(n,l):this._predictAll(f.xRes,l,r={scale:!1,center:!1}),f.Q2y=u,this.model.push(f)}let g=this.tCV,p=this.tOrthCV,d=this.model[c-1],w=d.XOrth,x=n.center("column").scale("column"),y=l.center("column").scale("column"),M=x.clone().sub(w),v=new nipals(M,{Y:y}),b=M.clone().sub(v.t.mmul(v.p)),S=this.model.map((t=>t.R2x)),A=this.model.map((t=>t.R2y));this.output={Q2y:u,R2x:S,R2y:A,tPred:d.plsC.t,pPred:d.plsC.p,wPred:d.plsC.w,betasPred:d.plsC.betas,Qpc:d.plsC.q,tCV:g,tOrthCV:p,tOrth:d.tOrth,pOrth:d.pOrth,wOrth:d.wOrth,XOrth:w,yHat:d.totalPred,Yres:d.plsC.yResidual,E:b}}getLogs(){return this.output}getScores(){return{scoresX:this.tCV.map((t=>t.to1DArray())),scoresY:this.tOrthCV.map((t=>t.to1DArray()))}}static load(t){if("string"!=typeof t.name)throw new TypeError("model must have a name property");if("OPLS"!==t.name)throw new RangeError("invalid model: "+t.name);return new OPLS(!0,[],t)}toJSON(){return{name:"OPLS",center:this.center,scale:this.scale,means:this.means,stdevs:this.stdevs,model:this.model,tCV:this.tCV,tOrthCV:this.tOrthCV,yHatCV:this.yHatCV}}predict(t,e={}){let{trueLabels:r=[],nc:n=1}=e,i=[];r.length>0&&(r=Matrix.from1DArray(r.length,1,r),i=r.clone());let o=t.clone();this.center&&(o.center("column",{center:this.means}),i.rows>0&&"regression"===this.mode&&i.center("column",{center:this.meansY})),this.scale&&(o.scale("column",{scale:this.stdevs}),i.rows>0&&"regression"===this.mode&&i.scale("column",{scale:this.stdevsY}));let s,a,l,h,u,c=o.clone();for(let t=0;t<n;t++)a=this.model[t].wOrth.transpose(),l=this.model[t].pOrth,s=c.mmul(a),c.sub(s.mmul(l)),u=c.mmul(this.model[t].plsC.w.transpose()),h=u.mmul(this.model[t].plsC.betas);if(!(i.rows>0))return{tPred:u,tOrth:s,yHat:h};if("regression"===this.mode){let t=tss(i);return{tPred:u,tOrth:s,yHat:h,Q2y:1-tss(i.clone().sub(h))/t}}if("discriminantAnalysis"===this.mode){let t=[];return t=ConfusionMatrix.fromLabels(r.to1DArray(),h.to1DArray()),{tPred:u,tOrth:s,yHat:h,confusionMatrix:t}}}_predictAll(t,e,r={}){const{center:n=!0,scale:i=!0}=r;n&&(t.center("column"),e.center("column")),i&&(t.scale("column"),e.scale("column"),this.tssy=tss(e),this.tssx=tss(t));let o=OPLSNipals(t,e),s=new nipals(o.filteredX,{Y:e}),a=o.filteredX.mmul(s.w.transpose()),l=a.mmul(s.betas);return{R2y:1-tss(e.clone().sub(l))/this.tssy,R2x:tss(s.t.mmul(s.p))/this.tssx,xRes:o.filteredX,tOrth:o.scoresXOrtho,pOrth:o.loadingsXOrtho,wOrth:o.weightsXOrtho,tPred:a,totalPred:l,XOrth:o.scoresXOrtho.mmul(o.loadingsXOrtho),oplsC:o,plsC:s}}_getTrainTest(t,e,r){let n=new Matrix(r.testIndex.length,t.columns),i=new Matrix(r.testIndex.length,1);r.testIndex.forEach(((r,o)=>{n.setRow(o,t.getRow(r)),i.setRow(o,e.getRow(r))}));let o=new Matrix(r.trainIndex.length,t.columns),s=new Matrix(r.trainIndex.length,1);return r.trainIndex.forEach(((r,n)=>{o.setRow(n,t.getRow(r)),s.setRow(n,e.getRow(r))})),{trainFeatures:o,testFeatures:n,trainLabels:s,testLabels:i}}}var require$$0=getAugmentedNamespace(MatrixLib);function logistic(t){return 1/(1+Math.exp(-t))}function expELU(t,e){return t<0?e*(Math.exp(t)-1):t}function softExponential(t,e){return e<0?-Math.log(1-e*(t+e))/e:e>0?(Math.exp(e*t)-1)/e+e:t}function softExponentialPrime(t,e){return e<0?1/(1-e*(e+t)):Math.exp(e*t)}const ACTIVATION_FUNCTIONS={tanh:{activation:Math.tanh,derivate:t=>1-t*t},identity:{activation:t=>t,derivate:()=>1},logistic:{activation:logistic,derivate:t=>logistic(t)*(1-logistic(t))},arctan:{activation:Math.atan,derivate:t=>1/(t*t+1)},softsign:{activation:t=>t/(1+Math.abs(t)),derivate:t=>1/((1+Math.abs(t))*(1+Math.abs(t)))},relu:{activation:t=>t<0?0:t,derivate:t=>t<0?0:1},softplus:{activation:t=>Math.log(1+Math.exp(t)),derivate:t=>1/(1+Math.exp(-t))},bent:{activation:t=>(Math.sqrt(t*t+1)-1)/2+t,derivate:t=>t/(2*Math.sqrt(t*t+1))+1},sinusoid:{activation:Math.sin,derivate:Math.cos},sinc:{activation:t=>0===t?1:Math.sin(t)/t,derivate:t=>0===t?0:Math.cos(t)/t-Math.sin(t)/(t*t)},gaussian:{activation:t=>Math.exp(-t*t),derivate:t=>-2*t*Math.exp(-t*t)},"parametric-relu":{activation:(t,e)=>t<0?e*t:t,derivate:(t,e)=>t<0?e:1},"exponential-elu":{activation:expELU,derivate:(t,e)=>t<0?expELU(t,e)+e:1},"soft-exponential":{activation:softExponential,derivate:softExponentialPrime}};class Layer{constructor(t){this.inputSize=t.inputSize,this.outputSize=t.outputSize,this.regularization=t.regularization,this.epsilon=t.epsilon,this.activation=t.activation,this.activationParam=t.activationParam;var e=ACTIVATION_FUNCTIONS[t.activation],r=e.activation.length,n=r>1?r=>e.activation(r,t.activationParam):e.activation,i=r>1?r=>e.derivate(r,t.activationParam):e.derivate;this.activationFunction=function(t,e){this.set(t,e,n(this.get(t,e)))},this.derivate=function(t,e){this.set(t,e,i(this.get(t,e)))},t.model?(this.W=require$$0.Matrix.checkMatrix(t.W),this.b=require$$0.Matrix.checkMatrix(t.b)):(this.W=require$$0.Matrix.rand(this.inputSize,this.outputSize),this.b=require$$0.Matrix.zeros(1,this.outputSize),this.W.apply((function(e,r){this.set(e,r,this.get(e,r)/Math.sqrt(t.inputSize))})))}forward(t){var e=t.mmul(this.W).addRowVector(this.b);return e.apply(this.activationFunction),this.a=e.clone(),e}backpropagation(t,e){this.dW=e.transpose().mmul(t),this.db=require$$0.Matrix.rowVector(t.sum("column"));var r=e.clone();return t.mmul(this.W.transpose()).mul(r.apply(this.derivate))}update(){this.dW.add(this.W.clone().mul(this.regularization)),this.W.add(this.dW.mul(-this.epsilon)),this.b.add(this.db.mul(-this.epsilon))}toJSON(){return{model:"Layer",inputSize:this.inputSize,outputSize:this.outputSize,regularization:this.regularization,epsilon:this.epsilon,activation:this.activation,W:this.W,b:this.b}}static load(t){if("Layer"!==t.model)throw new RangeError("the current model is not a Layer model");return new Layer(t)}}class OutputLayer extends Layer{constructor(t){super(t),this.activationFunction=function(t,e){this.set(t,e,Math.exp(this.get(t,e)))}}static load(t){if("Layer"!==t.model)throw new RangeError("the current model is not a Layer model");return new OutputLayer(t)}}class FeedForwardNeuralNetworks{constructor(t){if((t=t||{}).model){this.hiddenLayers=t.hiddenLayers,this.iterations=t.iterations,this.learningRate=t.learningRate,this.regularization=t.regularization,this.dicts=t.dicts,this.activation=t.activation,this.activationParam=t.activationParam,this.model=new Array(t.layers.length);for(var e=0;e<this.model.length-1;++e)this.model[e]=Layer.load(t.layers[e]);this.model[this.model.length-1]=OutputLayer.load(t.layers[this.model.length-1])}else this.hiddenLayers=t.hiddenLayers||[10],this.iterations=t.iterations||50,this.learningRate=t.learningRate||.01,this.regularization=t.regularization||.01,this.activation=t.activation||"tanh",this.activationParam=t.activationParam||1,this.activation in Object.keys(ACTIVATION_FUNCTIONS)||(this.activation="tanh")}buildNetwork(t,e){var r=this.hiddenLayers.length-1+2;this.model=new Array(r),this.model[0]=new Layer({inputSize:t,outputSize:this.hiddenLayers[0],activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate});for(var n=1;n<this.hiddenLayers.length;++n)this.model[n]=new Layer({inputSize:this.hiddenLayers[n-1],outputSize:this.hiddenLayers[n],activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate});this.model[r-1]=new OutputLayer({inputSize:this.hiddenLayers[this.hiddenLayers.length-1],outputSize:e,activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate})}train(t,e){t=require$$0.Matrix.checkMatrix(t),this.dicts=dictOutputs(e);var r=t.columns,n=Object.keys(this.dicts.inputs).length;this.model||this.buildNetwork(r,n);for(var i=0;i<this.iterations;++i){var o=this.propagate(t);this.backpropagation(t,e,o)}}propagate(t){for(var e=t,r=0;r<this.model.length;++r)e=this.model[r].forward(e);return e.divColumnVector(e.sum("row"))}backpropagation(t,e,r){for(var n=0;n<r.rows;++n)r.set(n,this.dicts.inputs[e[n]],r.get(n,this.dicts.inputs[e[n]])-1);var i=r;for(n=this.model.length-1;n>=0;--n){var o=n>0?this.model[n-1].a:t;i=this.model[n].backpropagation(i,o)}for(n=0;n<this.model.length;++n)this.model[n].update()}predict(t){t=require$$0.Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=this.propagate(t),n=0;n<t.rows;++n)e[n]=this.dicts.outputs[r.maxRowIndex(n)[1]];return e}toJSON(){for(var t={model:"FNN",hiddenLayers:this.hiddenLayers,iterations:this.iterations,learningRate:this.learningRate,regularization:this.regularization,activation:this.activation,activationParam:this.activationParam,dicts:this.dicts,layers:new Array(this.model.length)},e=0;e<this.model.length;++e)t.layers[e]=this.model[e].toJSON();return t}static load(t){if("FNN"!==t.model)throw new RangeError("the current model is not a feed forward network");return new FeedForwardNeuralNetworks(t)}}function dictOutputs(t){for(var e={},r={},n=0,i=0;i<t.length;i+=1)void 0===e[t[i]]&&(e[t[i]]=n,r[n]=t[i],n++);return{inputs:e,outputs:r}}var FeedForwardNeuralNetwork=FeedForwardNeuralNetworks;function NodeSquare(t,e,r,n){this.x=t,this.y=e,this.weights=r,this.som=n,this.neighbors={}}NodeSquare.prototype.adjustWeights=function(t,e,r){for(var n=0,i=this.weights.length;n<i;n++)this.weights[n]+=e*r*(t[n]-this.weights[n])},NodeSquare.prototype.getDistance=function(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))},NodeSquare.prototype.getDistanceTorus=function(t){var e=Math.abs(this.x-t.x),r=Math.abs(this.y-t.y);return Math.max(Math.min(e,this.som.gridDim.x-e),Math.min(r,this.som.gridDim.y-r))},NodeSquare.prototype.getNeighbors=function(t){if(!this.neighbors[t]){var e,r,n,i;if(this.neighbors[t]=new Array(2),this[t]>0?e=this[t]-1:this.som.torus&&(e=this.som.gridDim[t]-1),void 0!==e)"x"===t?(r=e,n=this.y):(r=this.x,n=e),this.neighbors[t][0]=this.som.nodes[r][n];this[t]<this.som.gridDim[t]-1?i=this[t]+1:this.som.torus&&(i=0),void 0!==i&&("x"===t?(r=i,n=this.y):(r=this.x,n=i),this.neighbors[t][1]=this.som.nodes[r][n])}return this.neighbors[t]},NodeSquare.prototype.getPos=function(t,e){var r,n,i=this.getNeighbors(t),o=this.som.distance;i[0]?i[1]?o(e,i[0].weights)<o(e,i[1].weights)?(r=i[0],n=-1):(r=i[1],n=1):(r=i[0],n=-1):(r=i[1],n=1);var s=1-o(e,this.weights),a=1-o(e,r.weights);return.5+.5*((s-a)/(2-s-a))*n},NodeSquare.prototype.getPosition=function(t){return[this.getPos("x",t),this.getPos("y",t)]};var nodeSquare=NodeSquare;function NodeHexagonal(t,e,r,n){nodeSquare.call(this,t,e,r,n),this.hX=t-Math.floor(e/2),this.z=0-this.hX-e}NodeHexagonal.prototype=new nodeSquare,NodeHexagonal.prototype.constructor=NodeHexagonal,NodeHexagonal.prototype.getDistance=function(t){return Math.max(Math.abs(this.hX-t.hX),Math.abs(this.y-t.y),Math.abs(this.z-t.z))},NodeHexagonal.prototype.getDistanceTorus=function(t){var e=Math.abs(this.hX-t.hX),r=Math.abs(this.y-t.y),n=Math.abs(this.z-t.z);return Math.max(Math.min(e,this.som.gridDim.x-e),Math.min(r,this.som.gridDim.y-r),Math.min(n,this.som.gridDim.z-n))},NodeHexagonal.prototype.getPosition=function(){throw new Error("Unimplemented : cannot get position of the points for hexagonal grid")};var nodeHexagonal=NodeHexagonal,defaultOptions$6={fields:3,randomizer:Math.random,distance:squareEuclidean,iterations:10,learningRate:.1,gridType:"rect",torus:!0,method:"random"};function SOM(t,e,r,n){for(var i in this.x=t,this.y=e,r=r||{},this.options={},defaultOptions$6)r.hasOwnProperty(i)?this.options[i]=r[i]:this.options[i]=defaultOptions$6[i];if("number"==typeof this.options.fields)this.numWeights=this.options.fields;else{if(!Array.isArray(this.options.fields))throw new Error("Invalid fields definition");this.numWeights=this.options.fields.length;var o=getConverters(this.options.fields);this.extractor=o.extractor,this.creator=o.creator}if("rect"===this.options.gridType)this.nodeType=nodeSquare,this.gridDim={x:t,y:e};else{this.nodeType=nodeHexagonal;var s=this.x-Math.floor(this.y/2);this.gridDim={x:s,y:this.y,z:-(0-s-this.y)}}if(this.torus=this.options.torus,this.distanceMethod=this.torus?"getDistanceTorus":"getDistance",this.distance=this.options.distance,this.maxDistance=getMaxDistance(this.distance,this.numWeights),!0!==n){if(!(t>0&&e>0))throw new Error("x and y must be positive");this.times={findBMU:0,adjust:0},this.randomizer=this.options.randomizer,this.iterationCount=0,this.iterations=this.options.iterations,this.startLearningRate=this.learningRate=this.options.learningRate,this.mapRadius=Math.floor(Math.max(t,e)/2),this.algorithmMethod=this.options.method,this._initNodes(),this.done=!1}else this.done=!0}function getConverters(t){for(var e=t.length,r=new Array(e),n=new Array(e),i=0;i<e;i++)r[i]=getNormalizer(t[i].range),n[i]=getDenormalizer(t[i].range);return{extractor:function(n){for(var i=new Array(e),o=0;o<e;o++)i[o]=r[o](n[t[o].name]);return i},creator:function(r){for(var i={},o=0;o<e;o++)i[t[o].name]=n[o](r[o]);return i}}}function getNormalizer(t){return function(e){return(e-t[0])/(t[1]-t[0])}}function getDenormalizer(t){return function(e){return t[0]+e*(t[1]-t[0])}}function squareEuclidean(t,e){for(var r=0,n=0,i=t.length;n<i;n++)r+=(t[n]-e[n])*(t[n]-e[n]);return r}function getRandomValue(t,e){return t[Math.floor(e()*t.length)]}function getMaxDistance(t,e){for(var r=new Array(e),n=new Array(e),i=0;i<e;i++)r[i]=0,n[i]=1;return t(r,n)}SOM.load=function loadModel(model,distance){if("SOM"===model.name){var x=model.data.length,y=model.data[0].length;distance?model.options.distance=distance:model.options.distance&&(model.options.distance=eval("("+model.options.distance+")"));var som=new SOM(x,y,model.options,!0);som.nodes=new Array(x);for(var i=0;i<x;i++){som.nodes[i]=new Array(y);for(var j=0;j<y;j++)som.nodes[i][j]=new som.nodeType(i,j,model.data[i][j],som)}return som}throw new Error("expecting a SOM model")},SOM.prototype.export=function(t){if(!this.done)throw new Error("model is not ready yet");var e={name:"SOM"};e.options={fields:this.options.fields,gridType:this.options.gridType,torus:this.options.torus},e.data=new Array(this.x);for(var r=0;r<this.x;r++){e.data[r]=new Array(this.y);for(var n=0;n<this.y;n++)e.data[r][n]=this.nodes[r][n].weights}return t&&(e.options.distance=this.distance.toString()),e},SOM.prototype._initNodes=function(){var t,e,r,n=Date.now();for(this.nodes=new Array(this.x),t=0;t<this.x;t++)for(this.nodes[t]=new Array(this.y),e=0;e<this.y;e++){var i=new Array(this.numWeights);for(r=0;r<this.numWeights;r++)i[r]=this.randomizer();this.nodes[t][e]=new this.nodeType(t,e,i,this)}this.times.initNodes=Date.now()-n},SOM.prototype.setTraining=function(t){if(this.trainingSet)throw new Error("training set has already been set");var e,r=Date.now(),n=t,i=t.length;if(this.extractor)for(n=new Array(i),e=0;e<i;e++)n[e]=this.extractor(t[e]);this.numIterations=this.iterations*i,"random"===this.algorithmMethod?this.timeConstant=this.numIterations/Math.log(this.mapRadius):this.timeConstant=i/Math.log(this.mapRadius),this.trainingSet=n,this.times.setTraining=Date.now()-r},SOM.prototype.trainOne=function(){return!this.done&&(this.numIterations-- >0?("random"===this.algorithmMethod?(t=this.mapRadius*Math.exp(-this.iterationCount/this.timeConstant),e=getRandomValue(this.trainingSet,this.randomizer),this._adjust(e,t),this.learningRate=this.startLearningRate*Math.exp(-this.iterationCount/this.numIterations)):(r=-Math.floor(this.iterationCount/this.trainingSet.length),t=this.mapRadius*Math.exp(r/this.timeConstant),e=this.trainingSet[this.iterationCount%this.trainingSet.length],this._adjust(e,t),(this.iterationCount+1)%this.trainingSet.length==0&&(this.learningRate=this.startLearningRate*Math.exp(r/Math.floor(this.numIterations/this.trainingSet.length)))),this.iterationCount++,!0):(this.done=!0,!1));var t,e,r},SOM.prototype._adjust=function(t,e){var r,n,i,o,s=Date.now(),a=this._findBestMatchingUnit(t),l=Date.now();this.times.findBMU+=l-s;var h=Math.floor(e),u=a.x-h,c=a.x+h,m=a.y-h,f=a.y+h;for(r=u;r<=c;r++){var g=r;for(r<0?g+=this.x:r>=this.x&&(g-=this.x),n=m;n<=f;n++){var p=n;n<0?p+=this.y:n>=this.y&&(p-=this.y),(i=a[this.distanceMethod](this.nodes[g][p]))<e&&(o=Math.exp(-i/(2*e)),this.nodes[g][p].adjustWeights(t,this.learningRate,o))}}this.times.adjust+=Date.now()-l},SOM.prototype.train=function(t){if(!this.done)for(this.setTraining(t);this.trainOne(););},SOM.prototype.getConvertedNodes=function(){for(var t=new Array(this.x),e=0;e<this.x;e++){t[e]=new Array(this.y);for(var r=0;r<this.y;r++){var n=this.nodes[e][r];t[e][r]=this.creator?this.creator(n.weights):n.weights}}return t},SOM.prototype._findBestMatchingUnit=function(t){for(var e,r,n=1/0,i=0;i<this.x;i++)for(var o=0;o<this.y;o++)(r=this.distance(this.nodes[i][o].weights,t))<n&&(n=r,e=this.nodes[i][o]);return e},SOM.prototype.predict=function(t,e){if("boolean"==typeof t&&(e=t,t=null),t||(t=this.trainingSet),Array.isArray(t)&&(Array.isArray(t[0])||"object"==typeof t[0])){var r=this;return t.map((function(t){return r._predict(t,e)}))}return this._predict(t,e)},SOM.prototype._predict=function(t,e){Array.isArray(t)||(t=this.extractor(t));var r=this._findBestMatchingUnit(t),n=[r.x,r.y];return e&&(n[2]=r.getPosition(t)),n},SOM.prototype.getQuantizationError=function(){for(var t=this.getFit(),e=t.length,r=0,n=0;n<e;n++)r+=t[n];return r/e},SOM.prototype.getFit=function(t){t||(t=this.trainingSet);for(var e,r=t.length,n=new Array(r),i=0;i<r;i++)e=this._findBestMatchingUnit(t[i]),n[i]=Math.sqrt(this.distance(t[i],e.weights));return n};var src=SOM;function maybeToPrecision(t,e){return t<0?(t=0-t,"number"==typeof e?"- "+t.toPrecision(e):"- "+t.toString()):"number"==typeof e?t.toPrecision(e):t.toString()}function checkArraySize(t,e){if(!Array.isArray(t)||!Array.isArray(e))throw new TypeError("x and y must be arrays");if(t.length!==e.length)throw new RangeError("x and y arrays must have the same length")}class BaseRegression{constructor(){if(new.target===BaseRegression)throw new Error("BaseRegression must be subclassed")}predict(t){if("number"==typeof t)return this._predict(t);if(Array.isArray(t)){const e=[];for(let r=0;r<t.length;r++)e.push(this._predict(t[r]));return e}throw new TypeError("x must be a number or array")}_predict(){throw new Error("_predict must be implemented")}train(){}toString(){return""}toLaTeX(){return""}score(t,e){if(!Array.isArray(t)||!Array.isArray(e)||t.length!==e.length)throw new Error("x and y must be arrays of the same length");const r=t.length,n=new Array(r);for(let e=0;e<r;e++)n[e]=this._predict(t[e]);let i=0,o=0,s=0,a=0,l=0,h=0,u=0;for(let t=0;t<r;t++)i+=n[t],o+=e[t],l+=n[t]*n[t],h+=e[t]*e[t],u+=n[t]*e[t],0!==e[t]&&(s+=(e[t]-n[t])*(e[t]-n[t])/e[t]),a+=(e[t]-n[t])*(e[t]-n[t]);const c=(r*u-i*o)/Math.sqrt((r*l-i*i)*(r*h-o*o));return{r:c,r2:c*c,chi2:s,rmsd:Math.sqrt(a/r)}}}class PolynomialRegression extends BaseRegression{constructor(t,e,r){super(),!0===t?(this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients):(checkArraySize(t,e),regress(this,t,e,r))}_predict(t){let e=0;for(let r=0;r<this.powers.length;r++)e+=this.coefficients[r]*Math.pow(t,this.powers[r]);return e}toJSON(){return{name:"polynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",n="",i=" * ";e&&(r="^{",n="}",i="");let o="",s="";for(let e=0;e<this.coefficients.length;e++)s="",0!==this.coefficients[e]&&(s=0===this.powers[e]?maybeToPrecision(this.coefficients[e],t):1===this.powers[e]?maybeToPrecision(this.coefficients[e],t)+i+"x":`${maybeToPrecision(this.coefficients[e],t)+i}x${r}${this.powers[e]}${n}`,this.coefficients[e]>0&&e!==this.coefficients.length-1?s=" + "+s:e!==this.coefficients.length-1&&(s=" "+s)),o=s+o;return"+"===o.charAt(0)&&(o=o.slice(1)),"f(x) = "+o}static load(t){if("polynomialRegression"!==t.name)throw new TypeError("not a polynomial regression model");return new PolynomialRegression(!0,t)}}function regress(t,e,r,n){const i=e.length;let o;if(Array.isArray(n))o=n,n=o.length;else{n++,o=new Array(n);for(let t=0;t<n;t++)o[t]=t}const s=new Matrix(i,n),a=new Matrix([r]);for(let t=0;t<n;t++)for(let r=0;r<i;r++)0===o[t]?s.set(r,t,1):s.set(r,t,Math.pow(e[r],o[t]));const l=new MatrixTransposeView(s),h=l.mmul(s),u=l.mmul(new MatrixTransposeView(a));t.degree=n-1,t.powers=o,t.coefficients=solve(h,u).to1DArray()}class SimpleLinearRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=[e.intercept,e.slope]):(checkArraySize(t,e),regress$1(this,t,e))}toJSON(){return{name:"simpleLinearRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){let e="f(x) = ";if(0!==this.slope){const r=maybeToPrecision(this.slope,t);if(e+=("1"===r?"":r+" * ")+"x",0!==this.intercept){const r=Math.abs(this.intercept);e+=` ${r===this.intercept?"+":"-"} ${maybeToPrecision(r,t)}`}}else e+=maybeToPrecision(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("simpleLinearRegression"!==t.name)throw new TypeError("not a SLR model");return new SimpleLinearRegression(!0,t)}}function regress$1(t,e,r){const n=e.length;let i=0,o=0,s=0,a=0;for(let t=0;t<n;t++)i+=e[t],o+=r[t],s+=e[t]*e[t],a+=e[t]*r[t];const l=n*a-i*o;t.slope=l/(n*s-i*i),t.intercept=1/n*o-t.slope*(1/n)*i,t.coefficients=[t.intercept,t.slope]}class ExponentialRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(checkArraySize(t,e),regress$2(this,t,e))}_predict(t){return this.B*Math.exp(t*this.A)}toJSON(){return{name:"exponentialRegression",A:this.A,B:this.B}}toString(t){return`f(x) = ${maybeToPrecision(this.B,t)} * e^(${maybeToPrecision(this.A,t)} * x)`}toLaTeX(t){return this.A>=0?`f(x) = ${maybeToPrecision(this.B,t)}e^{${maybeToPrecision(this.A,t)}x}`:`f(x) = \\frac{${maybeToPrecision(this.B,t)}}{e^{${maybeToPrecision(-this.A,t)}x}}`}static load(t){if("exponentialRegression"!==t.name)throw new TypeError("not a exponential regression model");return new ExponentialRegression(!0,t)}}function regress$2(t,e,r){const n=e.length,i=new Array(n);for(let t=0;t<n;t++)i[t]=Math.log(r[t]);const o=new SimpleLinearRegression(e,i);t.A=o.slope,t.B=Math.exp(o.intercept)}class PowerRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(checkArraySize(t,e),regress$3(this,t,e))}_predict(t){return this.A*Math.pow(t,this.B)}toJSON(){return{name:"powerRegression",A:this.A,B:this.B}}toString(t){return`f(x) = ${maybeToPrecision(this.A,t)} * x^${maybeToPrecision(this.B,t)}`}toLaTeX(t){let e="";return e=this.B>=0?`f(x) = ${maybeToPrecision(this.A,t)}x^{${maybeToPrecision(this.B,t)}}`:`f(x) = \\frac{${maybeToPrecision(this.A,t)}}{x^{${maybeToPrecision(-this.B,t)}}}`,e=e.replace(/e([+-]?[0-9]+)/g,"e^{$1}"),e}static load(t){if("powerRegression"!==t.name)throw new TypeError("not a power regression model");return new PowerRegression(!0,t)}}function regress$3(t,e,r){const n=e.length,i=new Array(n),o=new Array(n);for(let t=0;t<n;t++)i[t]=Math.log(e[t]),o[t]=Math.log(r[t]);const s=new SimpleLinearRegression(i,o);t.A=Math.exp(s.intercept),t.B=s.slope}class MultivariateLinearRegression{constructor(t,e,r={}){const{intercept:n=!0,statistics:i=!0}=r;if(this.statistics=i,!0===t)this.weights=e.weights,this.inputs=e.inputs,this.outputs=e.outputs,this.intercept=e.intercept;else{t=new Matrix(t),e=new Matrix(e),n&&t.addColumn(new Array(t.rows).fill(1));let r=t.transpose();const o=r.mmul(t),s=r.mmul(e),a=new SingularValueDecomposition(o).inverse(),l=s.transpose().mmul(a).transpose();if(this.weights=l.to2DArray(),this.inputs=t.columns,this.outputs=e.columns,n&&this.inputs--,this.intercept=n,i){const r=t.mmul(l),n=e.clone().addM(r.neg()).to2DArray().map((t=>Math.pow(t[0],2))).reduce(((t,e)=>t+e))/(e.rows-t.columns);this.stdError=Math.sqrt(n),this.stdErrorMatrix=pseudoInverse(o).mul(n),this.stdErrors=this.stdErrorMatrix.diagonal().map((t=>Math.sqrt(t))),this.tStats=this.weights.map(((t,e)=>0===this.stdErrors[e]?0:t[0]/this.stdErrors[e]))}}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return this._predict(t);if(Array.isArray(t[0])){const e=new Array(t.length);for(let r=0;r<t.length;r++)e[r]=this._predict(t[r]);return e}}else if(Matrix.isMatrix(t)){const e=new Matrix(t.rows,this.outputs);for(let r=0;r<t.rows;r++)e.setRow(r,this._predict(t.getRow(r)));return e}throw new TypeError("x must be a matrix or array of numbers")}_predict(t){const e=new Array(this.outputs);if(this.intercept)for(let t=0;t<this.outputs;t++)e[t]=this.weights[this.inputs][t];else e.fill(0);for(let r=0;r<this.inputs;r++)for(let n=0;n<this.outputs;n++)e[n]+=this.weights[r][n]*t[r];return e}score(){throw new Error("score method is not implemented yet")}toJSON(){return{name:"multivariateLinearRegression",weights:this.weights,inputs:this.inputs,outputs:this.outputs,intercept:this.intercept,summary:this.statistics?{regressionStatistics:{standardError:this.stdError,observations:this.outputs},variables:this.weights.map(((t,e)=>({label:e===this.weights.length-1?"Intercept":"X Variable "+(e+1),coefficients:t,standardError:this.stdErrors[e],tStat:this.tStats[e]})))}:void 0}}static load(t){if("multivariateLinearRegression"!==t.name)throw new Error("not a MLR model");return new MultivariateLinearRegression(!0,t)}}var require$$0$1=getAugmentedNamespace(euclidean$1);const{squaredEuclidean:squaredEuclidean$1}=require$$0$1,defaultOptions$7={sigma:1};class GaussianKernel{constructor(t){t=Object.assign({},defaultOptions$7,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=squaredEuclidean$1(t,e);return Math.exp(-r/this.divisor)}}var gaussianKernel=GaussianKernel;const defaultOptions$8={degree:1,constant:1,scale:1};class PolynomialKernel{constructor(t){t=Object.assign({},defaultOptions$8,t),this.degree=t.degree,this.constant=t.constant,this.scale=t.scale}compute(t,e){for(var r=0,n=0;n<t.length;n++)r+=t[n]*e[n];return Math.pow(this.scale*r+this.constant,this.degree)}}var polynomialKernel=PolynomialKernel;const defaultOptions$9={alpha:.01,constant:-Math.E};class SigmoidKernel{constructor(t){t=Object.assign({},defaultOptions$9,t),this.alpha=t.alpha,this.constant=t.constant}compute(t,e){for(var r=0,n=0;n<t.length;n++)r+=t[n]*e[n];return Math.tanh(this.alpha*r+this.constant)}}var sigmoidKernel=SigmoidKernel;const defaultOptions$a={sigma:1,degree:1};class ANOVAKernel{constructor(t){t=Object.assign({},defaultOptions$a,t),this.sigma=t.sigma,this.degree=t.degree}compute(t,e){for(var r=0,n=Math.min(t.length,e.length),i=1;i<=n;++i)r+=Math.pow(Math.exp(-this.sigma*Math.pow(Math.pow(t[i-1],i)-Math.pow(e[i-1],i),2)),this.degree);return r}}var anovaKernel=ANOVAKernel;const{squaredEuclidean:squaredEuclidean$2}=require$$0$1,defaultOptions$b={sigma:1};class CauchyKernel{constructor(t){t=Object.assign({},defaultOptions$b,t),this.sigma=t.sigma}compute(t,e){return 1/(1+squaredEuclidean$2(t,e)/(this.sigma*this.sigma))}}var cauchyKernel=CauchyKernel;const{euclidean:euclidean$2}=require$$0$1,defaultOptions$c={sigma:1};class ExponentialKernel{constructor(t){t=Object.assign({},defaultOptions$c,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=euclidean$2(t,e);return Math.exp(-r/this.divisor)}}var exponentialKernel=ExponentialKernel;class HistogramIntersectionKernel{compute(t,e){for(var r=Math.min(t.length,e.length),n=0,i=0;i<r;++i)n+=Math.min(t[i],e[i]);return n}}var histogramIntersectionKernel=HistogramIntersectionKernel;const{euclidean:euclidean$3}=require$$0$1,defaultOptions$d={sigma:1};class LaplacianKernel{constructor(t){t=Object.assign({},defaultOptions$d,t),this.sigma=t.sigma}compute(t,e){const r=euclidean$3(t,e);return Math.exp(-r/this.sigma)}}var laplacianKernel=LaplacianKernel;const{squaredEuclidean:squaredEuclidean$3}=require$$0$1,defaultOptions$e={constant:1};class MultiquadraticKernel{constructor(t){t=Object.assign({},defaultOptions$e,t),this.constant=t.constant}compute(t,e){return Math.sqrt(squaredEuclidean$3(t,e)+this.constant*this.constant)}}var multiquadraticKernel=MultiquadraticKernel;const{squaredEuclidean:squaredEuclidean$4}=require$$0$1,defaultOptions$f={constant:1};class RationalQuadraticKernel{constructor(t){t=Object.assign({},defaultOptions$f,t),this.constant=t.constant}compute(t,e){const r=squaredEuclidean$4(t,e);return 1-r/(r+this.constant)}}var rationalQuadraticKernel=RationalQuadraticKernel;const{Matrix:Matrix$1,MatrixTransposeView:MatrixTransposeView$1}=require$$0,kernelType={gaussian:gaussianKernel,rbf:gaussianKernel,polynomial:polynomialKernel,poly:polynomialKernel,anova:anovaKernel,cauchy:cauchyKernel,exponential:exponentialKernel,histogram:histogramIntersectionKernel,min:histogramIntersectionKernel,laplacian:laplacianKernel,multiquadratic:multiquadraticKernel,rational:rationalQuadraticKernel,sigmoid:sigmoidKernel,mlp:sigmoidKernel};class Kernel{constructor(t,e){if(this.kernelType=t,"linear"!==t)if("string"==typeof t){t=t.toLowerCase();var r=kernelType[t];if(!r)throw new Error("unsupported kernel type: "+t);this.kernelFunction=new r(e)}else{if("object"!=typeof t||"function"!=typeof t.compute)throw new TypeError("first argument must be a valid kernel type or instance");this.kernelFunction=t}}compute(t,e){if(t=Matrix$1.checkMatrix(t),e=void 0===e?t:Matrix$1.checkMatrix(e),"linear"===this.kernelType)return t.mmul(new MatrixTransposeView$1(e));const r=new Matrix$1(t.rows,e.rows);if(t===e)for(let e=0;e<t.rows;e++)for(let n=e;n<t.rows;n++){const i=this.kernelFunction.compute(t.getRow(e),t.getRow(n));r.set(e,n,i),r.set(n,e,i)}else for(let n=0;n<t.rows;n++)for(let i=0;i<e.rows;i++)r.set(n,i,this.kernelFunction.compute(t.getRow(n),e.getRow(i)));return r}}var kernel=Kernel;class TheilSenRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=e.coefficients):(checkArraySize(t,e),theilSen(this,t,e))}toJSON(){return{name:"TheilSenRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){var e="f(x) = ";if(this.slope){var r=maybeToPrecision(this.slope,t);if(e+=(Math.abs(r-1)<1e-5?"":r+" * ")+"x",this.intercept){var n=Math.abs(this.intercept);e+=` ${n===this.intercept?"+":"-"} ${maybeToPrecision(n,t)}`}}else e+=maybeToPrecision(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("TheilSenRegression"!==t.name)throw new TypeError("not a Theil-Sen model");return new TheilSenRegression(!0,t)}}function theilSen(t,e,r){let n=e.length,i=new Array(n*n),o=0;for(let t=0;t<n;++t)for(let s=t+1;s<n;++s)e[t]!==e[s]&&(i[o++]=(r[s]-r[t])/(e[s]-e[t]));i.length=o;let s=median(i),a=new Array(n);for(let t=0;t<n;++t)a[t]=r[t]-s*e[t];t.slope=s,t.intercept=median(a),t.coefficients=[t.intercept,t.slope]}class RobustPolynomialRegression extends BaseRegression{constructor(t,e,r){super(),!0===t?(this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients):(checkArraySize(t,e),robustPolynomial(this,t,e,r))}toJSON(){return{name:"robustPolynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}_predict(t){return predict(t,this.powers,this.coefficients)}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",n="",i=" * ";e&&(r="^{",n="}",i="");let o="",s="";for(let e=0;e<this.coefficients.length;e++)s="",0!==this.coefficients[e]&&(s=0===this.powers[e]?maybeToPrecision(this.coefficients[e],t):1===this.powers[e]?maybeToPrecision(this.coefficients[e],t)+i+"x":`${maybeToPrecision(this.coefficients[e],t)+i}x${r}${this.powers[e]}${n}`,this.coefficients[e]>0&&e!==this.coefficients.length-1?s=" + "+s:e!==this.coefficients.length-1&&(s=" "+s)),o=s+o;return"+"===o.charAt(0)&&(o=o.slice(1)),"f(x) = "+o}static load(t){if("robustPolynomialRegression"!==t.name)throw new TypeError("not a RobustPolynomialRegression model");return new RobustPolynomialRegression(!0,t)}}function robustPolynomial(t,e,r,n){let i=Array(n).fill(0).map(((t,e)=>e));const o=getRandomTuples(e,r,n);for(var s,a=0;a<o.length;a++){for(var l=calcCoefficients(o[a],i),h=e.slice(),u=0;u<e.length;u++)h[u]=r[u]-predict(e[u],i,l),h[u]={residual:h[u]*h[u],coefficients:l};var c=residualsMedian(h);(!s||c.residual<s.residual)&&(s=c)}t.degree=n,t.powers=i,t.coefficients=s.coefficients}function getRandomTuples(t,e,r){for(var n=Math.floor(t.length/r),i=new Array(n),o=0;o<t.length;o++){for(var s=Math.floor(Math.random()*n),a=0;a<t.length;){if(!i[s]){i[s]=[{x:t[o],y:e[o]}];break}if(i[s].length<r){i[s].push({x:t[o],y:e[o]});break}a++,s=(s+1)%n}if(a===t.length)return i}return i}function calcCoefficients(t,e){for(var r=t.slice(),n=t.slice(),i=0;i<r.length;i++){n[i]=[t[i].y],r[i]=new Array(e.length);for(var o=0;o<e.length;o++)r[i][o]=Math.pow(t[i].x,e[o])}return solve(r,n).to1DArray()}function predict(t,e,r){let n=0;for(let i=0;i<e.length;i++)n+=r[i]*Math.pow(t,e[i]);return n}function residualsMedian(t){t.sort(((t,e)=>t.residual-e.residual));var e=t.length,r=Math.floor(e/2);return e%2==0?t[r-1]:t[r]}const toString$3=Object.prototype.toString;function isAnyArray$3(t){return toString$3.call(t).endsWith("Array]")}function errorCalculation(t,e,r){let n=0;const i=r(e);for(let e=0;e<t.x.length;e++)n+=Math.abs(t.y[e]-i(t.x[e]));return n}function gradientFunction(t,e,r,n,i){const o=r.length,s=t.x.length;let a=new Array(o);for(let l=0;l<o;l++){a[l]=new Array(s);let o=r.slice();o[l]+=n;let h=i(o);for(let r=0;r<s;r++)a[l][r]=e[r]-h(t.x[r])}return new Matrix(a)}function matrixFunction(t,e){const r=t.x.length;let n=new Array(r);for(let i=0;i<r;i++)n[i]=[t.y[i]-e[i]];return new Matrix(n)}function step$1(t,e,r,n,i){let o=r*n*n,s=Matrix.eye(e.length,e.length,o);const a=i(e);let l=new Float64Array(t.x.length);for(let e=0;e<t.x.length;e++)l[e]=a(t.x[e]);let h=gradientFunction(t,l,e,n,i),u=matrixFunction(t,l),c=inverse(s.add(h.mmul(h.transpose())));return(e=(e=new Matrix([e])).sub(c.mmul(h).mmul(u).mul(n).transpose())).to1DArray()}function levenbergMarquardt(t,e,r={}){let{maxIterations:n=100,gradientDifference:i=.1,damping:o=0,errorTolerance:s=.01,minValues:a,maxValues:l,initialValues:h}=r;if(o<=0)throw new Error("The damping option must be a positive number");if(!t.x||!t.y)throw new Error("The data parameter must have x and y elements");if(!isAnyArray$3(t.x)||t.x.length<2||!isAnyArray$3(t.y)||t.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(t.x.length!==t.y.length)throw new Error("The data parameter elements must have the same size");let u=h||new Array(e.length).fill(1),c=u.length;if(l=l||new Array(c).fill(Number.MAX_SAFE_INTEGER),a=a||new Array(c).fill(Number.MIN_SAFE_INTEGER),l.length!==a.length)throw new Error("minValues and maxValues must be the same size");if(!isAnyArray$3(u))throw new Error("initialValues must be an array");let m,f=errorCalculation(t,u,e),g=f<=s;for(m=0;m<n&&!g;m++){u=step$1(t,u,o,i,e);for(let t=0;t<c;t++)u[t]=Math.min(Math.max(a[t],u[t]),l[t]);if(f=errorCalculation(t,u,e),isNaN(f))break;g=f<=s}return{parameterValues:u,parameterError:f,iterations:m}}function selection(t,e){let r=[];for(let n=0;n<e.length;n++)r[n]=t[e[n]];return r}function sortCollectionSet(t){let e,r=t.map(((t,e)=>{let r=BigInt(0);return t.forEach((t=>r|=BigInt(1)<<BigInt(t))),{value:t,index:e,key:r}})).sort(((t,e)=>t.key-e.key<0?-1:1)),n=[],i=[];for(let t of r)t.key!==e&&(e=t.key,i.push([]),n.push(t.value)),i[i.length-1].push(t.index);return{values:n,indices:i}}function cssls(t,e,r,n,i){let o=Matrix.zeros(n,i);if(null===r){let r=new CholeskyDecomposition(t);if(!0===r.isPositiveDefinite())o=r.solve(e);else{let r=new LuDecomposition(t);o=!1===r.isSingular()?r.solve(Matrix.eye(n)).mmul(e):solve(t,e,{useSVD:!0})}}else{let s=sortCollectionSet(r).values,a=sortCollectionSet(r).indices;if(1===s.length&&0===s[0].length&&a[0].length===i)return o;if(1===s.length&&s[0].length===n&&a[0].length===i){let r=new CholeskyDecomposition(t);if(!0===r.isPositiveDefinite())o=r.solve(e);else{let r=new LuDecomposition(t);o=!1===r.isSingular()?r.solve(Matrix.eye(n)).mmul(e):solve(t,e,{useSVD:!0})}}else for(let r=0;r<s.length;r++){let n,i=a[r],l=s[r],h=new CholeskyDecomposition(t.selection(l,l));if(!0===h.isPositiveDefinite())n=h.solve(e.selection(l,i));else{let r=new LuDecomposition(t.selection(l,l));n=!1===r.isSingular()?r.solve(Matrix.eye(l.length)).mmul(e.selection(l,i)):solve(t.selection(l,l),e.selection(l,i),{useSVD:!0})}for(let t=0;t<n.rows;t++)for(let e=0;e<n.columns;e++)o.set(l[t],i[e],n.get(t,e))}}return o}function initialisation(t,e){let r=t.rows,n=t.columns,i=e.columns;if(e.rows!==r)throw new Error("ERROR: matrix size not compatible");let o=Matrix.zeros(n,i),s=t.transpose().mmul(t),a=t.transpose().mmul(e),l=cssls(s,a,null,n,i),h=[];for(let t=0;t<i;t++){h[t]=[];for(let e=0;e<n;e++)l.get(e,t)>0?h[t].push(e):l.set(e,t,0)}let u=[];for(let t=0;t<i;t++)h[t].length!==n&&u.push(t);let c=l.clone();return{n:r,l:n,p:i,iter:0,W:o,XtX:s,XtY:a,K:l,Pset:h,Fset:u,D:c}}function setDifference(t,e){let r=[];for(let n of t)e.includes(n)||r.push(n);return r}function optimality(t,e,r,n,i,o,s,a,l,h,u){if(t===e)throw new Error("Maximum number of iterations exceeded");let c=n.subMatrixColumn(i).subtract(r.mmul(a.subMatrixColumn(i)));for(let t=0;t<i.length;t++)s.setColumn(i[t],c.subMatrixColumn([t]));let m=[],f=[];for(let t=0;t<l;t++)f.push(t);for(let t=0;t<i.length;t++){let e=setDifference(f,o[i[t]]);(0===e.length||s.selection(e,[i[t]]).max()<=0)&&m.push(i[t])}if(0!==(i=setDifference(i,m)).length){for(let t=0;t<i.length;t++){for(let e=0;e<l;e++)o[i[t]].includes(e)&&s.set(e,i[t],-1/0);o[i[t]].push(s.subMatrixColumn(i).maxColumnIndex(t)[0])}for(let t=0;t<i.length;t++)u.setColumn(i[t],a.getColumn(i[t]))}for(let t=0;t<h;t++)o[t].sort(((t,e)=>t-e));return{Pset:o,Fset:i,W:s}}function fcnnls(t,e,r={}){t=Matrix.checkMatrix(t),e=Matrix.checkMatrix(e);let{l:n,p:i,iter:o,W:s,XtX:a,XtY:l,K:h,Pset:u,Fset:c,D:m}=initialisation(t,e);const{maxIterations:f=3*t.columns}=r;for(;c.length>0;){let t=cssls(a,l.subMatrixColumn(c),selection(u,c),n,c.length);for(let e=0;e<n;e++)for(let r=0;r<c.length;r++)h.set(e,c[r],t.get(e,r));let e=[];for(let r=0;r<c.length;r++)for(let i=0;i<n;i++)if(t.get(i,r)<0){e.push(r);break}let r=selection(c,e);if(r.length>0){let e=r.length,i=Matrix.ones(n,e);for(;e>0&&o<f;){o++,i.mul(1/0);let s=[[],[]],c=[[],[]];for(let t=0;t<e;t++)for(let e=0;e<u[r[t]].length;e++)h.get(u[r[t]][e],r[t])<0&&(s[0].push(u[r[t]][e]),s[1].push(t),c[0].push(u[r[t]][e]),c[1].push(r[t]));for(let t=0;t<s[0].length;t++)i.set(s[0][t],s[1][t],m.get(c[0][t],c[1][t])/(m.get(c[0][t],c[1][t])-h.get(c[0][t],c[1][t])));let f=[],g=[];for(let t=0;t<e;t++)f[t]=i.minColumn(t),g[t]=i.minColumnIndex(t)[0];f=Matrix.rowVector(f);for(let t=0;t<n;t++)i.setSubMatrix(f,t,0);let p=new Matrix(n,e);p=m.subMatrixColumn(r).subtract(i.subMatrix(0,n-1,0,e-1).mul(m.subMatrixColumn(r).subtract(h.subMatrixColumn(r))));for(let t=0;t<e;t++)m.setColumn(r[t],p.subMatrixColumn([t]));let d=[g,r];for(let t=0;t<e;t++)m.set(d[0][t],d[1][t],0);for(let t=0;t<e;t++)u[r[t]].splice(u[r[t]].findIndex((e=>e===g[t])),1);t=cssls(a,l.subMatrixColumn(r),selection(u,r),n,e);for(let n=0;n<e;n++)h.setColumn(r[n],t.subMatrixColumn([n]));r=[];for(let t=0;t<h.columns;t++)for(let e=0;e<n;e++)if(h.get(e,t)<0){r.push(t);break}e=r.length}}let g=optimality(o,f,a,l,c,u,s,h,n,i,m);u=g.Pset,c=g.Fset,s=g.W}return h}function fcnnlsVector(t,e,r={}){if(!1===Array.isArray(e))throw new TypeError("y must be a 1D Array");return fcnnls(t,Matrix.columnVector(e),r).to1DArray()}var index$3=Object.freeze({__proto__:null,fcnnls:fcnnls,fcnnlsVector:fcnnlsVector}),binarySearch=function(t,e,r,n,i){var o,s;if(void 0===n)n=0;else if((n|=0)<0||n>=t.length)throw new RangeError("invalid lower bound");if(void 0===i)i=t.length-1;else if((i|=0)<n||i>=t.length)throw new RangeError("invalid upper bound");for(;n<=i;)if((s=+r(t[o=n+(i-n>>>1)],e,o,t))<0)n=o+1;else{if(!(s>0))return o;i=o-1}return~n};function assertNumber(t){if("number"!=typeof t)throw new TypeError("Expected a number")}var ascending=(t,e)=>(assertNumber(t),assertNumber(e),Number.isNaN(t)?-1:Number.isNaN(e)?1:t-e),descending=(t,e)=>(assertNumber(t),assertNumber(e),Number.isNaN(t)?1:Number.isNaN(e)?-1:e-t),numSort={ascending:ascending,descending:descending},index$4=Object.freeze(Object.assign(Object.create(null),numSort,{default:numSort,ascending:ascending,descending:descending}));const largestPrime=2147483647,primeNumbers=[largestPrime,5,11,23,47,97,197,397,797,1597,3203,6421,12853,25717,51437,102877,205759,411527,823117,1646237,3292489,6584983,13169977,26339969,52679969,105359939,210719881,421439783,842879579,1685759167,433,877,1759,3527,7057,14143,28289,56591,113189,226379,452759,905551,1811107,3622219,7244441,14488931,28977863,57955739,115911563,231823147,463646329,927292699,1854585413,953,1907,3821,7643,15287,30577,61169,122347,244703,489407,978821,1957651,3915341,7830701,15661423,31322867,62645741,125291483,250582987,501165979,1002331963,2004663929,1039,2081,4177,8363,16729,33461,66923,133853,267713,535481,1070981,2141977,4283963,8567929,17135863,34271747,68543509,137087021,274174111,548348231,1096696463,31,67,137,277,557,1117,2237,4481,8963,17929,35863,71741,143483,286973,573953,1147921,2295859,4591721,9183457,18366923,36733847,73467739,146935499,293871013,587742049,1175484103,599,1201,2411,4831,9677,19373,38747,77509,155027,310081,620171,1240361,2480729,4961459,9922933,19845871,39691759,79383533,158767069,317534141,635068283,1270136683,311,631,1277,2557,5119,10243,20507,41017,82037,164089,328213,656429,1312867,2625761,5251529,10503061,21006137,42012281,84024581,168049163,336098327,672196673,1344393353,3,7,17,37,79,163,331,673,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,43,89,179,359,719,1439,2879,5779,11579,23159,46327,92657,185323,370661,741337,1482707,2965421,5930887,11861791,23723597,47447201,94894427,189788857,379577741,759155483,1518310967,379,761,1523,3049,6101,12203,24407,48817,97649,195311,390647,781301,1562611,3125257,6250537,12501169,25002389,50004791,100009607,200019221,400038451,800076929,1600153859,13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683,539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407,276172823,552345671,1104691373,19,41,83,167,337,677,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269,234539,469099,938207,1876417,3752839,7505681,15011389,30022781,60045577,120091177,240182359,480364727,960729461,1921458943];function nextPrime(t){let e=binarySearch(primeNumbers,t,ascending);return e<0&&(e=~e),primeNumbers[e]}primeNumbers.sort(ascending);const FREE=0,FULL=1,REMOVED=2,defaultInitialCapacity=150,defaultMinLoadFactor=1/6,defaultMaxLoadFactor=2/3;class HashTable{constructor(t={}){if(t instanceof HashTable)return this.table=t.table.slice(),this.values=t.values.slice(),this.state=t.state.slice(),this.minLoadFactor=t.minLoadFactor,this.maxLoadFactor=t.maxLoadFactor,this.distinct=t.distinct,this.freeEntries=t.freeEntries,this.lowWaterMark=t.lowWaterMark,void(this.highWaterMark=t.maxLoadFactor);const e=void 0===t.initialCapacity?defaultInitialCapacity:t.initialCapacity;if(e<0)throw new RangeError("initial capacity must not be less than zero: "+e);const r=void 0===t.minLoadFactor?defaultMinLoadFactor:t.minLoadFactor,n=void 0===t.maxLoadFactor?defaultMaxLoadFactor:t.maxLoadFactor;if(r<0||r>=1)throw new RangeError("invalid minLoadFactor: "+r);if(n<=0||n>=1)throw new RangeError("invalid maxLoadFactor: "+n);if(r>=n)throw new RangeError(`minLoadFactor (${r}) must be smaller than maxLoadFactor (${n})`);let i=e;i=i/n|0,i=nextPrime(i),0===i&&(i=1),this.table=newArray$1(i),this.values=newArray$1(i),this.state=newArray$1(i),this.minLoadFactor=r,this.maxLoadFactor=i===largestPrime?1:n,this.distinct=0,this.freeEntries=i,this.lowWaterMark=0,this.highWaterMark=chooseHighWaterMark(i,this.maxLoadFactor)}clone(){return new HashTable(this)}get size(){return this.distinct}get(t){const e=this.indexOfKey(t);return e<0?0:this.values[e]}set(t,e){let r=this.indexOfInsertion(t);if(r<0)return r=-r-1,this.values[r]=e,!1;if(this.distinct>this.highWaterMark){const r=chooseGrowCapacity(this.distinct+1,this.minLoadFactor,this.maxLoadFactor);return this.rehash(r),this.set(t,e)}if(this.table[r]=t,this.values[r]=e,this.state[r]===FREE&&this.freeEntries--,this.state[r]=FULL,this.distinct++,this.freeEntries<1){const t=chooseGrowCapacity(this.distinct+1,this.minLoadFactor,this.maxLoadFactor);this.rehash(t)}return!0}remove(t,e){const r=this.indexOfKey(t);return!(r<0)&&(this.state[r]=REMOVED,this.distinct--,e||this.maybeShrinkCapacity(),!0)}delete(t,e){const r=this.indexOfKey(t);return!(r<0)&&(this.state[r]=FREE,this.distinct--,e||this.maybeShrinkCapacity(),!0)}maybeShrinkCapacity(){if(this.distinct<this.lowWaterMark){const t=chooseShrinkCapacity(this.distinct,this.minLoadFactor,this.maxLoadFactor);this.rehash(t)}}containsKey(t){return this.indexOfKey(t)>=0}indexOfKey(t){const e=this.table,r=this.state,n=this.table.length,i=2147483647&t;let o=i%n,s=i%(n-2);for(0===s&&(s=1);r[o]!==FREE&&(r[o]===REMOVED||e[o]!==t);)o-=s,o<0&&(o+=n);return r[o]===FREE?-1:o}containsValue(t){return this.indexOfValue(t)>=0}indexOfValue(t){const e=this.values,r=this.state;for(var n=0;n<r.length;n++)if(r[n]===FULL&&e[n]===t)return n;return-1}indexOfInsertion(t){const e=this.table,r=this.state,n=e.length,i=2147483647&t;let o=i%n,s=i%(n-2);for(0===s&&(s=1);r[o]===FULL&&e[o]!==t;)o-=s,o<0&&(o+=n);if(r[o]===REMOVED){const i=o;for(;r[o]!==FREE&&(r[o]===REMOVED||e[o]!==t);)o-=s,o<0&&(o+=n);r[o]===FREE&&(o=i)}return r[o]===FULL?-o-1:o}ensureCapacity(t){if(this.table.length<t){const e=nextPrime(t);this.rehash(e)}}rehash(t){const e=this.table.length;if(t<=this.distinct)throw new Error("Unexpected");const r=this.table,n=this.values,i=this.state,o=newArray$1(t),s=newArray$1(t),a=newArray$1(t);this.lowWaterMark=chooseLowWaterMark(t,this.minLoadFactor),this.highWaterMark=chooseHighWaterMark(t,this.maxLoadFactor),this.table=o,this.values=s,this.state=a,this.freeEntries=t-this.distinct;for(var l=0;l<e;l++)if(i[l]===FULL){var h=r[l],u=this.indexOfInsertion(h);o[u]=h,s[u]=n[l],a[u]=FULL}}forEachKey(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.table[e]))return!1;return!0}forEachValue(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.values[e]))return!1;return!0}forEachPair(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.table[e],this.values[e]))return!1;return!0}}function chooseLowWaterMark(t,e){return t*e|0}function chooseHighWaterMark(t,e){return Math.min(t-2,t*e|0)}function chooseGrowCapacity(t,e,r){return nextPrime(Math.max(t+1,4*t/(3*e+r)|0))}function chooseShrinkCapacity(t,e,r){return nextPrime(Math.max(t+1,4*t/(e+3*r)|0))}function newArray$1(t){return Array(t).fill(0)}class SparseMatrix{constructor(t,e,r={}){if(t instanceof SparseMatrix){const e=t;this._init(e.rows,e.columns,e.elements.clone(),e.threshold)}else if(Array.isArray(t)){const s=t;t=s.length,r=e||{},e=s[0].length,this._init(t,e,new HashTable(r),r.threshold);for(var n=0;n<t;n++)for(var i=0;i<e;i++){var o=s[n][i];this.threshold&&Math.abs(o)<this.threshold&&(o=0),0!==o&&this.elements.set(n*e+i,s[n][i])}}else this._init(t,e,new HashTable(r),r.threshold)}_init(t,e,r,n){this.rows=t,this.columns=e,this.elements=r,this.threshold=n||0}static eye(t=1,e=t){const r=Math.min(t,e),n=new SparseMatrix(t,e,{initialCapacity:r});for(var i=0;i<r;i++)n.set(i,i,1);return n}clone(){return new SparseMatrix(this)}to2DArray(){const t=new Array(this.rows);for(var e=0;e<this.rows;e++){t[e]=new Array(this.columns);for(var r=0;r<this.columns;r++)t[e][r]=this.get(e,r)}return t}isSquare(){return this.rows===this.columns}isSymmetric(){if(!this.isSquare())return!1;var t=!0;return this.forEachNonZero(((e,r,n)=>this.get(r,e)!==n?(t=!1,!1):n)),t}bandWidth(){let t=this.columns,e=-1;return this.forEachNonZero(((r,n,i)=>{let o=r-n;return t=Math.min(t,o),e=Math.max(e,o),i})),e-t}isBanded(t){return this.bandWidth()<=t}get cardinality(){return this.elements.size}get size(){return this.rows*this.columns}get(t,e){return this.elements.get(t*this.columns+e)}set(t,e,r){return this.threshold&&Math.abs(r)<this.threshold&&(r=0),0===r?this.elements.remove(t*this.columns+e):this.elements.set(t*this.columns+e,r),this}mmul(t){this.columns!==t.rows&&console.warn("Number of columns of left matrix are not equal to number of rows of right matrix.");const e=this.rows,r=t.columns,n=new SparseMatrix(e,r);return this.forEachNonZero(((e,r,i)=>(t.forEachNonZero(((t,o,s)=>(r===t&&n.set(e,o,n.get(e,o)+i*s),s))),i))),n}kroneckerProduct(t){const e=this.rows,r=this.columns,n=t.rows,i=t.columns,o=new SparseMatrix(e*n,r*i,{initialCapacity:this.cardinality*t.cardinality});return this.forEachNonZero(((e,r,s)=>(t.forEachNonZero(((t,a,l)=>(o.set(n*e+t,i*r+a,s*l),l))),s))),o}forEachNonZero(t){return this.elements.forEachPair(((e,r)=>{const n=e/this.columns|0,i=e%this.columns;let o=t(n,i,r);return!1!==o&&(this.threshold&&Math.abs(o)<this.threshold&&(o=0),o!==r&&(0===o?this.elements.remove(e,!0):this.elements.set(e,o)),!0)})),this.elements.maybeShrinkCapacity(),this}getNonZeros(){const t=this.cardinality,e=new Array(t),r=new Array(t),n=new Array(t);var i=0;return this.forEachNonZero(((t,o,s)=>(e[i]=t,r[i]=o,n[i]=s,i++,s))),{rows:e,columns:r,values:n}}setThreshold(t){return 0!==t&&t!==this.threshold&&(this.threshold=t,this.forEachNonZero(((t,e,r)=>r))),this}transpose(){let t=new SparseMatrix(this.columns,this.rows,{initialCapacity:this.cardinality});return this.forEachNonZero(((e,r,n)=>(t.set(r,e,n),n))),t}}SparseMatrix.prototype.klass="Matrix",SparseMatrix.identity=SparseMatrix.eye,SparseMatrix.prototype.tensorProduct=SparseMatrix.prototype.kroneckerProduct;var inplaceOperator="\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n",inplaceOperatorScalar="\n(function %name%S(value) {\n    this.forEachNonZero((i, j, v) => v %op% value);\n    return this;\n})\n",inplaceOperatorMatrix="\n(function %name%M(matrix) {\n    matrix.forEachNonZero((i, j, v) => {\n        this.set(i, j, this.get(i, j) %op% v);\n        return v;\n    });\n    return this;\n})\n",staticOperator="\n(function %name%(matrix, value) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%(value);\n})\n",inplaceMethod="\n(function %name%() {\n    this.forEachNonZero((i, j, v) => %method%(v));\n    return this;\n})\n",staticMethod="\n(function %name%(matrix) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%();\n})\n";const operators=[["+","add"],["-","sub","subtract"],["*","mul","multiply"],["/","div","divide"],["%","mod","modulus"],["&","and"],["|","or"],["^","xor"],["<<","leftShift"],[">>","signPropagatingRightShift"],[">>>","rightShift","zeroFillRightShift"]];for(const operator of operators)for(let i=1;i<operator.length;i++)SparseMatrix.prototype[operator[i]]=eval(fillTemplateFunction(inplaceOperator,{name:operator[i],op:operator[0]})),SparseMatrix.prototype[operator[i]+"S"]=eval(fillTemplateFunction(inplaceOperatorScalar,{name:operator[i]+"S",op:operator[0]})),SparseMatrix.prototype[operator[i]+"M"]=eval(fillTemplateFunction(inplaceOperatorMatrix,{name:operator[i]+"M",op:operator[0]})),SparseMatrix[operator[i]]=eval(fillTemplateFunction(staticOperator,{name:operator[i]}));var methods=[["~","not"]];["abs","acos","acosh","asin","asinh","atan","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","log","log1p","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc"].forEach((function(t){methods.push(["Math."+t,t])}));for(const method of methods)for(let i=1;i<method.length;i++)SparseMatrix.prototype[method[i]]=eval(fillTemplateFunction(inplaceMethod,{name:method[i],method:method[0]})),SparseMatrix[method[i]]=eval(fillTemplateFunction(staticMethod,{name:method[i]}));function fillTemplateFunction(t,e){for(const r in e)t=t.replace(new RegExp(`%${r}%`,"g"),e[r]);return t}function additiveSymmetric(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])*(t[r]+e[r])/(t[r]*e[r]);return 2*i}function avg(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)i+=o=Math.abs(t[s]-e[s]),n<o&&(n=o);return(n+i)/2}function bhattacharyya(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return-Math.log(n)}function canberra(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.abs(t[i]-e[i])/(t[i]+e[i]);return n}function chebyshev(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n<(i=Math.abs(t[o]-e[o]))&&(n=i);return n}function clark(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=Math.sqrt((t[r]-e[r])*(t[r]-e[r])/((t[r]+e[r])*(t[r]+e[r])));return 2*i}function czekanowskiSimilarity(t,e){for(var r=0,n=0,i=0;i<t.length;i++)r+=Math.min(t[i],e[i]),n+=t[i]+e[i];return 2*r/n}function czekanowskiDistance(t,e){return 1-czekanowskiSimilarity(t,e)}function dice(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*t[s],i+=e[s]*e[s],o+=(t[s]-e[s])*(t[s]-e[s]);return o/(n+i)}function divergence(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/((t[r]+e[r])*(t[r]+e[r]));return 2*i}function fidelity(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return n}function gower(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.abs(t[i]-e[i]);return n/r}function harmonicMean(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*e[i]/(t[i]+e[i]);return 2*n}function hellinger(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return 2*Math.sqrt(1-n)}function innerProduct(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*e[i];return n}function intersection(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.min(t[i],e[i]);return 1-n}function jaccard(t,e){for(var r=t.length,n=0,i=0,o=0,s=0,a=0;a<r;a++)n+=t[a]*e[a],i+=t[a]*t[a],o+=e[a]*e[a],s+=(t[a]-e[a])*(t[a]-e[a]);return s/(i+o-n)}function jeffreys(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]-e[i])*Math.log(t[i]/e[i]);return n}function jensenDifference(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]*Math.log(t[i])+e[i]*Math.log(e[i]))/2-(t[i]+e[i])/2*Math.log((t[i]+e[i])/2);return n}function jensenShannon(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=t[o]*Math.log(2*t[o]/(t[o]+e[o])),i+=e[o]*Math.log(2*e[o]/(t[o]+e[o]));return(n+i)/2}function kdivergence(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(2*t[i]/(t[i]+e[i]));return n}function kulczynski(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=Math.min(t[o],e[o]);return n/i}function kullbackLeibler(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(t[i]/e[i]);return n}function kumarHassebrook(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*e[s],i+=t[s]*t[s],o+=e[s]*e[s];return n/(i+o-n)}function kumarJohnson(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.pow(t[i]*t[i]-e[i]*e[i],2)/(2*Math.pow(t[i]*e[i],1.5));return n}function lorentzian(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.log(Math.abs(t[i]-e[i])+1);return n}function manhattan(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=Math.abs(t[r]-e[r]);return i}function matusita(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=Math.sqrt(t[i]*e[i]);return Math.sqrt(2-2*n)}function minkowski(t,e,r){for(var n=0,i=t.length,o=0;n<i;n++)o+=Math.pow(Math.abs(t[n]-e[n]),r);return Math.pow(o,1/r)}function motyka(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.min(t[o],e[o]),i+=t[o]+e[o];return 1-n/i}function neyman(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/t[r];return i}function pearson(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/e[r];return i}function probabilisticSymmetric(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/(t[r]+e[r]);return 2*i}function ruzicka(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.min(t[o],e[o]),i+=Math.max(t[o],e[o]);return n/i}function soergel(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=Math.max(t[o],e[o]);return n/i}function sorensen(t,e){for(var r=t.length,n=0,i=0,o=0;o<r;o++)n+=Math.abs(t[o]-e[o]),i+=t[o]+e[o];return n/i}function squared(t,e){for(var r=0,n=t.length,i=0;r<n;r++)i+=(t[r]-e[r])*(t[r]-e[r])/(t[r]+e[r]);return i}function squaredChord(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(Math.sqrt(t[i])-Math.sqrt(e[i]))*(Math.sqrt(t[i])-Math.sqrt(e[i]));return n}function taneja(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=(t[i]+e[i])/2*Math.log((t[i]+e[i])/(2*Math.sqrt(t[i]*e[i])));return n}function tanimoto(t,e,r){if(r){for(var n=0,i=0,o=0;o<t.length;o++)n+=t[o]&&e[o],i+=t[o]||e[o];return 0===i?1:n/i}for(var s=t.length,a=0,l=0,h=0,u=0;u<s;u++)a+=t[u],l+=e[u],h+=Math.min(t[u],e[u]);return 1-(a+l-2*h)/(a+l-h)}function tanimoto$1(t,e,r){if(r)return 1-tanimoto(t,e,r);for(var n=t.length,i=0,o=0,s=0,a=0;a<n;a++)i+=t[a],o+=e[a],s+=Math.min(t[a],e[a]);return(i+o-2*s)/(i+o-s)}function topsoe(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=t[i]*Math.log(2*t[i]/(t[i]+e[i]))+e[i]*Math.log(2*e[i]/(t[i]+e[i]));return n}function waveHedges(t,e){for(var r=t.length,n=0,i=0;i<r;i++)n+=1-Math.min(t[i],e[i])/Math.max(t[i],e[i]);return n}var distances=Object.freeze({__proto__:null,euclidean:euclidean,squaredEuclidean:squaredEuclidean,additiveSymmetric:additiveSymmetric,avg:avg,bhattacharyya:bhattacharyya,canberra:canberra,chebyshev:chebyshev,clark:clark,czekanowski:czekanowskiDistance,dice:dice,divergence:divergence,fidelity:fidelity,gower:gower,harmonicMean:harmonicMean,hellinger:hellinger,innerProduct:innerProduct,intersection:intersection,jaccard:jaccard,jeffreys:jeffreys,jensenDifference:jensenDifference,jensenShannon:jensenShannon,kdivergence:kdivergence,kulczynski:kulczynski,kullbackLeibler:kullbackLeibler,kumarHassebrook:kumarHassebrook,kumarJohnson:kumarJohnson,lorentzian:lorentzian,manhattan:manhattan,matusita:matusita,minkowski:minkowski,motyka:motyka,neyman:neyman,pearson:pearson,probabilisticSymmetric:probabilisticSymmetric,ruzicka:ruzicka,soergel:soergel,sorensen:sorensen,squared:squared,squaredChord:squaredChord,taneja:taneja,tanimoto:tanimoto$1,topsoe:topsoe,waveHedges:waveHedges});function createTree(t,e={}){var r=t[0];const{minWindow:n=.16,threshold:i=.01,from:o=r[0],to:s=r[r.length-1]}=e;return mainCreateTree(t[0],t[1],o,s,n,i)}function mainCreateTree(t,e,r,n,i,o){if(n-r<i)return null;var s=binarySearch(t,r,ascending);s<0&&(s=~s);for(var a=0,l=0,h=s;h<t.length&&!(t[h]>=n);h++)a+=e[h],l+=t[h]*e[h];return a<o||(l/=a)-r<1e-6||n-l<1e-6?null:l-r<i/4?mainCreateTree(t,e,l,n,i,o):n-l<i/4?mainCreateTree(t,e,r,l,i,o):new Tree(a,l,mainCreateTree(t,e,r,l,i,o),mainCreateTree(t,e,l,n,i,o))}class Tree{constructor(t,e,r,n){this.sum=t,this.center=e,this.left=r,this.right=n}}function getSimilarity(t,e,r={}){const{alpha:n=.1,beta:i=.33,gamma:o=.001}=r;return null===t||null===e?0:(Array.isArray(t)&&(t=createTree(t)),Array.isArray(e)&&(e=createTree(e)),i*(n*Math.min(t.sum,e.sum)/Math.max(t.sum,e.sum)+(1-n)*Math.exp(-o*Math.abs(t.center-e.center)))+(1-i)*(getSimilarity(t.left,e.left,r)+getSimilarity(t.right,e.right,r))/2)}function treeSimilarity(t,e,r={}){return getSimilarity(t,e,r)}function getFunction(t={}){return(e,r)=>getSimilarity(e,r,t)}var index$5=Object.freeze({__proto__:null,treeSimilarity:treeSimilarity,getFunction:getFunction,createTree:createTree});function cosine(t,e){for(var r=t.length,n=0,i=0,o=0,s=0;s<r;s++)n+=t[s]*e[s],i+=t[s]*t[s],o+=e[s]*e[s];return n/(Math.sqrt(i)*Math.sqrt(o))}function dice$1(t,e){return 1-dice(t,e)}function intersection$1(t,e){return 1-intersection(t,e)}function jaccard$1(t,e){return 1-jaccard(t,e)}function kulczynski$1(t,e){return 1/kulczynski(t,e)}function motyka$1(t,e){return 1-motyka(t,e)}function pearson$1(t,e){for(var r=mean(t),n=mean(e),i=new Array(t.length),o=new Array(e.length),s=0;s<i.length;s++)i[s]=t[s]-r,o[s]=e[s]-n;return cosine(i,o)}function squaredChord$1(t,e){return 1-squaredChord(t,e)}var similarities=Object.freeze({__proto__:null,tree:index$5,cosine:cosine,czekanowski:czekanowskiSimilarity,dice:dice$1,intersection:intersection$1,jaccard:jaccard$1,kulczynski:kulczynski$1,motyka:motyka$1,pearson:pearson$1,squaredChord:squaredChord$1,tanimoto:tanimoto});function zeroInsteadOfNegative(t){let e=t.rows,r=t.columns,n=new Matrix(t);for(let t=0;t<e;t++)for(let e=0;e<r;e++)n.get(t,e)<0&&n.set(t,e,0);return n}function checkMatrixS(t,e){let{A:r,S:n}=t,i=[],o=n.sum("row");for(let t=0;t<o.length;t++)if(0!==o[t]){for(let e=0;e<n.columns;e++)if(isNaN(n.get(t,e))){i.push(t);break}}else i.push(t);if(i.length>0){let t=fastExtractNMF(e.clone().subM(r.mmul(n)),i.length);for(let e=0;e<i.length;e++){for(let r=0;r<n.columns;r++)n.set(i[e],r,t.S.get(e,r));for(let n=0;n<r.rows;n++)r.set(n,i[e],t.A.get(n,e))}}return Object.assign({},t,{A:r,S:n})}function fastExtractNMF(t,e){if(e<=0)return{A:[],S:[]};const{columns:r,rows:n}=t;let i=Matrix.zeros(n,e),o=Matrix.zeros(e,r);for(let s=0;s<e;s++){if(0===(t=zeroInsteadOfNegative(t)).sum())continue;let e=Matrix.pow(t,2).sum("column"),a=0;for(let t=1;t<e.length;t++)e[a]<e[t]&&(a=t);if(e[a]>0){let l=Math.sqrt(e[a]);for(let e=0;e<n;e++){let r=t.get(e,a)/l;i.set(e,s,r)}let h=i.getColumnVector(s).transpose().mmul(t);for(let t=0;t<r;t++)o.set(s,t,Math.max(h.get(0,t),0));let u=i.getColumnVector(s).mmul(o.getRowVector(s));t=t.sub(u)}}return{A:i,S:o}}function normBy(t,e="column"){let r=Matrix.mul(t,t).sum(e),n=r.length;for(let t=0;t<n;t++)r[t]=Math.sqrt(r[t]);return"row"===e?Matrix.from1DArray(n,1,r):Matrix.from1DArray(1,n,r)}function normProj(t,e){let r,n=t.rows,i=t.columns;if(e.rows===n){r=normBy(t,"row");for(let o=0;o<n;o++)if(!(r.get(o,0)<=0))for(let n=0;n<i;n++){let i=t.get(o,n)*Math.min(r.get(o,0),e.get(o,0)/r.get(o,0));t.set(o,n,i)}}else{r=normBy(t,"column");for(let o=0;o<i;o++)if(!(r.get(0,o)<=0))for(let i=0;i<n;i++){let n=t.get(i,o)*Math.min(r.get(0,o),e.get(0,o)/r.get(0,o));t.set(i,o,n)}}return t}function updateMatrixA(t,e,r,n){let i,{maxFBIteration:o,toleranceFB:s,normConstrained:a=!1,lambda:l}=n,h=e.transpose(),u=e.mmul(h),c=r.mmul(h),m=new EigenvalueDecomposition(u,{assumeSymmetric:!0}),f=Math.max(...m.realEigenvalues),g=t,p=g.clone(),d=1;if(a){let e=normBy(t,"column");i=(t,r)=>normProj(zeroInsteadOfNegative(t.subS(r)),e)}else i=(t,e)=>zeroInsteadOfNegative(t.subS(e));for(let t=0;t<o;t++){let t=(1+Math.sqrt(1+4*d*d))/2,e=(d-1)/t;d=t;let r=Matrix.mul(g,e+1).sub(Matrix.mul(p,e));if(p=g.clone(),g=i(r.sub((w=r,w.mmul(u).sub(c)).divS(f)),l/f),Matrix.sub(p,g).norm()/g.norm()<s)break}var w;return g}function getMax(t=[]){let e=Number.MIN_SAFE_INTEGER;for(let r=0;r<t.length;r++)e<t[r]&&(e=t[r]);return e}function updateMatrixS(t,e,r,n,i){let{maxFBIteration:o,toleranceFB:s}=i,a=t.transpose(),l=a.mmul(t),h=a.mmul(r),u=getMax(new EigenvalueDecomposition(l,{assumeSymmetric:!0}).realEigenvalues),c=1,m=e.clone(),f=m.clone(),g=(t,e)=>zeroInsteadOfNegative(t.subS(e));for(let t=0;t<o;t++){let t=(1+Math.sqrt(1+4*c*c))/2,e=(c-1)/t;c=t;let r=Matrix.mul(m,1+e).sub(Matrix.mul(f,e));if(f=m.clone(),m=g(r.sub((p=r,l.mmul(p).sub(h)).divS(u)),n/u),Matrix.sub(f,m).norm()/m.norm()<s)break}var p;return m}function initialize(t,e={}){const{rank:r,randGenerator:n,maxInitFBIteration:i,toleranceFBInit:o,maxFBIteration:s,toleranceFB:a,normConstrained:l}=e;let h={},u=t.rows;h.A=Matrix.rand(u,r,{random:n});for(let e=0;e<i;e++){let e=h.A.sum("column");for(let t=0;t<e.length;t++)for(;0===e[t];){e[t]=0;for(let r=0;r<u;r++)h.A.set(r,t,n()),e[t]+=h.A.get(r,t)}h.S=zeroInsteadOfNegative(solve(h.A,t));let r=h.S.sum("row"),i=[],l=[];for(let t=0;t<r.length;t++)r[t]>0&&(i.push(t),l.push(h.S.getRow(t)));l=Matrix.checkMatrix(l);let c=zeroInsteadOfNegative(solve(l.transpose(),t.transpose()));for(let t=0;t<i.length;t++){let e=c.getRow(t);for(let r=0;r<u;r++)h.A.set(r,i[t],e[r])}let m=h.S.clone();if(h.S=updateMatrixS(h.A,h.S,t,0,{maxFBIteration:s,toleranceFB:a}),h=checkMatrixS(h,t),h.A=updateMatrixA(h.A,h.S,t,0),Matrix.sub(m,h.S).norm()/h.S.norm()<o)break}return h}function normalize(t,e){const{normOnA:r}=e;let n,i,o=normBy(t.S.transpose(),"column"),s=normBy(t.A,"column"),a=Matrix.mul(o,s);r?(n=(e,r)=>t.S.get(e,r)*a.get(0,e)/o.get(0,e),i=(e,r)=>t.A.get(r,e)/s.get(0,e)):(n=(e,r)=>t.S.get(e,r)/o.get(0,e),i=(e,r)=>t.A.get(r,e)*a.get(0,e)/s.get(0,e));const l=t.S.columns,h=t.A.rows;for(let e=0;e<a.columns;e++){let r,o;a.get(0,e)>0?(r=n,o=i):(o=()=>0,r=()=>0);for(let n=0;n<l;n++)t.S.set(e,n,r(e,n));for(let r=0;r<h;r++)t.A.set(r,e,o(e,r))}return t}function getMedians(t,e){let r=[],n=t.rows,i=t.columns;switch(e){case"column":for(let e=0;e<i;e++)r.push(medianQuickselect_min(t.getColumn(e)));r=Matrix.from1DArray(1,i,r);break;default:for(let e=0;e<n;e++)r.push(medianQuickselect_min(t.getRow(e)));r=Matrix.from1DArray(n,1,r)}return r}function dimMADstd(t,e){let r=getMedians(t,e),n=t.clone();return n="column"===e?n.subRowVector(r.to1DArray()):n.subColumnVector(r.to1DArray()),Matrix.mul(getMedians(n.abs(),e),1.4826)}function updateLambda(t,e,r={}){let n,{refinementBeginning:i,tauMAD:o}=r,{iteration:s,lambda:a,A:l,S:h}=t;if(i<=s)return a;if(void 0!==r.lambdaInf)n=r.lambdaInf/r.tauMAD;else if(void 0!==r.addStd)n=r.addStd;else{let t=Matrix.sub(e,l.mmul(h)).to1DArray();n=dimMADstd(Matrix.from1DArray(1,t.length,t),"row").get(0,0)}return Math.max(o*n,a-1/(i-s))}function nGMCA(t,e,r={}){const{maximumIteration:n=500,maxFBIteration:i=80,maxInitFBIteration:o=50,toleranceFBInit:s=0,toleranceFB:a=1e-5,phaseRatio:l=.8,randGenerator:h=Math.random,tauMAD:u=1,useTranspose:c=!1}=r;let{normConstrained:m=!1}=r;t=Matrix.checkMatrix(t),c&&(t=t.transpose());let f=Math.floor(l*n),g=initialize(t,{rank:e,randGenerator:h,maxInitFBIteration:o,toleranceFBInit:s,maxFBIteration:i,toleranceFB:a});g=normalize(g,{normOnA:!0}),g.lambda=g.A.transpose().mmul(g.A.mmul(g.S).sub(t)).abs().max();for(let e=0;e<n;e++)g.iteration=e,g.S=updateMatrixS(g.A,g.S,t,g.lambda,r),g=checkMatrixS(g,t),g=normalize(g,{normOnA:!1}),e>f&&(m=!0),g.A=updateMatrixA(g.A,g.S,t,{maxFBIteration:i,toleranceFB:a,normConstrained:m,lambda:0}),g=normalize(g,{normOnA:!0}),g.lambda=updateLambda(g,t,{refinementBeginning:f,tauMAD:u});if(c){let t=g.A.transpose();g.A=g.S.transpose(),g.S=t}return g}var acc=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=(t.tn[n]+t.tp[n])/(e-1);return r},err=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.fp[n]/(e-1);return r},fpr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]/t.nNeg;return r},tpr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.tp[n]/t.nPos;return r},fnr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]/t.nPos;return r},tnr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.tn[n]/t.nNeg;return r},ppv=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]+t.tp[n]!==0?t.tp[n]/(t.fp[n]+t.tp[n]):0;return r},npv=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.tn[n]!==0?t.tn[n]/(t.fn[n]+t.tn[n]):0;return r},pcfall=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fp[n]+t.tp[n]!==0?1-t.tp[n]/(t.fp[n]+t.tp[n]):1;return r},pcmiss=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.fn[n]+t.tn[n]!==0?1-t.tn[n]/(t.fn[n]+t.tn[n]):1;return r},lift=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=0!==t.nPosPred[n]?t.tp[n]/t.nPos/(t.nPosPred[n]/t.nSamples):0;return r},rpp=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.nPosPred[n]/t.nSamples;return r},rnp=t=>{const e=t.cutoffs.length,r=new Array(e);for(var n=0;n<e;n++)r[n]=t.nNegPred[n]/t.nSamples;return r},threshold=t=>{const e=t.cutoffs.slice();return e[0]=e[1],e},measures={acc:acc,err:err,fpr:fpr,tpr:tpr,fnr:fnr,tnr:tnr,ppv:ppv,npv:npv,pcfall:pcfall,pcmiss:pcmiss,lift:lift,rpp:rpp,rnp:rnp,threshold:threshold};class Performance{constructor(t,e,r){if(r=r||{},t.length!==e.length||t[0].length!==e[0].length)throw new Error("dimensions of prediction and target do not match");const n=t.length,i=t[0].length,o=!r.max,s=[];if(r.all)for(var a=0;a<n;a++)for(var l=0;l<i;l++)s.push({pred:t[a][l],targ:e[a][l]});else{if(n<3||n!==i)throw new Error('When "all" option is false, the prediction matrix must be square and have at least 3 columns');for(a=0;a<n-1;a++)for(l=a+1;l<i;l++)s.push({pred:t[a][l],targ:e[a][l]})}o?s.sort(((t,e)=>t.pred-e.pred)):s.sort(((t,e)=>e.pred-t.pred));const h=this.cutoffs=[o?Number.MIN_VALUE:Number.MAX_VALUE],u=this.fp=[0],c=this.tp=[0];var m=0,f=0,g=s[0].pred,p=0,d=0;for(a=0;a<s.length;a++)s[a].pred!==g&&(h.push(g),u.push(d),c.push(p),g=s[a].pred),s[a].targ?(m++,p++):(f++,d++);h.push(g),u.push(d),c.push(p);const w=h.length,x=this.fn=new Array(w),y=this.tn=new Array(w),M=this.nPosPred=new Array(w),v=this.nNegPred=new Array(w);for(a=0;a<w;a++)x[a]=m-c[a],y[a]=f-u[a],M[a]=c[a]+u[a],v[a]=y[a]+x[a];this.nPos=m,this.nNeg=f,this.nSamples=m+f}getMeasure(t){if("string"!=typeof t)throw new Error("No measure specified");if(!measures[t])throw new Error(`The specified measure (${t}) does not exist`);return measures[t](this)}getAURC(){const t=this.cutoffs.length,e=new Array(t),r=new Array(t);for(var n=0;n<t;n++)e[n]=this.fp[n]/this.nNeg,r[n]=this.tp[n]/this.nPos;var i=0;for(n=1;n<t;n++)i+=.5*(e[n]-e[n-1])*(r[n]+r[n-1]);return i}getAUDC(){const t=this.cutoffs.length,e=new Array(t),r=new Array(t);for(var n=0;n<t;n++)e[n]=this.fn[n]/this.nPos,r[n]=this.fp[n]/this.nNeg;var i=0;for(n=1;n<t;n++)i+=.5*(e[n]+e[n-1])*(r[n]-r[n-1]);return i}getDistribution(t){t=t||{};for(var e=this.cutoffs.length,r=t.xMin||Math.floor(100*this.cutoffs[e-1])/100,n=t.xMax||Math.ceil(100*this.cutoffs[1])/100,i=t.interval||Math.floor((n-r)/20*1e7-1)/1e7,o=[],s=[],a=[],l=[],h=[],u=this.tp[e-1],c=0,m=this.fp[e-1],f=0,g=r,p=e-1;g<=n;g+=i){for(;this.cutoffs[p]<g;)p--;o.push(g);var d=u-c-this.tp[p],w=m-f-this.fp[p];c+=d,f+=w,s.push(w),a.push(d),l.push(100-(m-this.fp[p])/m*100),h.push(100-(u-this.tp[p])/u*100)}return{xLabels:o,interValues:s,intraValues:a,interCumPercent:l,intraCumPercent:h}}}Performance.names={acc:"Accuracy",err:"Error rate",fpr:"False positive rate",tpr:"True positive rate",fnr:"False negative rate",tnr:"True negative rate",ppv:"Positive predictive value",npv:"Negative predictive value",pcfall:"Prediction-conditioned fallout",pcmiss:"Prediction-conditioned miss",lift:"Lift value",rpp:"Rate of positive predictions",rnp:"Rate of negative predictions",threshold:"Threshold"};var src$1=Performance,defaultOptions$g={size:1,value:0};function arrayCase(t,e){var r=t.length;"number"==typeof e.size&&(e.size=[e.size,e.size]);var n,i,o=r+e.size[0]+e.size[1];if(e.output){if(e.output.length!==o)throw new RangeError("Wrong output size");n=e.output}else n=new Array(o);if("circular"===e.value)for(i=0;i<o;i++)i<e.size[0]?n[i]=t[(r-e.size[0]%r+i)%r]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[(i-e.size[0])%r];else if("replicate"===e.value)for(i=0;i<o;i++)i<e.size[0]?n[i]=t[0]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[r-1];else if("symmetric"===e.value){if(e.size[0]>r||e.size[1]>r)throw new RangeError("expanded value should not be bigger than the data length");for(i=0;i<o;i++)i<e.size[0]?n[i]=t[e.size[0]-1-i]:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=t[2*r+e.size[0]-i-1]}else for(i=0;i<o;i++)i<e.size[0]?n[i]=e.value:i<e.size[0]+r?n[i]=t[i-e.size[0]]:n[i]=e.value;return n}function matrixCase(t,e){throw void 0===e.size[0]&&(e.size=[e.size,e.size,e.size,e.size]),new Error("matrix not supported yet, sorry")}function padArray(t,e){if(e=Object.assign({},defaultOptions$g,e),Array.isArray(t))return Array.isArray(t[0])?matrixCase(t,e):arrayCase(t,e);throw new TypeError("data should be an array")}var src$2=padArray;function factorial(t){let e=1;for(;t>0;)e*=t--;return e}const defaultOptions$h={windowSize:5,derivative:1,polynomial:2,pad:"none",padValue:"replicate"};function savitzkyGolay(t,e,r){if((r=Object.assign({},defaultOptions$h,r)).windowSize%2==0||r.windowSize<5||!Number.isInteger(r.windowSize))throw new RangeError("Invalid window size (should be odd and at least 5 integer number)");if(r.derivative<0||!Number.isInteger(r.derivative))throw new RangeError("Derivative should be a positive integer");if(r.polynomial<1||!Number.isInteger(r.polynomial))throw new RangeError("Polynomial should be a positive integer");let n,i,o=Math.floor(r.windowSize/2);"pre"===r.pad&&(t=src$2(t,{size:o,value:r.padValue}));let s=new Array(t.length-2*o);if(5!==r.windowSize||2!==r.polynomial||1!==r.derivative&&2!==r.derivative){let t=Matrix.ones(r.windowSize,r.polynomial+1),e=-(r.windowSize-1)/2;for(let r=0;r<t.rows;r++)for(let n=0;n<t.columns;n++)e+1===0&&0===n||t.set(r,n,Math.pow(e+r,n));let o=new MatrixTransposeView(t);n=inverse(o.mmul(t)).mmul(o),n=n.getRow(r.derivative),i=1/factorial(r.derivative)}else 1===r.derivative?(n=[-2,-1,0,1,2],i=10):(n=[2,-1,-2,-1,2],i=7);let a=i*Math.pow(e,r.derivative);for(let e=o;e<t.length-o;e++){let r=0;for(let i=0;i<n.length;i++)r+=n[i]*t[i+e-o]/a;s[e-o]=r}return"post"===r.pad&&(s=src$2(s,{size:o,value:r.padValue})),s}for(var ans=new Array(256),i=0;i<256;i++){for(var num=i,c=0;num;)num&=num-1,c++;ans[i]=c}var creator=ans;function count(t){for(var e=0,r=0;r<t.length;r++)e+=creator[255&t[r]]+creator[t[r]>>8&255]+creator[t[r]>>16&255]+creator[t[r]>>24&255];return e}function and(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]&e[n];return r}function or(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]|e[n];return r}function xor(t,e){for(var r=new Array(t.length),n=0;n<t.length;n++)r[n]=t[n]^e[n];return r}function not(t){for(var e=new Array(t.length),r=0;r<e.length;r++)e[r]=~t[r];return e}function getBit(t,e){var r=1<<31-e%32;return Boolean(t[e>>5]&r)}function setBit(t,e,r){var n=e>>5,i=1<<31-e%32;return t[n]=r?i|t[n]:~i&t[n],t}function toBinaryString(t){for(var e="",r=0;r<t.length;r++){var n=(t[r]>>>0).toString(2);e+="00000000000000000000000000000000".substr(n.length)+n}return e}function parseBinaryString(t){for(var e=t.length/32,r=new Array(e),n=0;n<e;n++)r[n]=0|parseInt(t.substr(32*n,32),2);return r}function toHexString(t){for(var e="",r=0;r<t.length;r++){var n=(t[r]>>>0).toString(16);e+="00000000".substr(n.length)+n}return e}function parseHexString(t){for(var e=t.length/8,r=new Array(e),n=0;n<e;n++)r[n]=0|parseInt(t.substr(8*n,8),16);return r}function toDebug(t){for(var e=toBinaryString(t),r="",n=0;n<t.length;n++){r+="0000".substr((32*n).toString(16).length)+(32*n).toString(16)+":";for(var i=0;i<32;i+=4)r+=" "+e.substr(32*n+i,4);n<t.length-1&&(r+="\n")}return r}var src$3={count:count,and:and,or:or,xor:xor,not:not,getBit:getBit,setBit:setBit,toBinaryString:toBinaryString,parseBinaryString:parseBinaryString,toHexString:toHexString,parseHexString:parseHexString,toDebug:toDebug};function SavitzkyGolay(t,e,r={}){let{windowSize:n=9,derivative:i=0,polynomial:o=3}=r;if(n%2==0||n<5||!Number.isInteger(n))throw new RangeError("Invalid window size (should be odd and at least 5 integer number)");if(n>t.length)throw new RangeError(`Window size is higher than the data length ${n}>${t.length}`);if(i<0||!Number.isInteger(i))throw new RangeError("Derivative should be a positive integer");if(o<1||!Number.isInteger(o))throw new RangeError("Polynomial should be a positive integer");o>=6&&console.warn("You should not use polynomial grade higher than 5 if you are not sure that your data arises from such a model. Possible polynomial oscillation problems");let s=Math.floor(n/2),a=t.length,l=new Array(a),h=fullWeights(n,o,i),u=0,c=!0;Array.isArray(e)?c=!1:u=Math.pow(e,i);for(let r=0;r<s;r++){let o=h[s-r-1],m=h[s+r+1],f=0,g=0;for(let e=0;e<n;e++)f+=o[e]*t[e],g+=m[e]*t[a-n+e];c?(l[s-r-1]=f/u,l[a-s+r]=g/u):(u=getHs(e,s-r-1,s,i),l[s-r-1]=f/u,u=getHs(e,a-s+r,s,i),l[a-s+r]=g/u)}let m=h[s];for(let r=n;r<=a;r++){let o=0;for(let e=0;e<n;e++)o+=m[e]*t[e+r-n];c||(u=getHs(e,r-s-1,s,i)),l[r-s-1]=o/u}return l}function getHs(t,e,r,n){let i=0,o=0;for(let n=e-r;n<e+r;n++)n>=0&&n<t.length-1&&(i+=t[n+1]-t[n],o++);return Math.pow(i/o,n)}function GramPoly(t,e,r,n){let i=0;return i=r>0?(4*r-2)/(r*(2*e-r+1))*(t*GramPoly(t,e,r-1,n)+n*GramPoly(t,e,r-1,n-1))-(r-1)*(2*e+r)/(r*(2*e-r+1))*GramPoly(t,e,r-2,n):0===r&&0===n?1:0,i}function GenFact(t,e){let r=1;if(t>=e)for(let n=t-e+1;n<=t;n++)r*=n;return r}function Weight(t,e,r,n,i){let o=0;for(let s=0;s<=n;s++)o+=(2*s+1)*(GenFact(2*r,s)/GenFact(2*r+s+1,s+1))*GramPoly(t,r,s,0)*GramPoly(e,r,s,i);return o}function fullWeights(t,e,r){let n=new Array(t),i=Math.floor(t/2);for(let o=-i;o<=i;o++){n[o+i]=new Array(t);for(let t=-i;t<=i;t++)n[o+i][t+i]=Weight(t,o,i,e,r)}return n}function gsd(t,e,r={}){let{noiseLevel:n,sgOptions:i={windowSize:9,polynomial:3},smoothY:o=!0,heightFactor:s=0,broadRatio:a=0,maxCriteria:l=!0,minMaxRatio:h=25e-5,derivativeThreshold:u=-1,realTopDetection:c=!1}=r;const m=e.slice();let f=isEqualSpaced(t);void 0===n&&(n=f?getNoiseLevel(m):0);const g={m:1,b:n};l||(g.m=-1,g.b*=-1);for(let t=0;t<m.length;t++)m[t]=g.m*m[t]-g.b;for(let t=0;t<m.length;t++)m[t]<0&&(m[t]=0);let p,d,w=m;const{windowSize:x,polynomial:y}=i;f?(o&&(w=SavitzkyGolay(m,t[1]-t[0],{windowSize:x,polynomial:y,derivative:0})),p=SavitzkyGolay(m,t[1]-t[0],{windowSize:x,polynomial:y,derivative:1}),d=SavitzkyGolay(m,t[1]-t[0],{windowSize:x,polynomial:y,derivative:2})):(o&&(w=SavitzkyGolay(m,t,{windowSize:x,polynomial:y,derivative:0})),p=SavitzkyGolay(m,t,{windowSize:x,polynomial:y,derivative:1}),d=SavitzkyGolay(m,t,{windowSize:x,polynomial:y,derivative:2}));const M=t,v=t[1]-t[0];let b=0,S=0;for(let t=0;t<w.length;t++)Math.abs(d[t])>b&&(b=Math.abs(d[t])),Math.abs(w[t])>S&&(S=Math.abs(w[t]));let A=null,E=null,R=new Array(w.length-2),k=new Array(w.length),N=new Array(w.length),C=new Array(w.length-2),T=0,I=0,O=0,L=0;for(let t=1;t<w.length-1;++t)Math.abs(p[t])>u&&((p[t]<p[t-1]&&p[t]<=p[t+1]||p[t]<=p[t-1]&&p[t]<p[t+1])&&(E={x:M[t],index:t},v>0&&null!==A&&(k[I++]=A,N[O++]=E)),(p[t]>=p[t-1]&&p[t]>p[t+1]||p[t]>p[t-1]&&p[t]>=p[t+1])&&(A={x:M[t],index:t},v<0&&null!==E&&(k[I++]=A,N[O++]=E))),d[t]<d[t-1]&&d[t]<d[t+1]&&(R[T++]=t,C[L++]=Math.abs(d[t])<=a*b);R.length=T,k.length=I,N.length=O,C.length=L;let F,P,V,D,z,_=new Array(R.length),$=0,q=-1;for(let t=0;t<R.length;++t){P=M[R[t]],F=-1;let e=q+1;for(D=Number.MAX_VALUE,V=0,z=!0;-1===F&&e<k.length&&z;)V=Math.abs(P-(k[e].x+N[e].x)/2),V<D?D=V:z=!1,V<Math.abs(k[e].x-N[e].x)/2&&(F=e,q=e),++e;if(-1!==F&&Math.abs(w[R[t]])>h*S&&(_[$++]={index:R[t],x:P,y:(w[R[t]]+g.b)/g.m,width:Math.abs(N[F].x-k[F].x),soft:C[t]},_[$-1].left=k[F],_[$-1].right=N[F],s)){let t=w[k[F].index],e=w[N[F].index];_[$-1].height=s*(_[$-1].y-(t+e)/2)}}_.length=$,c&&determineRealTop(_,M,w);for(let t=0;t<_.length;t++)_[t].base=n;return _.sort((function(t,e){return t.x-e.x})),_}const isEqualSpaced=t=>{let e,r=0,n=Number.MAX_SAFE_INTEGER;for(let i=0;i<t.length-1;++i)e=Math.abs(t[i+1]-t[i]),e<n&&(n=e),e>r&&(r=e);return(r-n)/r<.05},getNoiseLevel=t=>{let e=0,r=0,n=t.length;for(let r=0;r<n;++r)e+=t[r];e/=n;let i=new Array(n);for(let r=0;r<n;++r)i[r]=Math.abs(t[r]-e);return i.sort(((t,e)=>t-e)),r=n%2==1?i[(n-1)/2]/.6745:.5*(i[n/2]+i[n/2-1])/.6745,r},determineRealTop=(t,e,r)=>{let n,i,o,s,a;for(let l=0;l<t.length;l++)a=t[l].index,r[a-1]>=r[a-2]&&r[a-1]>=r[a]?a--:r[a+1]>=r[a]&&r[a+1]>=r[a+2]?a++:r[a-2]>=r[a-3]&&r[a-2]>=r[a-1]?a-=2:r[a+2]>=r[a+1]&&r[a+2]>=r[a+3]&&(a+=2),r[a-1]>0&&r[a+1]>0&&r[a]>=r[a-1]&&r[a]>=r[a+1]&&(r[a]!==r[a-1]||r[a]!==r[a+1])&&(n=20*Math.log10(r[a-1]),i=20*Math.log10(r[a]),o=20*Math.log10(r[a+1]),s=.5*(n-o)/(n-2*i+o),t[l].x=e[a]+(e[a]-e[a-1])*s,t[l].y=r[a]-.25*(r[a-1]-r[a+1])*s)};function sumOfGaussians(t){return function(e){let r,n=t.length/3,i=e.length,o=void 0===i?0:new Float64Array(i).fill(0);for(let s=0;s<n;s++)if(r=2*Math.pow(t[s+2*n],2),void 0===i)o+=t[s+n]*Math.exp(-Math.pow(e-t[s],2)/r);else for(let a=0;a<i;a++)o[a]+=t[s+n]*Math.exp(-Math.pow(e[a]-t[s],2)/r);return o}}function optimizeGaussianSum(t,e,r={}){let n=t[0],i=t[1],o=Math.max(...i);i.forEach(((t,e,r)=>r[e]/=o));let s=e.length,a=new Float64Array(3*s),l=new Float64Array(3*s),h=new Float64Array(3*s),u=Math.abs(n[0]-n[1]);for(let t=0;t<s;t++)a[t]=e[t].x,a[t+s]=e[t].y/o,a[t+2*s]=e[t].width,l[t]=e[t].x-u,l[t+s]=0,l[t+2*s]=e[t].width/4,h[t]=e[t].x+u,h[t+s]=1.2*e[t].y/o,h[t+2*s]=4*e[t].width;let c={x:n,y:i},m=new Array(s),f={damping:1.5,initialValues:a,minValues:l,maxValues:h,gradientDifference:u/1e4,maxIterations:100,errorTolerance:1e-4},g=levenbergMarquardt(c,sumOfGaussians,r=Object.assign({},f,r));for(let t=0;t<s;t++)m[t]={parameters:[g.parameterValues[t],g.parameterValues[t+s]*o,g.parameterValues[t+2*s]],error:g.parameterError};return m}function singleGaussian(t){return function(e){let r=t[2]*t[2]/2;if(!e.length)return t[1]*Math.exp(-(e-t[0])*(e-t[0])/r);let n=new Float64Array(e.length);for(let i=0;i<e.length;i++)n[i]=t[1]*Math.exp(-(e[i]-t[0])*(e[i]-t[0])/r);return n}}function optimizeSingleGaussian(t,e,r={}){let n=t[0],i=t[1],o=Math.max(...i);i.forEach(((t,e,r)=>r[e]/=o));let s=Math.abs(n[0]-n[1]),a={damping:1.5,initialValues:new Float64Array([e.x,1,e.width]),minValues:new Float64Array([e.x-s,0,e.width/4]),maxValues:new Float64Array([e.x+s,1.25,4*e.width]),gradientDifference:s/1e4,maxIterations:100,errorTolerance:1e-4},l=levenbergMarquardt({x:n,y:i},singleGaussian,r=Object.assign({},a,r));return{parameters:[l.parameterValues[0],l.parameterValues[1]*o,l.parameterValues[2]],error:l.parameterError}}function sumOfLorentzians(t){return function(e){let r,n,i=t.length/3,o=e.length,s=void 0===o?0:new Float64Array(o).fill(0);for(let a=0;a<i;a++)if(n=Math.pow(t[a+2*i]/2,2),r=t[a+i]*n,void 0===o)s+=r/(Math.pow(e-t[a],2)+n);else for(let i=0;i<o;i++)s[i]+=r/(Math.pow(e[i]-t[a],2)+n);return s}}function optimizeLorentzianSum(t,e,r={}){let n=t[0],i=t[1],o=Math.max(...i);i.forEach(((t,e,r)=>r[e]/=o));let s=e.length,a=new Float64Array(3*s),l=new Float64Array(3*s),h=new Float64Array(3*s),u=Math.abs(n[0]-n[1]);for(let t=0;t<s;t++)a[t]=e[t].x,a[t+s]=1,a[t+2*s]=e[t].width,l[t]=e[t].x-u,l[t+s]=0,l[t+2*s]=e[t].width/4,h[t]=e[t].x+u,h[t+s]=1.5,h[t+2*s]=4*e[t].width;let c={x:n,y:i},m=new Array(s),f={damping:1.5,initialValues:a,minValues:l,maxValues:h,gradientDifference:u/1e4,maxIterations:100,errorTolerance:1e-4},g=levenbergMarquardt(c,sumOfLorentzians,r=Object.assign({},f,r));for(let t=0;t<s;t++)m[t]={parameters:[g.parameterValues[t],g.parameterValues[t+s]*o,g.parameterValues[t+2*s]],error:g.parameterError};return m}function singleLorentzian(t){return function(e){let r=t[1]*Math.pow(t[2]/2,2),n=e.length;if(!n)return r/(Math.pow(e-t[0],2)+Math.pow(t[2]/2,2));let i=new Float64Array(n);for(let o=0;o<n;o++)i[o]=r/(Math.pow(e[o]-t[0],2)+Math.pow(t[2]/2,2));return i}}function optimizeSingleLorentzian(t,e,r={}){let n=t[0],i=t[1],o=Math.max(...i);i.forEach(((t,e,r)=>r[e]/=o));let s=Math.abs(n[0]-n[1]),a={damping:1.5,initialValues:new Float64Array([e.x,1,e.width]),minValues:new Float64Array([e.x-s,.75,e.width/4]),maxValues:new Float64Array([e.x+s,1.25,4*e.width]),gradientDifference:s/1e4,maxIterations:100,errorTolerance:1e-4},l=levenbergMarquardt({x:n,y:i},singleLorentzian,r=Object.assign({},a,r));return{parameters:[l.parameterValues[0],l.parameterValues[1]*o,l.parameterValues[2]],error:l.parameterError}}function optimizePeaks(t,e,r,n={}){const{functionName:i="gaussian",factorWidth:o=4,optimizationOptions:s={damping:1.5,maxIterations:100,errorTolerance:1e-4}}=n;let a,l=[0],h=groupPeaks(t,o),u=[],c=1;"gaussian"===i&&(c=1.17741);for(let t=0;t<h.length;t++){let n=h[t].group;if(n.length>1){if(a=sampleFunction(h[t].limits[0]-h[t].limits[1],h[t].limits[0]+h[t].limits[1],e,r,l),a[0].length>5){let t=[];"gaussian"===i?t=optimizeGaussianSum(a,n,s):"lorentzian"===i&&(t=optimizeLorentzianSum(a,n,s));for(let e=0;e<t.length;e++){let{parameters:r}=t[e];u.push({x:r[0],y:r[1],width:r[2]*c,index:n[e].index})}}}else if(n=n[0],a=sampleFunction(n.x-o*n.width,n.x+o*n.width,e,r,l),a[0].length>5){let t=[];"gaussian"===i?t=optimizeSingleGaussian([a[0],a[1]],n,s):"lorentzian"===i&&(t=optimizeSingleLorentzian([a[0],a[1]],n,s));let{parameters:e}=t;u.push({x:e[0],y:e[1],width:e[2]*c,index:n.index})}}return u}function sampleFunction(t,e,r,n,i){let o=r.length,s=[],a=[],l=Math.sign(r[1]-r[0]);-1===l&&(i[0]=r.length-1);let h=Math.abs(e-t)/2,u=(t+e)/2,c=!1,m=i[0];for(;!c&&m<o&&m>=0;)Math.abs(r[m]-u)<=h?(s.push(r[m]),a.push(n[m]),m+=l):1===Math.sign(u-r[m])?m+=l:c=!0;return i[0]=m,[s,a]}function groupPeaks(t,e){let r,n,i=[],o=[],s=[t[0].x,e*t[0].width];for(let a=0;a<t.length;a++)Math.abs(t[a].x-s[0])<e*t[a].width+s[1]?(i.push(t[a]),r=s[0]+s[1],t[a].x+e*t[a].width>r&&(r=t[a].x+e*t[a].width),n=s[0]-s[1],t[a].x-e*t[a].width<n&&(n=t[a].x-e*t[a].width),s=[(r+n)/2,Math.abs(r-n)/2]):(o.push({limits:s,group:i}),i=[t[a]],s=[t[a].x,e*t[a].width]);o.push({limits:s,group:i});for(let t=o.length-2;t>=0;t--)if(Math.abs(o[t].limits[0]-o[t+1].limits[0])<(o[t].limits[1]+o[t+1].limits[1])/2){for(let e=0;e<o[t+1].group.length;e++)o[t].group.push(o[t+1].group[e]);r=o[t].limits[0]+o[t].limits[1],o[t+1].limits[0]+o[t+1].limits[1]>r&&(r=o[t+1].limits[0]+o[t+1].limits[1]),n=o[t].limits[0]-o[t].limits[1],o[t+1].limits[0]-o[t+1].limits[1]<n&&(n=o[t+1].limits[0]-o[t+1].limits[1]),o[t].limits=[(r+n)/2,Math.abs(r-n)/2],o.splice(t+1,1)}return o}function joinBroadPeaks(t,e={}){let r=e.width,n=[],i=0,o=0,s=1;for(let e=t.length-1;e>=0;e--)t[e].soft&&n.push(t.splice(e,1)[0]);n.push({x:Number.MAX_VALUE});let a=[[n[0].x,n[0].y]],l=[n[0].index];for(let e=1;e<n.length;e++)if(Math.abs(n[e-1].x-n[e].x)<r)a.push([n[e].x,n[e].y]),n[e].y>i&&(i=n[e].y,o=e),l.push(n[e].index),s++;else{if(s>2){let e=optimizeSingleLorentzian(a,{x:n[o].x,y:i,width:Math.abs(a[0][0]-a[a.length-1][0])}),{parameters:r}=e;t.push({x:r[0],y:r[1],width:r[2],index:Math.floor(l.reduce(((t,e)=>t+e),0)/l.length),soft:!1})}else l.forEach((e=>{t.push(n[e])}));a=[[n[e].x,n[e].y]],l=[e],i=n[e].y,o=e,s=1}return t.sort((function(t,e){return t.x-e.x})),t}function broadenPeaks(t,e={}){const{factor:r=2,overlap:n=!1}=e;for(let e of t)e.right&&e.left?(e.from=e.x-(e.x-e.left.x)*r,e.to=e.x+(e.right.x-e.x)*r):(e.from=e.x-e.width/2*r,e.to=e.x+e.width/2*r);if(!n)for(let e=0;e<t.length-1;e++){let r=t[e],n=t[e+1];r.to>n.from&&(r.to=n.from=(r.to+n.from)/2)}for(let e of t)e.width=e.to-e.from;return t}var index$6=Object.freeze({__proto__:null,gsd:gsd,optimizePeaks:optimizePeaks,joinBroadPeaks:joinBroadPeaks,broadenPeaks:broadenPeaks});const toString$4=Object.prototype.toString;function isAnyArray$4(t){return toString$4.call(t).endsWith("Array]")}function min$1(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray$4(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,n=void 0===r?0:r,i=e.toIndex,o=void 0===i?t.length:i;if(n<0||n>=t.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(o<=n||o>t.length||!Number.isInteger(o))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var s=t[n],a=n+1;a<o;a++)t[a]<s&&(s=t[a]);return s}function max$1(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray$4(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,n=void 0===r?0:r,i=e.toIndex,o=void 0===i?t.length:i;if(n<0||n>=t.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(o<=n||o>t.length||!Number.isInteger(o))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var s=t[n],a=n+1;a<o;a++)t[a]>s&&(s=t[a]);return s}function mode$1(t){if(!isAnyArray$4(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0,n=0,i={},o=0;o<t.length;++o){var s=t[o];(n=i[s])?(i[s]++,n++):i[s]=n=1,n>r&&(r=n,e=t[o])}return e}const toString$5=Object.prototype.toString;function isAnyArray$5(t){return toString$5.call(t).endsWith("Array]")}function max$2(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray$5(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");var r=e.fromIndex,n=void 0===r?0:r,i=e.toIndex,o=void 0===i?t.length:i;if(n<0||n>=t.length||!Number.isInteger(n))throw new Error("fromIndex must be a positive integer smaller than length");if(o<=n||o>t.length||!Number.isInteger(o))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var s=t[n],a=n+1;a<o;a++)t[a]>s&&(s=t[a]);return s}function norm$1(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=r.algorithm,i=void 0===n?"absolute":n,o=r.sumValue,s=void 0===o?1:o,a=r.maxValue,l=void 0===a?1:a;if(!isAnyArray$5(t))throw new Error("input must be an array");if(void 0!==r.output){if(!isAnyArray$5(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);if(0===t.length)throw new Error("input must not be empty");switch(i.toLowerCase()){case"absolute":var h=absoluteSum(t)/s;if(0===h)return t.slice(0);for(var u=0;u<t.length;u++)e[u]=t[u]/h;return e;case"max":var c=max$2(t);if(0===c)return t.slice(0);for(var m=l/c,f=0;f<t.length;f++)e[f]=t[f]*m;return e;case"sum":var g=sum(t)/s;if(0===g)return t.slice(0);for(var p=0;p<t.length;p++)e[p]=t[p]/g;return e;default:throw new Error("norm: unknown algorithm: ".concat(i))}}function absoluteSum(t){for(var e=0,r=0;r<t.length;r++)e+=Math.abs(t[r]);return e}function _typeof(t){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function sequentialFill(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"!==_typeof(t)||isAnyArray$4(t)||(e=t,t=[]),!isAnyArray$4(t))throw new TypeError("input must be an array");var r=e,n=r.from,i=void 0===n?0:n,o=r.to,s=void 0===o?10:o,a=r.size,l=void 0===a?t.length:a,h=r.step;if(0!==l&&h)throw new Error("step is defined by the array size");if(l||(l=h?Math.floor((s-i)/h)+1:s-i+1),!h&&l&&(h=(s-i)/(l-1)),Array.isArray(t)){t.length=0;for(var u=0;u<l;u++)t.push(i),i+=h}else{if(t.length!==l)throw new Error("sequentialFill typed array must have the correct length");for(var c=0;c<l;c++)t[c]=i,i+=h}return t}const toString$6=Object.prototype.toString;function isAnyArray$6(t){return toString$6.call(t).endsWith("Array]")}function variance(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!isAnyArray$6(t))throw new TypeError("input must be an array");for(var r=e.unbiased,n=void 0===r||r,i=e.mean,o=void 0===i?mean(t):i,s=0,a=0;a<t.length;a++){var l=t[a]-o;s+=l*l}return n?s/(t.length-1):s/t.length}function standardDeviation(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Math.sqrt(variance(t,e))}function mergeByCentroids(t,e,r={}){const{window:n=.01}=r;for(var i={x:e.slice(),y:new Array(e.length).fill(0)},o=0,s=0;o<t.x.length&&s<e.length;){var a=t.x[o]-e[s];Math.abs(a)<n?i.y[s]+=t.y[o++]:a<0?o++:s++}return i}function closestX(t,e){const{x:r,y:n}=t,{target:i=r[0],reverse:o=!1}=e;let s;return s=binarySearch(r,i,o?descending:ascending),s>=0?{x:r[s],y:n[s]}:(s=~s,0!==s&&Math.abs(r[s]-i)>.5||s===r.length?{x:r[s-1],y:n[s-1]}:{x:r[s],y:n[s]})}function covariance$1(t,e={}){const{x:r,y:n}=t,{unbiased:i=!0}=e,o=mean(r),s=mean(n);var a=0;for(let t=0;t<r.length;t++)a+=(r[t]-o)*(n[t]-s);return i?a/(r.length-1):a/r.length}function maxMerge(t,e={}){const{x:r,y:n}=t,{groupWidth:i=.001}=e;for(var o={x:[],y:[]},s={x:[],y:[]},a=0,l=0;l<r.length;)0===a||r[l]-o.x[a-1]>i?(s.x.push(r[l]),s.y.push(n[l]),o.x.push(r[l]),o.y.push(n[l]),l++,a++):(n[l]>s.y[a-1]&&(s.x[a-1]=r[l],s.y[a-1]=n[l]),o.x[a-1]=r[l],o.y[a-1]+=n[l],l++);return o.x=s.x.slice(),o}function maxY(t,e={}){const{x:r,y:n}=t;let{from:i={index:0},to:o={index:r.length},reverse:s=!1}=e;void 0!==i.value&&void 0===i.index&&(i.index=calculateIndex(i.value,r,s)),void 0!==o.value&&void 0===o.index&&(o.index=calculateIndex(o.value,r,s));for(var a,l=Number.MIN_VALUE,h=i.index;h<o.index;h++)l<n[h]&&(l=n[h],a=h);return{index:a,value:l}}function calculateIndex(t,e,r){let n;if(n=binarySearch(e,t,r?descending:ascending),n<0)throw new Error(`the value ${t} doesn't belongs to the abscissa value`);return n}function sortX(t,e={}){const{x:r,y:n}=t,{reverse:i=!1}=e;var o;o=i?(t,e)=>e.x-t.x:(t,e)=>t.x-e.x;for(var s=r.map(((t,e)=>({x:t,y:n[e]}))).sort(o),a={x:r.slice(),y:n.slice()},l=0;l<r.length;l++)a.x[l]=s[l].x,a.y[l]=s[l].y;return a}function uniqueX(t={}){const{x:e,y:r}=t;if(e.length<2)return;if(e.length!==r.length)throw new Error("The X and Y arrays mush have the same length");let n=e[0],i=0;for(let t=1;t<e.length;t++)n!==e[t]&&(i++,n=e[t],e[i]=e[t],t!==i&&(r[i]=0)),t!==i&&(r[i]+=r[t]);e.length=i+1,r.length=i+1}function weightedMerge(t,e={}){const{x:r,y:n}=t,{groupWidth:i=.001}=e;for(var o={x:[],y:[]},s={x:[],y:[]},a=0,l=0;l<r.length;)0===a||r[l]-o.x[a-1]>i?(s.x.push(r[l]*n[l]),s.y.push(n[l]),o.x.push(r[l]),o.y.push(n[l]),l++,a++):(s.x[a-1]+=r[l]*n[l],s.y[a-1]+=n[l],o.x[a-1]=r[l],o.y[a-1]+=n[l],l++);for(var h=0;h<o.x.length;h++)o.x[h]=s.x[h]/s.y[h];return o}function normalize$1(t=[],e={}){if(0===t.length)return[];let{from:r=Number.NEGATIVE_INFINITY,to:n=Number.POSITIVE_INFINITY}=e;if(r>n&&([r,n]=[n,r]),(t=(t=JSON.parse(JSON.stringify(t)).map((t=>t.from>t.to?{from:t.to,to:t.from}:t))).sort(((t,e)=>t.from!==e.from?t.from-e.from:t.to-e.to))).forEach((t=>{r>t.from&&(t.from=r),n<t.to&&(t.to=n)})),0===(t=t.filter((t=>t.from<=t.to))).length)return[];let i=t[0],o=[i];for(let e=1;e<t.length;e++){let r=t[e];r.from<=i.to?i.to=r.to:(i=r,o.push(i))}return o}function invert(t=[],e={}){let{from:r=Number.NEGATIVE_INFINITY,to:n=Number.POSITIVE_INFINITY}=e;if(r>n&&([r,n]=[n,r]),0===(t=normalize$1(t,{from:r,to:n})).length)return[{from:r,to:n}];let i=[];for(let e=0;e<t.length;e++){let o=t[e],s=t[e+1];0===e&&o.from>r&&i.push({from:r,to:o.from}),e===t.length-1?o.to<n&&i.push({from:o.to,to:n}):i.push({from:o.to,to:s.from})}return i}function zonesWithPoints(t,e,r={}){if(0===t.length)return t;let n=(t=normalize$1(t,r)).reduce(((t,e)=>t+(e.to-e.from)),0)/e,i=0;for(let r=0;r<t.length-1;r++){let o=t[r];o.numberOfPoints=Math.min(Math.round((o.to-o.from)/n),e-i),i+=o.numberOfPoints}return t[t.length-1].numberOfPoints=e-i,t}function integral(t,e,r,n){return.5*r*e*e+n*e-(.5*r*t*t+n*t)}function equallySpacedSmooth(t,e,r,n,i){let o=t.length,s=(n-r)/(i-1),a=s/2,l=new Array(i),h=t[1]-t[0],u=t[o-1]-t[o-2],c=r-a,m=r+a,f=Number.MIN_VALUE,g=0,p=t[0]-h,d=0,w=0,x=0,y=0,M=0,v=0,b=0,S=0;let A=0;t:for(;;){for(f<=c&&c<=p&&(A=integral(0,c-f,x,g),M=w+A);p-m>=0;){if(A=integral(0,m-f,x,g),v=w+A,l[S++]=(v-M)/s,S===i)break t;c=m,m+=s,M=v}w+=integral(f,p,x,y),f=p,g=d,b<o?(p=t[b],d=e[b],b++):b===o&&(p+=u,d=0),x=(d-g)/(p-f),y=-x*f+g}return l}function equallySpacedSlot(t,e,r,n,i){let o=t.length,s=(n-r)/(i-1),a=s/2,l=t[t.length-1]-t[t.length-2],h=r-a,u=new Array(i),c=h,m=h+s,f=-Number.MAX_VALUE,g=0,p=t[0],d=e[0],w=0,x=!0,y=0,M=0,v=1,b=0;t:for(;;){if(f>=p)throw new Error("x must be an increasing serie");for(;f-m>0;){if(x&&(M++,x=!1),u[b]=M<=0?0:y/M,b++,b===i)break t;c=m,m+=s,y=0,M=0}f>c&&(y+=g,M++),(f===-Number.MAX_VALUE||w>1)&&M--,f=p,g=d,v<o?(p=t[v],d=e[v],v++):(p+=l,d=0,w++)}return u}function equallySpaced(t={},e={}){let{x:r,y:n}=t,i=r.length,o=!1;r.length>1&&r[0]>r[1]&&(r=r.slice().reverse(),n=n.slice().reverse(),o=!0);let{from:s=r[0],to:a=r[i-1],variant:l="smooth",numberOfPoints:h=100,exclusions:u=[],zones:c=[]}=e;if(i!==n.length)throw new RangeError("the x and y vector doesn't have the same size.");if("number"!=typeof s||isNaN(s))throw new RangeError("'from' option must be a number");if("number"!=typeof a||isNaN(a))throw new RangeError("'to' option must be a number");if("number"!=typeof h||isNaN(h))throw new RangeError("'numberOfPoints' option must be a number");if(h<2)throw new RangeError("'numberOfPoints' option must be greater than 1");0===c.length&&(c=invert(u,{from:s,to:a})),c=zonesWithPoints(c,h,{from:s,to:a});let m=[],f=[];for(let t of c){let e=processZone(r,n,t.from,t.to,t.numberOfPoints,l);m=m.concat(e.x),f=f.concat(e.y)}return o?s<a?{x:m.reverse(),y:f.reverse()}:{x:m,y:f}:s<a?{x:m,y:f}:{x:m.reverse(),y:f.reverse()}}function processZone(t,e,r,n,i,o){if(i<1)throw new RangeError("the number of points must be at least 1");let s="slot"===o?equallySpacedSlot(t,e,r,n,i):equallySpacedSmooth(t,e,r,n,i);return{x:sequentialFill({from:r,to:n,size:i}),y:s}}function getZones(t,e,r=[]){t>e&&([t,e]=[e,t]),r=r.filter((t=>void 0!==t.from&&void 0!==t.to)),(r=JSON.parse(JSON.stringify(r))).forEach((t=>{t.from>t.to&&([t.to,t.from]=[t.from,t.to])})),r.sort(((t,e)=>t.from-e.from)),r.forEach((r=>{r.from<t&&(r.from=t),r.to>e&&(r.to=e)}));for(let t=0;t<r.length-1;t++)r[t].to>r[t+1].from&&(r[t].to=r[t+1].from);if(!(r=r.filter((t=>t.from<t.to)))||0===r.length)return[{from:t,to:e}];let n=[],i=t;for(let t of r)i<t.from&&n.push({from:i,to:t.from}),i=t.to;return i<e&&n.push({from:i,to:e}),n}function filterX(t,e={}){const{x:r,y:n}=t,{from:i=r[0],to:o=r[r.length-1],exclusions:s=[]}=e;let a=getZones(i,o,s),l=0,h=[],u=[],c=0;for(;c<r.length;){if(r[c]<=a[l].to&&r[c]>=a[l].from)h.push(r[c]),u.push(n[c]);else if(r[c]>a[l].to&&(l++,!a[l]))break;c++}return{x:h,y:u}}const{Matrix:Matrix$2,SVD:SVD,EVD:EVD,CholeskyDecomposition:CholeskyDecomposition$1,LuDecomposition:LuDecomposition$1,QrDecomposition:QrDecomposition$1}=MatrixLib,Array$1={min:min$1,max:max$1,median:median,mean:mean,mode:mode$1,normed:norm$1,rescale:rescale,sequentialFill:sequentialFill,standardDeviation:standardDeviation,sum:sum,variance:variance},ArrayXY={centroidsMerge:mergeByCentroids,closestX:closestX,covariance:covariance$1,maxMerge:maxMerge,maxY:maxY,sortX:sortX,uniqueX:uniqueX,weightedMerge:weightedMerge,equallySpaced:equallySpaced,filterX:filterX};exports.Array=Array$1,exports.ArrayXY=ArrayXY,exports.BitArray=src$3,exports.CholeskyDecomposition=CholeskyDecomposition$1,exports.ConfusionMatrix=ConfusionMatrix,exports.CrossValidation=index$2,exports.DecisionTreeClassifier=DecisionTreeClassifier,exports.DecisionTreeRegression=DecisionTreeRegression,exports.Distance=distances,exports.EVD=EVD,exports.ExponentialRegression=ExponentialRegression,exports.FCNNLS=index$3,exports.FNN=FeedForwardNeuralNetwork,exports.GSD=index$6,exports.HClust=index,exports.HashTable=HashTable,exports.KMeans=kmeans,exports.KNN=KNN,exports.KOPLS=KOPLS,exports.Kernel=kernel,exports.LuDecomposition=LuDecomposition$1,exports.Matrix=Matrix$2,exports.MatrixLib=MatrixLib,exports.MultivariateLinearRegression=MultivariateLinearRegression,exports.NaiveBayes=index$1,exports.OPLS=OPLS,exports.OPLSNipals=OPLSNipals,exports.PCA=PCA,exports.PLS=PLS,exports.Performance=src$1,exports.PolynomialRegression=PolynomialRegression,exports.PowerRegression=PowerRegression,exports.QrDecomposition=QrDecomposition$1,exports.Random=Random,exports.RandomForestClassifier=RandomForestClassifier,exports.RandomForestRegression=RandomForestRegression,exports.RobustPolynomialRegression=RobustPolynomialRegression,exports.SOM=src,exports.SVD=SVD,exports.Similarity=similarities,exports.SimpleLinearRegression=SimpleLinearRegression,exports.SparseMatrix=SparseMatrix,exports.TheilSenRegression=TheilSenRegression,exports.XSadd=XSadd,exports.binarySearch=binarySearch,exports.distanceMatrix=distanceMatrix,exports.levenbergMarquardt=levenbergMarquardt,exports.nGMCA=nGMCA,exports.numSort=index$4,exports.padArray=src$2,exports.savitzkyGolay=savitzkyGolay,Object.defineProperty(exports,"__esModule",{value:!0})}));
//# sourceMappingURL=ml.min.js.map
