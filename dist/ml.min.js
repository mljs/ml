!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).ML={})}(this,(function(exports){"use strict";const toString=Object.prototype.toString;function isAnyArray(t){return toString.call(t).endsWith("Array]")}var src=isAnyArray;function max(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=t[0],r=1;r<t.length;r++)t[r]>e&&(e=t[r]);return e}function min(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=t[0],r=1;r<t.length;r++)t[r]<e&&(e=t[r]);return e}function rescale(t){var e,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");if(void 0!==r.output){if(!src(r.output))throw new TypeError("output option must be an array if specified");e=r.output}else e=new Array(t.length);var i=min(t),n=max(t);if(i===n)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var s=r.min,o=void 0===s?r.autoMinMax?i:0:s,a=r.max,h=void 0===a?r.autoMinMax?n:1:a;if(o>=h)throw new RangeError("min option must be smaller than max option");for(var l=(h-o)/(n-i),u=0;u<t.length;u++)e[u]=(t[u]-i)*l+o;return e}function checkRowIndex(t,e,r){let i=r?t.rows:t.rows-1;if(e<0||e>i)throw new RangeError("Row index out of range")}function checkColumnIndex(t,e,r){let i=r?t.columns:t.columns-1;if(e<0||e>i)throw new RangeError("Column index out of range")}function checkRowVector(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.columns)throw new RangeError("vector size must be the same as the number of columns");return e}function checkColumnVector(t,e){if(e.to1DArray&&(e=e.to1DArray()),e.length!==t.rows)throw new RangeError("vector size must be the same as the number of rows");return e}function checkIndices(t,e,r){return{row:checkRowIndices(t,e),column:checkColumnIndices(t,r)}}function checkRowIndices(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for row indices");if(e.some(e=>e<0||e>=t.rows))throw new RangeError("row indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function checkColumnIndices(t,e){if("object"!=typeof e)throw new TypeError("unexpected type for column indices");if(e.some(e=>e<0||e>=t.columns))throw new RangeError("column indices are out of range");return Array.isArray(e)||(e=Array.from(e)),e}function checkRange(t,e,r,i,n){if(5!==arguments.length)throw new RangeError("expected 4 arguments");if(checkNumber("startRow",e),checkNumber("endRow",r),checkNumber("startColumn",i),checkNumber("endColumn",n),e>r||i>n||e<0||e>=t.rows||r<0||r>=t.rows||i<0||i>=t.columns||n<0||n>=t.columns)throw new RangeError("Submatrix indices are out of range")}function newArray(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=[];for(let i=0;i<t;i++)r.push(e);return r}function checkNumber(t,e){if("number"!=typeof e)throw new TypeError("".concat(t," must be a number"))}function sumByRow(t){let e=newArray(t.rows);for(let r=0;r<t.rows;++r)for(let i=0;i<t.columns;++i)e[r]+=t.get(r,i);return e}function sumByColumn(t){let e=newArray(t.columns);for(let r=0;r<t.rows;++r)for(let i=0;i<t.columns;++i)e[i]+=t.get(r,i);return e}function sumAll(t){let e=0;for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)e+=t.get(r,i);return e}function productByRow(t){let e=newArray(t.rows,1);for(let r=0;r<t.rows;++r)for(let i=0;i<t.columns;++i)e[r]*=t.get(r,i);return e}function productByColumn(t){let e=newArray(t.columns,1);for(let r=0;r<t.rows;++r)for(let i=0;i<t.columns;++i)e[i]*=t.get(r,i);return e}function productAll(t){let e=1;for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)e*=t.get(r,i);return e}function varianceByRow(t,e,r){const i=t.rows,n=t.columns,s=[];for(let o=0;o<i;o++){let i=0,a=0,h=0;for(let e=0;e<n;e++)i+=h=t.get(o,e)-r[o],a+=h*h;e?s.push((a-i*i/n)/(n-1)):s.push((a-i*i/n)/n)}return s}function varianceByColumn(t,e,r){const i=t.rows,n=t.columns,s=[];for(let o=0;o<n;o++){let n=0,a=0,h=0;for(let e=0;e<i;e++)n+=h=t.get(e,o)-r[o],a+=h*h;e?s.push((a-n*n/i)/(i-1)):s.push((a-n*n/i)/i)}return s}function varianceAll(t,e,r){const i=t.rows,n=t.columns,s=i*n;let o=0,a=0,h=0;for(let e=0;e<i;e++)for(let i=0;i<n;i++)o+=h=t.get(e,i)-r,a+=h*h;return e?(a-o*o/s)/(s-1):(a-o*o/s)/s}function centerByRow(t,e){for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)t.set(r,i,t.get(r,i)-e[r])}function centerByColumn(t,e){for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)t.set(r,i,t.get(r,i)-e[i])}function centerAll(t,e){for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)t.set(r,i,t.get(r,i)-e)}function getScaleByRow(t){const e=[];for(let r=0;r<t.rows;r++){let i=0;for(let e=0;e<t.columns;e++)i+=Math.pow(t.get(r,e),2)/(t.columns-1);e.push(Math.sqrt(i))}return e}function scaleByRow(t,e){for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)t.set(r,i,t.get(r,i)/e[r])}function getScaleByColumn(t){const e=[];for(let r=0;r<t.columns;r++){let i=0;for(let e=0;e<t.rows;e++)i+=Math.pow(t.get(e,r),2)/(t.rows-1);e.push(Math.sqrt(i))}return e}function scaleByColumn(t,e){for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)t.set(r,i,t.get(r,i)/e[i])}function getScaleAll(t){const e=t.size-1;let r=0;for(let i=0;i<t.columns;i++)for(let n=0;n<t.rows;n++)r+=Math.pow(t.get(n,i),2)/e;return Math.sqrt(r)}function scaleAll(t,e){for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)t.set(r,i,t.get(r,i)/e)}function inspectMatrix(){const t=" ".repeat(2),e=" ".repeat(4);return"".concat(this.constructor.name," {\n").concat(t,"[\n").concat(e).concat(inspectData(this,e),"\n").concat(t,"]\n").concat(t,"rows: ").concat(this.rows,"\n").concat(t,"columns: ").concat(this.columns,"\n}")}const maxRows=15,maxColumns=10,maxNumSize=8;function inspectData(t,e){const{rows:r,columns:i}=t,n=Math.min(r,maxRows),s=Math.min(i,maxColumns),o=[];for(let e=0;e<n;e++){let r=[];for(let i=0;i<s;i++)r.push(formatNumber(t.get(e,i)));o.push("".concat(r.join(" ")))}return s!==i&&(o[o.length-1]+=" ... ".concat(i-maxColumns," more columns")),n!==r&&o.push("... ".concat(r-maxRows," more rows")),o.join("\n".concat(e))}function formatNumber(t){const e=String(t);if(e.length<=maxNumSize)return e.padEnd(maxNumSize," ");const r=t.toPrecision(maxNumSize-2);if(r.length<=maxNumSize)return r;const i=t.toExponential(maxNumSize-2),n=i.indexOf("e"),s=i.substring(n);return i.substring(0,maxNumSize-s.length)+s}function installMathOperations(t,e){t.prototype.add=function(t){return"number"==typeof t?this.addS(t):this.addM(t)},t.prototype.addS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t);return this},t.prototype.addM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t.get(e,r));return this},t.add=function(t,r){return new e(t).add(r)},t.prototype.sub=function(t){return"number"==typeof t?this.subS(t):this.subM(t)},t.prototype.subS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t);return this},t.prototype.subM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t.get(e,r));return this},t.sub=function(t,r){return new e(t).sub(r)},t.prototype.subtract=t.prototype.sub,t.prototype.subtractS=t.prototype.subS,t.prototype.subtractM=t.prototype.subM,t.subtract=t.sub,t.prototype.mul=function(t){return"number"==typeof t?this.mulS(t):this.mulM(t)},t.prototype.mulS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t);return this},t.prototype.mulM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t.get(e,r));return this},t.mul=function(t,r){return new e(t).mul(r)},t.prototype.multiply=t.prototype.mul,t.prototype.multiplyS=t.prototype.mulS,t.prototype.multiplyM=t.prototype.mulM,t.multiply=t.mul,t.prototype.div=function(t){return"number"==typeof t?this.divS(t):this.divM(t)},t.prototype.divS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t);return this},t.prototype.divM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t.get(e,r));return this},t.div=function(t,r){return new e(t).div(r)},t.prototype.divide=t.prototype.div,t.prototype.divideS=t.prototype.divS,t.prototype.divideM=t.prototype.divM,t.divide=t.div,t.prototype.mod=function(t){return"number"==typeof t?this.modS(t):this.modM(t)},t.prototype.modS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t);return this},t.prototype.modM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)%t.get(e,r));return this},t.mod=function(t,r){return new e(t).mod(r)},t.prototype.modulus=t.prototype.mod,t.prototype.modulusS=t.prototype.modS,t.prototype.modulusM=t.prototype.modM,t.modulus=t.mod,t.prototype.and=function(t){return"number"==typeof t?this.andS(t):this.andM(t)},t.prototype.andS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t);return this},t.prototype.andM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)&t.get(e,r));return this},t.and=function(t,r){return new e(t).and(r)},t.prototype.or=function(t){return"number"==typeof t?this.orS(t):this.orM(t)},t.prototype.orS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t);return this},t.prototype.orM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)|t.get(e,r));return this},t.or=function(t,r){return new e(t).or(r)},t.prototype.xor=function(t){return"number"==typeof t?this.xorS(t):this.xorM(t)},t.prototype.xorS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t);return this},t.prototype.xorM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)^t.get(e,r));return this},t.xor=function(t,r){return new e(t).xor(r)},t.prototype.leftShift=function(t){return"number"==typeof t?this.leftShiftS(t):this.leftShiftM(t)},t.prototype.leftShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t);return this},t.prototype.leftShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)<<t.get(e,r));return this},t.leftShift=function(t,r){return new e(t).leftShift(r)},t.prototype.signPropagatingRightShift=function(t){return"number"==typeof t?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},t.prototype.signPropagatingRightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t);return this},t.prototype.signPropagatingRightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>t.get(e,r));return this},t.signPropagatingRightShift=function(t,r){return new e(t).signPropagatingRightShift(r)},t.prototype.rightShift=function(t){return"number"==typeof t?this.rightShiftS(t):this.rightShiftM(t)},t.prototype.rightShiftS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t);return this},t.prototype.rightShiftM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)>>>t.get(e,r));return this},t.rightShift=function(t,r){return new e(t).rightShift(r)},t.prototype.zeroFillRightShift=t.prototype.rightShift,t.prototype.zeroFillRightShiftS=t.prototype.rightShiftS,t.prototype.zeroFillRightShiftM=t.prototype.rightShiftM,t.zeroFillRightShift=t.rightShift,t.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,~this.get(t,e));return this},t.not=function(t){return new e(t).not()},t.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.abs(this.get(t,e)));return this},t.abs=function(t){return new e(t).abs()},t.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acos(this.get(t,e)));return this},t.acos=function(t){return new e(t).acos()},t.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.acosh(this.get(t,e)));return this},t.acosh=function(t){return new e(t).acosh()},t.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asin(this.get(t,e)));return this},t.asin=function(t){return new e(t).asin()},t.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.asinh(this.get(t,e)));return this},t.asinh=function(t){return new e(t).asinh()},t.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atan(this.get(t,e)));return this},t.atan=function(t){return new e(t).atan()},t.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.atanh(this.get(t,e)));return this},t.atanh=function(t){return new e(t).atanh()},t.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cbrt(this.get(t,e)));return this},t.cbrt=function(t){return new e(t).cbrt()},t.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.ceil(this.get(t,e)));return this},t.ceil=function(t){return new e(t).ceil()},t.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.clz32(this.get(t,e)));return this},t.clz32=function(t){return new e(t).clz32()},t.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cos(this.get(t,e)));return this},t.cos=function(t){return new e(t).cos()},t.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.cosh(this.get(t,e)));return this},t.cosh=function(t){return new e(t).cosh()},t.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.exp(this.get(t,e)));return this},t.exp=function(t){return new e(t).exp()},t.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.expm1(this.get(t,e)));return this},t.expm1=function(t){return new e(t).expm1()},t.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.floor(this.get(t,e)));return this},t.floor=function(t){return new e(t).floor()},t.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.fround(this.get(t,e)));return this},t.fround=function(t){return new e(t).fround()},t.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log(this.get(t,e)));return this},t.log=function(t){return new e(t).log()},t.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log1p(this.get(t,e)));return this},t.log1p=function(t){return new e(t).log1p()},t.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log10(this.get(t,e)));return this},t.log10=function(t){return new e(t).log10()},t.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.log2(this.get(t,e)));return this},t.log2=function(t){return new e(t).log2()},t.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.round(this.get(t,e)));return this},t.round=function(t){return new e(t).round()},t.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sign(this.get(t,e)));return this},t.sign=function(t){return new e(t).sign()},t.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sin(this.get(t,e)));return this},t.sin=function(t){return new e(t).sin()},t.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sinh(this.get(t,e)));return this},t.sinh=function(t){return new e(t).sinh()},t.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.sqrt(this.get(t,e)));return this},t.sqrt=function(t){return new e(t).sqrt()},t.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tan(this.get(t,e)));return this},t.tan=function(t){return new e(t).tan()},t.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.tanh(this.get(t,e)));return this},t.tanh=function(t){return new e(t).tanh()},t.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let e=0;e<this.columns;e++)this.set(t,e,Math.trunc(this.get(t,e)));return this},t.trunc=function(t){return new e(t).trunc()},t.pow=function(t,r){return new e(t).pow(r)},t.prototype.pow=function(t){return"number"==typeof t?this.powS(t):this.powM(t)},t.prototype.powS=function(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t));return this},t.prototype.powM=function(t){if(t=e.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,Math.pow(this.get(e,r),t.get(e,r)));return this}}class AbstractMatrix{static from1DArray(t,e,r){if(t*e!==r.length)throw new RangeError("data length does not match given dimensions");let i=new Matrix(t,e);for(let n=0;n<t;n++)for(let t=0;t<e;t++)i.set(n,t,r[n*e+t]);return i}static rowVector(t){let e=new Matrix(1,t.length);for(let r=0;r<t.length;r++)e.set(0,r,t[r]);return e}static columnVector(t){let e=new Matrix(t.length,1);for(let r=0;r<t.length;r++)e.set(r,0,t[r]);return e}static zeros(t,e){return new Matrix(t,e)}static ones(t,e){return new Matrix(t,e).fill(1)}static rand(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("object"!=typeof r)throw new TypeError("options must be an object");const{random:i=Math.random}=r;let n=new Matrix(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++)n.set(r,t,i());return n}static randInt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("object"!=typeof r)throw new TypeError("options must be an object");const{min:i=0,max:n=1e3,random:s=Math.random}=r;if(!Number.isInteger(i))throw new TypeError("min must be an integer");if(!Number.isInteger(n))throw new TypeError("max must be an integer");if(i>=n)throw new RangeError("min must be smaller than max");let o=n-i,a=new Matrix(t,e);for(let r=0;r<t;r++)for(let t=0;t<e;t++){let e=i+Math.round(s()*o);a.set(r,t,e)}return a}static eye(t,e,r){void 0===e&&(e=t),void 0===r&&(r=1);let i=Math.min(t,e),n=this.zeros(t,e);for(let t=0;t<i;t++)n.set(t,t,r);return n}static diag(t,e,r){let i=t.length;void 0===e&&(e=i),void 0===r&&(r=e);let n=Math.min(i,e,r),s=this.zeros(e,r);for(let e=0;e<n;e++)s.set(e,e,t[e]);return s}static min(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,i=t.columns,n=new Matrix(r,i);for(let s=0;s<r;s++)for(let r=0;r<i;r++)n.set(s,r,Math.min(t.get(s,r),e.get(s,r)));return n}static max(t,e){t=this.checkMatrix(t),e=this.checkMatrix(e);let r=t.rows,i=t.columns,n=new this(r,i);for(let s=0;s<r;s++)for(let r=0;r<i;r++)n.set(s,r,Math.max(t.get(s,r),e.get(s,r)));return n}static checkMatrix(t){return AbstractMatrix.isMatrix(t)?t:new Matrix(t)}static isMatrix(t){return null!=t&&"Matrix"===t.klass}get size(){return this.rows*this.columns}apply(t){if("function"!=typeof t)throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.call(this,e,r);return this}to1DArray(){let t=[];for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.push(this.get(e,r));return t}to2DArray(){let t=[];for(let e=0;e<this.rows;e++){t.push([]);for(let r=0;r<this.columns;r++)t[e].push(this.get(e,r))}return t}toJSON(){return this.to2DArray()}isRowVector(){return 1===this.rows}isColumnVector(){return 1===this.columns}isVector(){return 1===this.rows||1===this.columns}isSquare(){return this.rows===this.columns}isSymmetric(){if(this.isSquare()){for(let t=0;t<this.rows;t++)for(let e=0;e<=t;e++)if(this.get(t,e)!==this.get(e,t))return!1;return!0}return!1}isEchelonForm(){let t=0,e=0,r=-1,i=!0,n=!1;for(;t<this.rows&&i;){for(e=0,n=!1;e<this.columns&&!1===n;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(n=!0,r=e):(i=!1,n=!0);t++}return i}isReducedEchelonForm(){let t=0,e=0,r=-1,i=!0,n=!1;for(;t<this.rows&&i;){for(e=0,n=!1;e<this.columns&&!1===n;)0===this.get(t,e)?e++:1===this.get(t,e)&&e>r?(n=!0,r=e):(i=!1,n=!0);for(let r=e+1;r<this.rows;r++)0!==this.get(t,r)&&(i=!1);t++}return i}echelonForm(){let t=this.clone(),e=0,r=0;for(;e<t.rows&&r<t.columns;){let i=e;for(let n=e;n<t.rows;n++)t.get(n,r)>t.get(i,r)&&(i=n);if(0===t.get(i,r))r++;else{t.swapRows(e,i);let n=t.get(e,r);for(let i=r;i<t.columns;i++)t.set(e,i,t.get(e,i)/n);for(let i=e+1;i<t.rows;i++){let n=t.get(i,r)/t.get(e,r);t.set(i,r,0);for(let s=r+1;s<t.columns;s++)t.set(i,s,t.get(i,s)-t.get(e,s)*n)}e++,r++}}return t}reducedEchelonForm(){let t=this.echelonForm(),e=t.columns,r=t.rows,i=r-1;for(;i>=0;)if(0===t.maxRow(i))i--;else{let n=0,s=!1;for(;n<r&&!1===s;)1===t.get(i,n)?s=!0:n++;for(let r=0;r<i;r++){let s=t.get(r,n);for(let o=n;o<e;o++){let e=t.get(r,o)-s*t.get(i,o);t.set(r,o,e)}}i--}return t}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{rows:e=1,columns:r=1}=t;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(r)||r<=0)throw new TypeError("columns must be a positive integer");let i=new Matrix(this.rows*e,this.columns*r);for(let t=0;t<e;t++)for(let e=0;e<r;e++)i.setSubMatrix(this,this.rows*t,this.columns*e);return i}fill(t){for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,t);return this}neg(){return this.mulS(-1)}getRow(t){checkRowIndex(this,t);let e=[];for(let r=0;r<this.columns;r++)e.push(this.get(t,r));return e}getRowVector(t){return Matrix.rowVector(this.getRow(t))}setRow(t,e){checkRowIndex(this,t),e=checkRowVector(this,e);for(let r=0;r<this.columns;r++)this.set(t,r,e[r]);return this}swapRows(t,e){checkRowIndex(this,t),checkRowIndex(this,e);for(let r=0;r<this.columns;r++){let i=this.get(t,r);this.set(t,r,this.get(e,r)),this.set(e,r,i)}return this}getColumn(t){checkColumnIndex(this,t);let e=[];for(let r=0;r<this.rows;r++)e.push(this.get(r,t));return e}getColumnVector(t){return Matrix.columnVector(this.getColumn(t))}setColumn(t,e){checkColumnIndex(this,t),e=checkColumnVector(this,e);for(let r=0;r<this.rows;r++)this.set(r,t,e[r]);return this}swapColumns(t,e){checkColumnIndex(this,t),checkColumnIndex(this,e);for(let r=0;r<this.rows;r++){let i=this.get(r,t);this.set(r,t,this.get(r,e)),this.set(r,e,i)}return this}addRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[r]);return this}subRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[r]);return this}mulRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[r]);return this}divRowVector(t){t=checkRowVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[r]);return this}addColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)+t[e]);return this}subColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)-t[e]);return this}mulColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)*t[e]);return this}divColumnVector(t){t=checkColumnVector(this,t);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.set(e,r,this.get(e,r)/t[e]);return this}mulRow(t,e){checkRowIndex(this,t);for(let r=0;r<this.columns;r++)this.set(t,r,this.get(t,r)*e);return this}mulColumn(t,e){checkColumnIndex(this,t);for(let r=0;r<this.rows;r++)this.set(r,t,this.get(r,t)*e);return this}max(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)>t&&(t=this.get(e,r));return t}maxIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)>t&&(t=this.get(r,i),e[0]=r,e[1]=i);return e}min(){let t=this.get(0,0);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)this.get(e,r)<t&&(t=this.get(e,r));return t}minIndex(){let t=this.get(0,0),e=[0,0];for(let r=0;r<this.rows;r++)for(let i=0;i<this.columns;i++)this.get(r,i)<t&&(t=this.get(r,i),e[0]=r,e[1]=i);return e}maxRow(t){checkRowIndex(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxRowIndex(t){checkRowIndex(this,t);let e=this.get(t,0),r=[t,0];for(let i=1;i<this.columns;i++)this.get(t,i)>e&&(e=this.get(t,i),r[1]=i);return r}minRow(t){checkRowIndex(this,t);let e=this.get(t,0);for(let r=1;r<this.columns;r++)this.get(t,r)<e&&(e=this.get(t,r));return e}minRowIndex(t){checkRowIndex(this,t);let e=this.get(t,0),r=[t,0];for(let i=1;i<this.columns;i++)this.get(t,i)<e&&(e=this.get(t,i),r[1]=i);return r}maxColumn(t){checkColumnIndex(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxColumnIndex(t){checkColumnIndex(this,t);let e=this.get(0,t),r=[0,t];for(let i=1;i<this.rows;i++)this.get(i,t)>e&&(e=this.get(i,t),r[0]=i);return r}minColumn(t){checkColumnIndex(this,t);let e=this.get(0,t);for(let r=1;r<this.rows;r++)this.get(r,t)<e&&(e=this.get(r,t));return e}minColumnIndex(t){checkColumnIndex(this,t);let e=this.get(0,t),r=[0,t];for(let i=1;i<this.rows;i++)this.get(i,t)<e&&(e=this.get(i,t),r[0]=i);return r}diag(){let t=Math.min(this.rows,this.columns),e=[];for(let r=0;r<t;r++)e.push(this.get(r,r));return e}norm(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"frobenius",e=0;if("max"===t)return this.max();if("frobenius"===t){for(let t=0;t<this.rows;t++)for(let r=0;r<this.columns;r++)e+=this.get(t,r)*this.get(t,r);return Math.sqrt(e)}throw new RangeError("unknown norm type: ".concat(t))}cumulativeSum(){let t=0;for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t+=this.get(e,r),this.set(e,r,t);return this}dot(t){AbstractMatrix.isMatrix(t)&&(t=t.to1DArray());let e=this.to1DArray();if(e.length!==t.length)throw new RangeError("vectors do not have the same size");let r=0;for(let i=0;i<e.length;i++)r+=e[i]*t[i];return r}mmul(t){t=Matrix.checkMatrix(t);let e=this.rows,r=this.columns,i=t.columns,n=new Matrix(e,i),s=new Float64Array(r);for(let o=0;o<i;o++){for(let e=0;e<r;e++)s[e]=t.get(e,o);for(let t=0;t<e;t++){let e=0;for(let i=0;i<r;i++)e+=this.get(t,i)*s[i];n.set(t,o,e)}}return n}strassen2x2(t){t=Matrix.checkMatrix(t);let e=new Matrix(2,2);const r=this.get(0,0),i=t.get(0,0),n=this.get(0,1),s=t.get(0,1),o=this.get(1,0),a=t.get(1,0),h=this.get(1,1),l=t.get(1,1),u=(r+h)*(i+l),c=(o+h)*i,f=r*(s-l),m=h*(a-i),g=(r+n)*l,d=u+m-g+(n-h)*(a+l),p=f+g,w=c+m,x=u-c+f+(o-r)*(i+s);return e.set(0,0,d),e.set(0,1,p),e.set(1,0,w),e.set(1,1,x),e}strassen3x3(t){t=Matrix.checkMatrix(t);let e=new Matrix(3,3);const r=this.get(0,0),i=this.get(0,1),n=this.get(0,2),s=this.get(1,0),o=this.get(1,1),a=this.get(1,2),h=this.get(2,0),l=this.get(2,1),u=this.get(2,2),c=t.get(0,0),f=t.get(0,1),m=t.get(0,2),g=t.get(1,0),d=t.get(1,1),p=t.get(1,2),w=t.get(2,0),x=t.get(2,1),M=t.get(2,2),y=(r-s)*(-f+d),v=(-r+s+o)*(c-f+d),b=(s+o)*(-c+f),S=r*c,A=(-r+h+l)*(c-m+p),E=(-r+h)*(m-p),R=(h+l)*(-c+m),k=(-n+l+u)*(d+w-x),C=(n-u)*(d-x),T=n*w,N=(l+u)*(-w+x),I=(-n+o+a)*(p+w-M),L=(n-a)*(p-M),F=(o+a)*(-w+M),P=S+T+i*g,O=(r+i+n-s-o-l-u)*d+v+b+S+k+T+N,D=S+A+R+(r+i+n-o-a-h-l)*p+T+I+F,V=y+o*(-c+f+g-d-p-w+M)+v+S+T+I+L,_=y+v+b+S+a*x,z=T+I+L+F+s*m,q=S+A+E+l*(-c+m+g-d-p-w+x)+k+C+T,$=k+C+T+N+h*f,U=S+A+E+R+u*M;return e.set(0,0,P),e.set(0,1,O),e.set(0,2,D),e.set(1,0,V),e.set(1,1,_),e.set(1,2,z),e.set(2,0,q),e.set(2,1,$),e.set(2,2,U),e}mmulStrassen(t){t=Matrix.checkMatrix(t);let e=this.clone(),r=e.rows,i=e.columns,n=t.rows,s=t.columns;function o(t,e,r){let i=t.rows,n=t.columns;if(i===e&&n===r)return t;{let i=AbstractMatrix.zeros(e,r);return i=i.setSubMatrix(t,0,0)}}i!==n&&console.warn("Multiplying ".concat(r," x ").concat(i," and ").concat(n," x ").concat(s," matrix: dimensions do not match."));let a=Math.max(r,n),h=Math.max(i,s);return function t(e,r,i,n){if(i<=512||n<=512)return e.mmul(r);i%2==1&&n%2==1?(e=o(e,i+1,n+1),r=o(r,i+1,n+1)):i%2==1?(e=o(e,i+1,n),r=o(r,i+1,n)):n%2==1&&(e=o(e,i,n+1),r=o(r,i,n+1));let s=parseInt(e.rows/2,10),a=parseInt(e.columns/2,10),h=e.subMatrix(0,s-1,0,a-1),l=r.subMatrix(0,s-1,0,a-1),u=e.subMatrix(0,s-1,a,e.columns-1),c=r.subMatrix(0,s-1,a,r.columns-1),f=e.subMatrix(s,e.rows-1,0,a-1),m=r.subMatrix(s,r.rows-1,0,a-1),g=e.subMatrix(s,e.rows-1,a,e.columns-1),d=r.subMatrix(s,r.rows-1,a,r.columns-1),p=t(AbstractMatrix.add(h,g),AbstractMatrix.add(l,d),s,a),w=t(AbstractMatrix.add(f,g),l,s,a),x=t(h,AbstractMatrix.sub(c,d),s,a),M=t(g,AbstractMatrix.sub(m,l),s,a),y=t(AbstractMatrix.add(h,u),d,s,a),v=t(AbstractMatrix.sub(f,h),AbstractMatrix.add(l,c),s,a),b=t(AbstractMatrix.sub(u,g),AbstractMatrix.add(m,d),s,a),S=AbstractMatrix.add(p,M);S.sub(y),S.add(b);let A=AbstractMatrix.add(x,y),E=AbstractMatrix.add(w,M),R=AbstractMatrix.sub(p,w);R.add(x),R.add(v);let k=AbstractMatrix.zeros(2*S.rows,2*S.columns);return(k=(k=(k=(k=k.setSubMatrix(S,0,0)).setSubMatrix(A,S.rows,0)).setSubMatrix(E,0,S.columns)).setSubMatrix(R,S.rows,S.columns)).subMatrix(0,i-1,0,n-1)}(e=o(e,a,h),t=o(t,a,h),a,h)}scaleRows(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let i=new Matrix(this.rows,this.columns);for(let t=0;t<this.rows;t++){const n=this.getRow(t);rescale(n,{min:e,max:r,output:n}),i.setRow(t,n)}return i}scaleColumns(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if("object"!=typeof t)throw new TypeError("options must be an object");const{min:e=0,max:r=1}=t;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(r))throw new TypeError("max must be a number");if(e>=r)throw new RangeError("min must be smaller than max");let i=new Matrix(this.rows,this.columns);for(let t=0;t<this.columns;t++){const n=this.getColumn(t);rescale(n,{min:e,max:r,output:n}),i.setColumn(t,n)}return i}flipRows(){const t=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let r=0;r<t;r++){let t=this.get(e,r),i=this.get(e,this.columns-1-r);this.set(e,r,i),this.set(e,this.columns-1-r,t)}return this}flipColumns(){const t=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let r=0;r<t;r++){let t=this.get(r,e),i=this.get(this.rows-1-r,e);this.set(r,e,i),this.set(this.rows-1-r,e,t)}return this}kroneckerProduct(t){t=Matrix.checkMatrix(t);let e=this.rows,r=this.columns,i=t.rows,n=t.columns,s=new Matrix(e*i,r*n);for(let o=0;o<e;o++)for(let e=0;e<r;e++)for(let r=0;r<i;r++)for(let a=0;a<n;a++)s.set(i*o+r,n*e+a,this.get(o,e)*t.get(r,a));return s}transpose(){let t=new Matrix(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(r,e,this.get(e,r));return t}sortRows(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:compareNumbers;for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(t));return this}sortColumns(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:compareNumbers;for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(t));return this}subMatrix(t,e,r,i){checkRange(this,t,e,r,i);let n=new Matrix(e-t+1,i-r+1);for(let s=t;s<=e;s++)for(let e=r;e<=i;e++)n.set(s-t,e-r,this.get(s,e));return n}subMatrixRow(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.columns-1),e>r||e<0||e>=this.columns||r<0||r>=this.columns)throw new RangeError("Argument out of range");let i=new Matrix(t.length,r-e+1);for(let n=0;n<t.length;n++)for(let s=e;s<=r;s++){if(t[n]<0||t[n]>=this.rows)throw new RangeError("Row index out of range: ".concat(t[n]));i.set(n,s-e,this.get(t[n],s))}return i}subMatrixColumn(t,e,r){if(void 0===e&&(e=0),void 0===r&&(r=this.rows-1),e>r||e<0||e>=this.rows||r<0||r>=this.rows)throw new RangeError("Argument out of range");let i=new Matrix(r-e+1,t.length);for(let n=0;n<t.length;n++)for(let s=e;s<=r;s++){if(t[n]<0||t[n]>=this.columns)throw new RangeError("Column index out of range: ".concat(t[n]));i.set(s-e,n,this.get(s,t[n]))}return i}setSubMatrix(t,e,r){checkRange(this,e,e+(t=Matrix.checkMatrix(t)).rows-1,r,r+t.columns-1);for(let i=0;i<t.rows;i++)for(let n=0;n<t.columns;n++)this.set(e+i,r+n,t.get(i,n));return this}selection(t,e){let r=checkIndices(this,t,e),i=new Matrix(t.length,e.length);for(let t=0;t<r.row.length;t++){let e=r.row[t];for(let n=0;n<r.column.length;n++){let s=r.column[n];i.set(t,n,this.get(e,s))}}return i}trace(){let t=Math.min(this.rows,this.columns),e=0;for(let r=0;r<t;r++)e+=this.get(r,r);return e}clone(){let t=new Matrix(this.rows,this.columns);for(let e=0;e<this.rows;e++)for(let r=0;r<this.columns;r++)t.set(e,r,this.get(e,r));return t}sum(t){switch(t){case"row":return sumByRow(this);case"column":return sumByColumn(this);case void 0:return sumAll(this);default:throw new Error("invalid option: ".concat(t))}}product(t){switch(t){case"row":return productByRow(this);case"column":return productByColumn(this);case void 0:return productAll(this);default:throw new Error("invalid option: ".concat(t))}}mean(t){const e=this.sum(t);switch(t){case"row":for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e;case"column":for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e;case void 0:return e/this.size;default:throw new Error("invalid option: ".concat(t))}}variance(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{unbiased:r=!0,mean:i=this.mean(t)}=e;if("boolean"!=typeof r)throw new TypeError("unbiased must be a boolean");switch(t){case"row":if(!Array.isArray(i))throw new TypeError("mean must be an array");return varianceByRow(this,r,i);case"column":if(!Array.isArray(i))throw new TypeError("mean must be an array");return varianceByColumn(this,r,i);case void 0:if("number"!=typeof i)throw new TypeError("mean must be a number");return varianceAll(this,r,i);default:throw new Error("invalid option: ".concat(t))}}standardDeviation(t,e){"object"==typeof t&&(e=t,t=void 0);const r=this.variance(t,e);if(void 0===t)return Math.sqrt(r);for(let t=0;t<r.length;t++)r[t]=Math.sqrt(r[t]);return r}center(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");const{center:r=this.mean(t)}=e;switch(t){case"row":if(!Array.isArray(r))throw new TypeError("center must be an array");return centerByRow(this,r),this;case"column":if(!Array.isArray(r))throw new TypeError("center must be an array");return centerByColumn(this,r),this;case void 0:if("number"!=typeof r)throw new TypeError("center must be a number");return centerAll(this,r),this;default:throw new Error("invalid option: ".concat(t))}}scale(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"==typeof t&&(e=t,t=void 0),"object"!=typeof e)throw new TypeError("options must be an object");let r=e.scale;switch(t){case"row":if(void 0===r)r=getScaleByRow(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return scaleByRow(this,r),this;case"column":if(void 0===r)r=getScaleByColumn(this);else if(!Array.isArray(r))throw new TypeError("scale must be an array");return scaleByColumn(this,r),this;case void 0:if(void 0===r)r=getScaleAll(this);else if("number"!=typeof r)throw new TypeError("scale must be a number");return scaleAll(this,r),this;default:throw new Error("invalid option: ".concat(t))}}}function compareNumbers(t,e){return t-e}AbstractMatrix.prototype.klass="Matrix","undefined"!=typeof Symbol&&(AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")]=inspectMatrix),AbstractMatrix.random=AbstractMatrix.rand,AbstractMatrix.randomInt=AbstractMatrix.randInt,AbstractMatrix.diagonal=AbstractMatrix.diag,AbstractMatrix.prototype.diagonal=AbstractMatrix.prototype.diag,AbstractMatrix.identity=AbstractMatrix.eye,AbstractMatrix.prototype.negate=AbstractMatrix.prototype.neg,AbstractMatrix.prototype.tensorProduct=AbstractMatrix.prototype.kroneckerProduct;class Matrix extends AbstractMatrix{constructor(t,e){if(super(),Matrix.isMatrix(t))return t.clone();if(Number.isInteger(t)&&t>0){if(this.data=[],!(Number.isInteger(e)&&e>0))throw new TypeError("nColumns must be a positive integer");for(let r=0;r<t;r++)this.data.push(new Float64Array(e))}else{if(!Array.isArray(t))throw new TypeError("First argument must be a positive number or an array");{const r=t;if(t=r.length,"number"!=typeof(e=r[0].length)||0===e)throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let i=0;i<t;i++){if(r[i].length!==e)throw new RangeError("Inconsistent array dimensions");this.data.push(Float64Array.from(r[i]))}}}return this.rows=t,this.columns=e,this}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}removeRow(t){if(checkRowIndex(this,t),1===this.rows)throw new RangeError("A matrix cannot have less than one row");return this.data.splice(t,1),this.rows-=1,this}addRow(t,e){return void 0===e&&(e=t,t=this.rows),checkRowIndex(this,t,!0),e=Float64Array.from(checkRowVector(this,e)),this.data.splice(t,0,e),this.rows+=1,this}removeColumn(t){if(checkColumnIndex(this,t),1===this.columns)throw new RangeError("A matrix cannot have less than one column");for(let e=0;e<this.rows;e++){const r=new Float64Array(this.columns-1);for(let i=0;i<t;i++)r[i]=this.data[e][i];for(let i=t+1;i<this.columns;i++)r[i-1]=this.data[e][i];this.data[e]=r}return this.columns-=1,this}addColumn(t,e){void 0===e&&(e=t,t=this.columns),checkColumnIndex(this,t,!0),e=checkColumnVector(this,e);for(let r=0;r<this.rows;r++){const i=new Float64Array(this.columns+1);let n=0;for(;n<t;n++)i[n]=this.data[r][n];for(i[n++]=e[r];n<this.columns+1;n++)i[n]=this.data[r][n-1];this.data[r]=i}return this.columns+=1,this}}installMathOperations(AbstractMatrix,Matrix);class BaseView extends AbstractMatrix{constructor(t,e,r){super(),this.matrix=t,this.rows=e,this.columns=r}}class MatrixColumnView extends BaseView{constructor(t,e){checkColumnIndex(t,e),super(t,t.rows,1),this.column=e}set(t,e,r){return this.matrix.set(t,this.column,r),this}get(t){return this.matrix.get(t,this.column)}}class MatrixColumnSelectionView extends BaseView{constructor(t,e){e=checkColumnIndices(t,e),super(t,t.rows,e.length),this.columnIndices=e}set(t,e,r){return this.matrix.set(t,this.columnIndices[e],r),this}get(t,e){return this.matrix.get(t,this.columnIndices[e])}}class MatrixFlipColumnView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(t,this.columns-e-1,r),this}get(t,e){return this.matrix.get(t,this.columns-e-1)}}class MatrixFlipRowView extends BaseView{constructor(t){super(t,t.rows,t.columns)}set(t,e,r){return this.matrix.set(this.rows-t-1,e,r),this}get(t,e){return this.matrix.get(this.rows-t-1,e)}}class MatrixRowView extends BaseView{constructor(t,e){checkRowIndex(t,e),super(t,1,t.columns),this.row=e}set(t,e,r){return this.matrix.set(this.row,e,r),this}get(t,e){return this.matrix.get(this.row,e)}}class MatrixRowSelectionView extends BaseView{constructor(t,e){super(t,(e=checkRowIndices(t,e)).length,t.columns),this.rowIndices=e}set(t,e,r){return this.matrix.set(this.rowIndices[t],e,r),this}get(t,e){return this.matrix.get(this.rowIndices[t],e)}}class MatrixSelectionView extends BaseView{constructor(t,e,r){let i=checkIndices(t,e,r);super(t,i.row.length,i.column.length),this.rowIndices=i.row,this.columnIndices=i.column}set(t,e,r){return this.matrix.set(this.rowIndices[t],this.columnIndices[e],r),this}get(t,e){return this.matrix.get(this.rowIndices[t],this.columnIndices[e])}}class MatrixSubView extends BaseView{constructor(t,e,r,i,n){checkRange(t,e,r,i,n),super(t,r-e+1,n-i+1),this.startRow=e,this.startColumn=i}set(t,e,r){return this.matrix.set(this.startRow+t,this.startColumn+e,r),this}get(t,e){return this.matrix.get(this.startRow+t,this.startColumn+e)}}class MatrixTransposeView extends BaseView{constructor(t){super(t,t.columns,t.rows)}set(t,e,r){return this.matrix.set(e,t,r),this}get(t,e){return this.matrix.get(e,t)}}class WrapperMatrix1D extends AbstractMatrix{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{rows:r=1}=e;if(t.length%r!=0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=r,this.columns=t.length/r,this.data=t}set(t,e,r){let i=this._calculateIndex(t,e);return this.data[i]=r,this}get(t,e){let r=this._calculateIndex(t,e);return this.data[r]}_calculateIndex(t,e){return t*this.columns+e}}class WrapperMatrix2D extends AbstractMatrix{constructor(t){super(),this.data=t,this.rows=t.length,this.columns=t[0].length}set(t,e,r){return this.data[t][e]=r,this}get(t,e){return this.data[t][e]}}function wrap(t,e){if(Array.isArray(t))return t[0]&&Array.isArray(t[0])?new WrapperMatrix2D(t):new WrapperMatrix1D(t,e);throw new Error("the argument is not an array")}class LuDecomposition{constructor(t){let e,r,i,n,s,o,a,h,l,u=(t=WrapperMatrix2D.checkMatrix(t)).clone(),c=u.rows,f=u.columns,m=new Float64Array(c),g=1;for(e=0;e<c;e++)m[e]=e;for(h=new Float64Array(c),r=0;r<f;r++){for(e=0;e<c;e++)h[e]=u.get(e,r);for(e=0;e<c;e++){for(l=Math.min(e,r),s=0,i=0;i<l;i++)s+=u.get(e,i)*h[i];h[e]-=s,u.set(e,r,h[e])}for(n=r,e=r+1;e<c;e++)Math.abs(h[e])>Math.abs(h[n])&&(n=e);if(n!==r){for(i=0;i<f;i++)o=u.get(n,i),u.set(n,i,u.get(r,i)),u.set(r,i,o);a=m[n],m[n]=m[r],m[r]=a,g=-g}if(r<c&&0!==u.get(r,r))for(e=r+1;e<c;e++)u.set(e,r,u.get(e,r)/u.get(r,r))}this.LU=u,this.pivotVector=m,this.pivotSign=g}isSingular(){let t=this.LU,e=t.columns;for(let r=0;r<e;r++)if(0===t.get(r,r))return!0;return!1}solve(t){t=Matrix.checkMatrix(t);let e=this.LU;if(e.rows!==t.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let r,i,n,s=t.columns,o=t.subMatrixRow(this.pivotVector,0,s-1),a=e.columns;for(n=0;n<a;n++)for(r=n+1;r<a;r++)for(i=0;i<s;i++)o.set(r,i,o.get(r,i)-o.get(n,i)*e.get(r,n));for(n=a-1;n>=0;n--){for(i=0;i<s;i++)o.set(n,i,o.get(n,i)/e.get(n,n));for(r=0;r<n;r++)for(i=0;i<s;i++)o.set(r,i,o.get(r,i)-o.get(n,i)*e.get(r,n))}return o}get determinant(){let t=this.LU;if(!t.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,r=t.columns;for(let i=0;i<r;i++)e*=t.get(i,i);return e}get lowerTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,i=new Matrix(e,r);for(let n=0;n<e;n++)for(let e=0;e<r;e++)n>e?i.set(n,e,t.get(n,e)):n===e?i.set(n,e,1):i.set(n,e,0);return i}get upperTriangularMatrix(){let t=this.LU,e=t.rows,r=t.columns,i=new Matrix(e,r);for(let n=0;n<e;n++)for(let e=0;e<r;e++)n<=e?i.set(n,e,t.get(n,e)):i.set(n,e,0);return i}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function hypotenuse(t,e){let r=0;return Math.abs(t)>Math.abs(e)?(r=e/t,Math.abs(t)*Math.sqrt(1+r*r)):0!==e?(r=t/e,Math.abs(e)*Math.sqrt(1+r*r)):0}class QrDecomposition{constructor(t){let e,r,i,n,s=(t=WrapperMatrix2D.checkMatrix(t)).clone(),o=t.rows,a=t.columns,h=new Float64Array(a);for(i=0;i<a;i++){let t=0;for(e=i;e<o;e++)t=hypotenuse(t,s.get(e,i));if(0!==t){for(s.get(i,i)<0&&(t=-t),e=i;e<o;e++)s.set(e,i,s.get(e,i)/t);for(s.set(i,i,s.get(i,i)+1),r=i+1;r<a;r++){for(n=0,e=i;e<o;e++)n+=s.get(e,i)*s.get(e,r);for(n=-n/s.get(i,i),e=i;e<o;e++)s.set(e,r,s.get(e,r)+n*s.get(e,i))}}h[i]=-t}this.QR=s,this.Rdiag=h}solve(t){t=Matrix.checkMatrix(t);let e=this.QR,r=e.rows;if(t.rows!==r)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let i,n,s,o,a=t.columns,h=t.clone(),l=e.columns;for(s=0;s<l;s++)for(n=0;n<a;n++){for(o=0,i=s;i<r;i++)o+=e.get(i,s)*h.get(i,n);for(o=-o/e.get(s,s),i=s;i<r;i++)h.set(i,n,h.get(i,n)+o*e.get(i,s))}for(s=l-1;s>=0;s--){for(n=0;n<a;n++)h.set(s,n,h.get(s,n)/this.Rdiag[s]);for(i=0;i<s;i++)for(n=0;n<a;n++)h.set(i,n,h.get(i,n)-h.get(s,n)*e.get(i,s))}return h.subMatrix(0,l-1,0,a-1)}isFullRank(){let t=this.QR.columns;for(let e=0;e<t;e++)if(0===this.Rdiag[e])return!1;return!0}get upperTriangularMatrix(){let t,e,r=this.QR,i=r.columns,n=new Matrix(i,i);for(t=0;t<i;t++)for(e=0;e<i;e++)t<e?n.set(t,e,r.get(t,e)):t===e?n.set(t,e,this.Rdiag[t]):n.set(t,e,0);return n}get orthogonalMatrix(){let t,e,r,i,n=this.QR,s=n.rows,o=n.columns,a=new Matrix(s,o);for(r=o-1;r>=0;r--){for(t=0;t<s;t++)a.set(t,r,0);for(a.set(r,r,1),e=r;e<o;e++)if(0!==n.get(r,r)){for(i=0,t=r;t<s;t++)i+=n.get(t,r)*a.get(t,e);for(i=-i/n.get(r,r),t=r;t<s;t++)a.set(t,e,a.get(t,e)+i*n.get(t,r))}}return a}}class SingularValueDecomposition{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=(t=WrapperMatrix2D.checkMatrix(t)).rows,i=t.columns;const{computeLeftSingularVectors:n=!0,computeRightSingularVectors:s=!0,autoTranspose:o=!1}=e;let a,h=Boolean(n),l=Boolean(s),u=!1;if(r<i)if(o){r=(a=t.transpose()).rows,i=a.columns,u=!0;let e=h;h=l,l=e}else a=t.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else a=t.clone();let c=Math.min(r,i),f=Math.min(r+1,i),m=new Float64Array(f),g=new Matrix(r,c),d=new Matrix(i,i),p=new Float64Array(i),w=new Float64Array(r),x=new Float64Array(f);for(let t=0;t<f;t++)x[t]=t;let M=Math.min(r-1,i),y=Math.max(0,Math.min(i-2,r)),v=Math.max(M,y);for(let t=0;t<v;t++){if(t<M){m[t]=0;for(let e=t;e<r;e++)m[t]=hypotenuse(m[t],a.get(e,t));if(0!==m[t]){a.get(t,t)<0&&(m[t]=-m[t]);for(let e=t;e<r;e++)a.set(e,t,a.get(e,t)/m[t]);a.set(t,t,a.get(t,t)+1)}m[t]=-m[t]}for(let e=t+1;e<i;e++){if(t<M&&0!==m[t]){let i=0;for(let n=t;n<r;n++)i+=a.get(n,t)*a.get(n,e);i=-i/a.get(t,t);for(let n=t;n<r;n++)a.set(n,e,a.get(n,e)+i*a.get(n,t))}p[e]=a.get(t,e)}if(h&&t<M)for(let e=t;e<r;e++)g.set(e,t,a.get(e,t));if(t<y){p[t]=0;for(let e=t+1;e<i;e++)p[t]=hypotenuse(p[t],p[e]);if(0!==p[t]){p[t+1]<0&&(p[t]=0-p[t]);for(let e=t+1;e<i;e++)p[e]/=p[t];p[t+1]+=1}if(p[t]=-p[t],t+1<r&&0!==p[t]){for(let e=t+1;e<r;e++)w[e]=0;for(let e=t+1;e<r;e++)for(let r=t+1;r<i;r++)w[e]+=p[r]*a.get(e,r);for(let e=t+1;e<i;e++){let i=-p[e]/p[t+1];for(let n=t+1;n<r;n++)a.set(n,e,a.get(n,e)+i*w[n])}}if(l)for(let e=t+1;e<i;e++)d.set(e,t,p[e])}}let b=Math.min(i,r+1);if(M<i&&(m[M]=a.get(M,M)),r<b&&(m[b-1]=0),y+1<b&&(p[y]=a.get(y,b-1)),p[b-1]=0,h){for(let t=M;t<c;t++){for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}for(let t=M-1;t>=0;t--)if(0!==m[t]){for(let e=t+1;e<c;e++){let i=0;for(let n=t;n<r;n++)i+=g.get(n,t)*g.get(n,e);i=-i/g.get(t,t);for(let n=t;n<r;n++)g.set(n,e,g.get(n,e)+i*g.get(n,t))}for(let e=t;e<r;e++)g.set(e,t,-g.get(e,t));g.set(t,t,1+g.get(t,t));for(let e=0;e<t-1;e++)g.set(e,t,0)}else{for(let e=0;e<r;e++)g.set(e,t,0);g.set(t,t,1)}}if(l)for(let t=i-1;t>=0;t--){if(t<y&&0!==p[t])for(let e=t+1;e<i;e++){let r=0;for(let n=t+1;n<i;n++)r+=d.get(n,t)*d.get(n,e);r=-r/d.get(t+1,t);for(let n=t+1;n<i;n++)d.set(n,e,d.get(n,e)+r*d.get(n,t))}for(let e=0;e<i;e++)d.set(e,t,0);d.set(t,t,1)}let S=b-1,A=Number.EPSILON;for(;b>0;){let t,e;for(t=b-2;t>=-1&&-1!==t;t--){const e=Number.MIN_VALUE+A*Math.abs(m[t]+Math.abs(m[t+1]));if(Math.abs(p[t])<=e||Number.isNaN(p[t])){p[t]=0;break}}if(t===b-2)e=4;else{let r;for(r=b-1;r>=t&&r!==t;r--){let e=(r!==b?Math.abs(p[r]):0)+(r!==t+1?Math.abs(p[r-1]):0);if(Math.abs(m[r])<=A*e){m[r]=0;break}}r===t?e=3:r===b-1?e=1:(e=2,t=r)}switch(t++,e){case 1:{let e=p[b-2];p[b-2]=0;for(let r=b-2;r>=t;r--){let n=hypotenuse(m[r],e),s=m[r]/n,o=e/n;if(m[r]=n,r!==t&&(e=-o*p[r-1],p[r-1]=s*p[r-1]),l)for(let t=0;t<i;t++)n=s*d.get(t,r)+o*d.get(t,b-1),d.set(t,b-1,-o*d.get(t,r)+s*d.get(t,b-1)),d.set(t,r,n)}break}case 2:{let e=p[t-1];p[t-1]=0;for(let i=t;i<b;i++){let n=hypotenuse(m[i],e),s=m[i]/n,o=e/n;if(m[i]=n,e=-o*p[i],p[i]=s*p[i],h)for(let e=0;e<r;e++)n=s*g.get(e,i)+o*g.get(e,t-1),g.set(e,t-1,-o*g.get(e,i)+s*g.get(e,t-1)),g.set(e,i,n)}break}case 3:{const e=Math.max(Math.abs(m[b-1]),Math.abs(m[b-2]),Math.abs(p[b-2]),Math.abs(m[t]),Math.abs(p[t])),n=m[b-1]/e,s=m[b-2]/e,o=p[b-2]/e,a=m[t]/e,u=p[t]/e,c=((s+n)*(s-n)+o*o)/2,f=n*o*(n*o);let w=0;0===c&&0===f||(w=f/(c+(w=c<0?0-Math.sqrt(c*c+f):Math.sqrt(c*c+f))));let x=(a+n)*(a-n)+w,M=a*u;for(let e=t;e<b-1;e++){let n=hypotenuse(x,M);0===n&&(n=Number.MIN_VALUE);let s=x/n,o=M/n;if(e!==t&&(p[e-1]=n),x=s*m[e]+o*p[e],p[e]=s*p[e]-o*m[e],M=o*m[e+1],m[e+1]=s*m[e+1],l)for(let t=0;t<i;t++)n=s*d.get(t,e)+o*d.get(t,e+1),d.set(t,e+1,-o*d.get(t,e)+s*d.get(t,e+1)),d.set(t,e,n);if(0===(n=hypotenuse(x,M))&&(n=Number.MIN_VALUE),s=x/n,o=M/n,m[e]=n,x=s*p[e]+o*m[e+1],m[e+1]=-o*p[e]+s*m[e+1],M=o*p[e+1],p[e+1]=s*p[e+1],h&&e<r-1)for(let t=0;t<r;t++)n=s*g.get(t,e)+o*g.get(t,e+1),g.set(t,e+1,-o*g.get(t,e)+s*g.get(t,e+1)),g.set(t,e,n)}p[b-2]=x;break}case 4:if(m[t]<=0&&(m[t]=m[t]<0?-m[t]:0,l))for(let e=0;e<=S;e++)d.set(e,t,-d.get(e,t));for(;t<S&&!(m[t]>=m[t+1]);){let e=m[t];if(m[t]=m[t+1],m[t+1]=e,l&&t<i-1)for(let r=0;r<i;r++)e=d.get(r,t+1),d.set(r,t+1,d.get(r,t)),d.set(r,t,e);if(h&&t<r-1)for(let i=0;i<r;i++)e=g.get(i,t+1),g.set(i,t+1,g.get(i,t)),g.set(i,t,e);t++}b--}}if(u){let t=d;d=g,g=t}this.m=r,this.n=i,this.s=m,this.U=g,this.V=d}solve(t){let e=t,r=this.threshold,i=this.s.length,n=Matrix.zeros(i,i);for(let t=0;t<i;t++)Math.abs(this.s[t])<=r?n.set(t,t,0):n.set(t,t,1/this.s[t]);let s=this.U,o=this.rightSingularVectors,a=o.mmul(n),h=o.rows,l=s.rows,u=Matrix.zeros(h,l);for(let t=0;t<h;t++)for(let e=0;e<l;e++){let r=0;for(let n=0;n<i;n++)r+=a.get(t,n)*s.get(e,n);u.set(t,e,r)}return u.mmul(e)}solveForDiagonal(t){return this.solve(Matrix.diag(t))}inverse(){let t=this.V,e=this.threshold,r=t.rows,i=t.columns,n=new Matrix(r,this.s.length);for(let s=0;s<r;s++)for(let r=0;r<i;r++)Math.abs(this.s[r])>e&&n.set(s,r,t.get(s,r)/this.s[r]);let s=this.U,o=s.rows,a=s.columns,h=new Matrix(r,o);for(let t=0;t<r;t++)for(let e=0;e<o;e++){let r=0;for(let i=0;i<a;i++)r+=n.get(t,i)*s.get(e,i);h.set(t,e,r)}return h}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let t=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,r=this.s;for(let i=0,n=r.length;i<n;i++)r[i]>t&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix.diag(this.s)}}function inverse(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t=WrapperMatrix2D.checkMatrix(t),e?new SingularValueDecomposition(t).inverse():solve(t,Matrix.eye(t.rows))}function solve(t,e){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return t=WrapperMatrix2D.checkMatrix(t),e=WrapperMatrix2D.checkMatrix(e),r?new SingularValueDecomposition(t).solve(e):t.isSquare()?new LuDecomposition(t).solve(e):new QrDecomposition(t).solve(e)}function determinant(t){if((t=Matrix.checkMatrix(t)).isSquare()){let e,r,i,n;if(2===t.columns)return e=t.get(0,0),r=t.get(0,1),i=t.get(1,0),e*(n=t.get(1,1))-r*i;if(3===t.columns){let n,s,o;return n=new MatrixSelectionView(t,[1,2],[1,2]),s=new MatrixSelectionView(t,[1,2],[0,2]),o=new MatrixSelectionView(t,[1,2],[0,1]),e=t.get(0,0),r=t.get(0,1),i=t.get(0,2),e*determinant(n)-r*determinant(s)+i*determinant(o)}return new LuDecomposition(t).determinant}throw Error("determinant can only be calculated for a square matrix")}function xrange(t,e){let r=[];for(let i=0;i<t;i++)i!==e&&r.push(i);return r}function dependenciesOneRow(t,e,r){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-9;if(t>(arguments.length>4&&void 0!==arguments[4]?arguments[4]:1e-9))return new Array(e.rows+1).fill(0);{let t=e.addRow(r,[0]);for(let e=0;e<t.rows;e++)Math.abs(t.get(e,0))<i&&t.set(e,0,0);return t.to1DArray()}}function linearDependencies(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{thresholdValue:r=1e-9,thresholdError:i=1e-9}=e;let n=(t=Matrix.checkMatrix(t)).rows,s=new Matrix(n,n);for(let e=0;e<n;e++){let o=Matrix.columnVector(t.getRow(e)),a=t.subMatrixRow(xrange(n,e)).transpose(),h=new SingularValueDecomposition(a).solve(o),l=Matrix.sub(o,a.mmul(h)).abs().max();s.setRow(e,dependenciesOneRow(l,h,e,r,i))}return s}function pseudoInverse(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.EPSILON;t=Matrix.checkMatrix(t);let r=new SingularValueDecomposition(t,{autoTranspose:!0}),i=r.leftSingularVectors,n=r.rightSingularVectors,s=r.diagonal;for(let t=0;t<s.length;t++)Math.abs(s[t])>e?s[t]=1/s[t]:s[t]=0;return n.mmul(Matrix.diag(s).mmul(i.transpose()))}function covariance(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t=Matrix.checkMatrix(t);let i=!1;if("object"!=typeof e||Matrix.isMatrix(e)||Array.isArray(e)?e=Matrix.checkMatrix(e):(r=e,e=t,i=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:n=!0}=r;n&&(t=t.center("column"),i||(e=e.center("column")));const s=t.transpose().mmul(e);for(let e=0;e<s.rows;e++)for(let r=0;r<s.columns;r++)s.set(e,r,s.get(e,r)*(1/(t.rows-1)));return s}function correlation(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t=Matrix.checkMatrix(t);let i=!1;if("object"!=typeof e||Matrix.isMatrix(e)||Array.isArray(e)?e=Matrix.checkMatrix(e):(r=e,e=t,i=!0),t.rows!==e.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:n=!0,scale:s=!0}=r;n&&(t.center("column"),i||e.center("column")),s&&(t.scale("column"),i||e.scale("column"));const o=t.standardDeviation("column",{unbiased:!0}),a=i?o:e.standardDeviation("column",{unbiased:!0}),h=t.transpose().mmul(e);for(let e=0;e<h.rows;e++)for(let r=0;r<h.columns;r++)h.set(e,r,h.get(e,r)*(1/(o[e]*a[r]))*(1/(t.rows-1)));return h}class EigenvalueDecomposition{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{assumeSymmetric:r=!1}=e;if(!(t=WrapperMatrix2D.checkMatrix(t)).isSquare())throw new Error("Matrix is not a square matrix");let i,n,s=t.columns,o=new Matrix(s,s),a=new Float64Array(s),h=new Float64Array(s),l=t,u=!1;if(u=!!r||t.isSymmetric()){for(i=0;i<s;i++)for(n=0;n<s;n++)o.set(i,n,l.get(i,n));tred2(s,h,a,o),tql2(s,h,a,o)}else{let t=new Matrix(s,s),e=new Float64Array(s);for(n=0;n<s;n++)for(i=0;i<s;i++)t.set(i,n,l.get(i,n));orthes(s,t,e,o),hqr2(s,h,a,o,t)}this.n=s,this.e=h,this.d=a,this.V=o}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let t,e,r=this.n,i=this.e,n=this.d,s=new Matrix(r,r);for(t=0;t<r;t++){for(e=0;e<r;e++)s.set(t,e,0);s.set(t,t,n[t]),i[t]>0?s.set(t,t+1,i[t]):i[t]<0&&s.set(t,t-1,i[t])}return s}}function tred2(t,e,r,i){let n,s,o,a,h,l,u,c;for(h=0;h<t;h++)r[h]=i.get(t-1,h);for(a=t-1;a>0;a--){for(c=0,o=0,l=0;l<a;l++)c+=Math.abs(r[l]);if(0===c)for(e[a]=r[a-1],h=0;h<a;h++)r[h]=i.get(a-1,h),i.set(a,h,0),i.set(h,a,0);else{for(l=0;l<a;l++)r[l]/=c,o+=r[l]*r[l];for(n=r[a-1],s=Math.sqrt(o),n>0&&(s=-s),e[a]=c*s,o-=n*s,r[a-1]=n-s,h=0;h<a;h++)e[h]=0;for(h=0;h<a;h++){for(n=r[h],i.set(h,a,n),s=e[h]+i.get(h,h)*n,l=h+1;l<=a-1;l++)s+=i.get(l,h)*r[l],e[l]+=i.get(l,h)*n;e[h]=s}for(n=0,h=0;h<a;h++)e[h]/=o,n+=e[h]*r[h];for(u=n/(o+o),h=0;h<a;h++)e[h]-=u*r[h];for(h=0;h<a;h++){for(n=r[h],s=e[h],l=h;l<=a-1;l++)i.set(l,h,i.get(l,h)-(n*e[l]+s*r[l]));r[h]=i.get(a-1,h),i.set(a,h,0)}}r[a]=o}for(a=0;a<t-1;a++){if(i.set(t-1,a,i.get(a,a)),i.set(a,a,1),0!==(o=r[a+1])){for(l=0;l<=a;l++)r[l]=i.get(l,a+1)/o;for(h=0;h<=a;h++){for(s=0,l=0;l<=a;l++)s+=i.get(l,a+1)*i.get(l,h);for(l=0;l<=a;l++)i.set(l,h,i.get(l,h)-s*r[l])}}for(l=0;l<=a;l++)i.set(l,a+1,0)}for(h=0;h<t;h++)r[h]=i.get(t-1,h),i.set(t-1,h,0);i.set(t-1,t-1,1),e[0]=0}function tql2(t,e,r,i){let n,s,o,a,h,l,u,c,f,m,g,d,p,w,x,M;for(o=1;o<t;o++)e[o-1]=e[o];e[t-1]=0;let y=0,v=0,b=Number.EPSILON;for(l=0;l<t;l++){for(v=Math.max(v,Math.abs(r[l])+Math.abs(e[l])),u=l;u<t&&!(Math.abs(e[u])<=b*v);)u++;if(u>l)do{for(n=r[l],f=hypotenuse(c=(r[l+1]-n)/(2*e[l]),1),c<0&&(f=-f),r[l]=e[l]/(c+f),r[l+1]=e[l]*(c+f),m=r[l+1],s=n-r[l],o=l+2;o<t;o++)r[o]-=s;for(y+=s,c=r[u],d=g=1,p=g,w=e[l+1],x=0,M=0,o=u-1;o>=l;o--)for(p=d,d=g,M=x,n=g*e[o],s=g*c,f=hypotenuse(c,e[o]),e[o+1]=x*f,x=e[o]/f,c=(g=c/f)*r[o]-x*n,r[o+1]=s+x*(g*n+x*r[o]),h=0;h<t;h++)s=i.get(h,o+1),i.set(h,o+1,x*i.get(h,o)+g*s),i.set(h,o,g*i.get(h,o)-x*s);c=-x*M*p*w*e[l]/m,e[l]=x*c,r[l]=g*c}while(Math.abs(e[l])>b*v);r[l]=r[l]+y,e[l]=0}for(o=0;o<t-1;o++){for(h=o,c=r[o],a=o+1;a<t;a++)r[a]<c&&(h=a,c=r[a]);if(h!==o)for(r[h]=r[o],r[o]=c,a=0;a<t;a++)c=i.get(a,o),i.set(a,o,i.get(a,h)),i.set(a,h,c)}}function orthes(t,e,r,i){let n,s,o,a,h,l,u,c=t-1;for(l=1;l<=c-1;l++){for(u=0,a=l;a<=c;a++)u+=Math.abs(e.get(a,l-1));if(0!==u){for(o=0,a=c;a>=l;a--)r[a]=e.get(a,l-1)/u,o+=r[a]*r[a];for(s=Math.sqrt(o),r[l]>0&&(s=-s),o-=r[l]*s,r[l]=r[l]-s,h=l;h<t;h++){for(n=0,a=c;a>=l;a--)n+=r[a]*e.get(a,h);for(n/=o,a=l;a<=c;a++)e.set(a,h,e.get(a,h)-n*r[a])}for(a=0;a<=c;a++){for(n=0,h=c;h>=l;h--)n+=r[h]*e.get(a,h);for(n/=o,h=l;h<=c;h++)e.set(a,h,e.get(a,h)-n*r[h])}r[l]=u*r[l],e.set(l,l-1,u*s)}}for(a=0;a<t;a++)for(h=0;h<t;h++)i.set(a,h,a===h?1:0);for(l=c-1;l>=1;l--)if(0!==e.get(l,l-1)){for(a=l+1;a<=c;a++)r[a]=e.get(a,l-1);for(h=l;h<=c;h++){for(s=0,a=l;a<=c;a++)s+=r[a]*i.get(a,h);for(s=s/r[l]/e.get(l,l-1),a=l;a<=c;a++)i.set(a,h,i.get(a,h)+s*r[a])}}}function hqr2(t,e,r,i,n){let s,o,a,h,l,u,c,f,m,g,d,p,w,x,M,y=t-1,v=t-1,b=Number.EPSILON,S=0,A=0,E=0,R=0,k=0,C=0,T=0,N=0;for(s=0;s<t;s++)for((s<0||s>v)&&(r[s]=n.get(s,s),e[s]=0),o=Math.max(s-1,0);o<t;o++)A+=Math.abs(n.get(s,o));for(;y>=0;){for(h=y;h>0&&(0===(C=Math.abs(n.get(h-1,h-1))+Math.abs(n.get(h,h)))&&(C=A),!(Math.abs(n.get(h,h-1))<b*C));)h--;if(h===y)n.set(y,y,n.get(y,y)+S),r[y]=n.get(y,y),e[y]=0,y--,N=0;else if(h===y-1){if(c=n.get(y,y-1)*n.get(y-1,y),R=(E=(n.get(y-1,y-1)-n.get(y,y))/2)*E+c,T=Math.sqrt(Math.abs(R)),n.set(y,y,n.get(y,y)+S),n.set(y-1,y-1,n.get(y-1,y-1)+S),f=n.get(y,y),R>=0){for(T=E>=0?E+T:E-T,r[y-1]=f+T,r[y]=r[y-1],0!==T&&(r[y]=f-c/T),e[y-1]=0,e[y]=0,E=(f=n.get(y,y-1))/(C=Math.abs(f)+Math.abs(T)),R=T/C,E/=k=Math.sqrt(E*E+R*R),R/=k,o=y-1;o<t;o++)T=n.get(y-1,o),n.set(y-1,o,R*T+E*n.get(y,o)),n.set(y,o,R*n.get(y,o)-E*T);for(s=0;s<=y;s++)T=n.get(s,y-1),n.set(s,y-1,R*T+E*n.get(s,y)),n.set(s,y,R*n.get(s,y)-E*T);for(s=0;s<=v;s++)T=i.get(s,y-1),i.set(s,y-1,R*T+E*i.get(s,y)),i.set(s,y,R*i.get(s,y)-E*T)}else r[y-1]=f+E,r[y]=f+E,e[y-1]=T,e[y]=-T;y-=2,N=0}else{if(f=n.get(y,y),m=0,c=0,h<y&&(m=n.get(y-1,y-1),c=n.get(y,y-1)*n.get(y-1,y)),10===N){for(S+=f,s=0;s<=y;s++)n.set(s,s,n.get(s,s)-f);f=m=.75*(C=Math.abs(n.get(y,y-1))+Math.abs(n.get(y-1,y-2))),c=-.4375*C*C}if(30===N&&(C=(C=(m-f)/2)*C+c)>0){for(C=Math.sqrt(C),m<f&&(C=-C),C=f-c/((m-f)/2+C),s=0;s<=y;s++)n.set(s,s,n.get(s,s)-C);S+=C,f=m=c=.964}for(N+=1,l=y-2;l>=h&&(E=((k=f-(T=n.get(l,l)))*(C=m-T)-c)/n.get(l+1,l)+n.get(l,l+1),R=n.get(l+1,l+1)-T-k-C,k=n.get(l+2,l+1),E/=C=Math.abs(E)+Math.abs(R)+Math.abs(k),R/=C,k/=C,l!==h)&&!(Math.abs(n.get(l,l-1))*(Math.abs(R)+Math.abs(k))<b*(Math.abs(E)*(Math.abs(n.get(l-1,l-1))+Math.abs(T)+Math.abs(n.get(l+1,l+1)))));)l--;for(s=l+2;s<=y;s++)n.set(s,s-2,0),s>l+2&&n.set(s,s-3,0);for(a=l;a<=y-1&&(x=a!==y-1,a!==l&&(E=n.get(a,a-1),R=n.get(a+1,a-1),k=x?n.get(a+2,a-1):0,0!==(f=Math.abs(E)+Math.abs(R)+Math.abs(k))&&(E/=f,R/=f,k/=f)),0!==f);a++)if(C=Math.sqrt(E*E+R*R+k*k),E<0&&(C=-C),0!==C){for(a!==l?n.set(a,a-1,-C*f):h!==l&&n.set(a,a-1,-n.get(a,a-1)),f=(E+=C)/C,m=R/C,T=k/C,R/=E,k/=E,o=a;o<t;o++)E=n.get(a,o)+R*n.get(a+1,o),x&&(E+=k*n.get(a+2,o),n.set(a+2,o,n.get(a+2,o)-E*T)),n.set(a,o,n.get(a,o)-E*f),n.set(a+1,o,n.get(a+1,o)-E*m);for(s=0;s<=Math.min(y,a+3);s++)E=f*n.get(s,a)+m*n.get(s,a+1),x&&(E+=T*n.get(s,a+2),n.set(s,a+2,n.get(s,a+2)-E*k)),n.set(s,a,n.get(s,a)-E),n.set(s,a+1,n.get(s,a+1)-E*R);for(s=0;s<=v;s++)E=f*i.get(s,a)+m*i.get(s,a+1),x&&(E+=T*i.get(s,a+2),i.set(s,a+2,i.get(s,a+2)-E*k)),i.set(s,a,i.get(s,a)-E),i.set(s,a+1,i.get(s,a+1)-E*R)}}}if(0!==A){for(y=t-1;y>=0;y--)if(E=r[y],0===(R=e[y]))for(h=y,n.set(y,y,1),s=y-1;s>=0;s--){for(c=n.get(s,s)-E,k=0,o=h;o<=y;o++)k+=n.get(s,o)*n.get(o,y);if(e[s]<0)T=c,C=k;else if(h=s,0===e[s]?n.set(s,y,0!==c?-k/c:-k/(b*A)):(f=n.get(s,s+1),m=n.get(s+1,s),u=(f*C-T*k)/(R=(r[s]-E)*(r[s]-E)+e[s]*e[s]),n.set(s,y,u),n.set(s+1,y,Math.abs(f)>Math.abs(T)?(-k-c*u)/f:(-C-m*u)/T)),b*(u=Math.abs(n.get(s,y)))*u>1)for(o=s;o<=y;o++)n.set(o,y,n.get(o,y)/u)}else if(R<0)for(h=y-1,Math.abs(n.get(y,y-1))>Math.abs(n.get(y-1,y))?(n.set(y-1,y-1,R/n.get(y,y-1)),n.set(y-1,y,-(n.get(y,y)-E)/n.get(y,y-1))):(M=cdiv(0,-n.get(y-1,y),n.get(y-1,y-1)-E,R),n.set(y-1,y-1,M[0]),n.set(y-1,y,M[1])),n.set(y,y-1,0),n.set(y,y,1),s=y-2;s>=0;s--){for(g=0,d=0,o=h;o<=y;o++)g+=n.get(s,o)*n.get(o,y-1),d+=n.get(s,o)*n.get(o,y);if(c=n.get(s,s)-E,e[s]<0)T=c,k=g,C=d;else if(h=s,0===e[s]?(M=cdiv(-g,-d,c,R),n.set(s,y-1,M[0]),n.set(s,y,M[1])):(f=n.get(s,s+1),m=n.get(s+1,s),p=(r[s]-E)*(r[s]-E)+e[s]*e[s]-R*R,w=2*(r[s]-E)*R,0===p&&0===w&&(p=b*A*(Math.abs(c)+Math.abs(R)+Math.abs(f)+Math.abs(m)+Math.abs(T))),M=cdiv(f*k-T*g+R*d,f*C-T*d-R*g,p,w),n.set(s,y-1,M[0]),n.set(s,y,M[1]),Math.abs(f)>Math.abs(T)+Math.abs(R)?(n.set(s+1,y-1,(-g-c*n.get(s,y-1)+R*n.get(s,y))/f),n.set(s+1,y,(-d-c*n.get(s,y)-R*n.get(s,y-1))/f)):(M=cdiv(-k-m*n.get(s,y-1),-C-m*n.get(s,y),T,R),n.set(s+1,y-1,M[0]),n.set(s+1,y,M[1]))),b*(u=Math.max(Math.abs(n.get(s,y-1)),Math.abs(n.get(s,y))))*u>1)for(o=s;o<=y;o++)n.set(o,y-1,n.get(o,y-1)/u),n.set(o,y,n.get(o,y)/u)}for(s=0;s<t;s++)if(s<0||s>v)for(o=s;o<t;o++)i.set(s,o,n.get(s,o));for(o=t-1;o>=0;o--)for(s=0;s<=v;s++){for(T=0,a=0;a<=Math.min(o,v);a++)T+=i.get(s,a)*n.get(a,o);i.set(s,o,T)}}}function cdiv(t,e,r,i){let n,s;return Math.abs(r)>Math.abs(i)?[(t+(n=i/r)*e)/(s=r+n*i),(e-n*t)/s]:[((n=r/i)*t+e)/(s=i+n*r),(n*e-t)/s]}class CholeskyDecomposition{constructor(t){if(!(t=WrapperMatrix2D.checkMatrix(t)).isSymmetric())throw new Error("Matrix is not symmetric");let e,r,i,n=t,s=n.rows,o=new Matrix(s,s),a=!0;for(r=0;r<s;r++){let t=0;for(i=0;i<r;i++){let s=0;for(e=0;e<i;e++)s+=o.get(i,e)*o.get(r,e);s=(n.get(r,i)-s)/o.get(i,i),o.set(r,i,s),t+=s*s}for(a&=(t=n.get(r,r)-t)>0,o.set(r,r,Math.sqrt(Math.max(t,0))),i=r+1;i<s;i++)o.set(r,i,0)}this.L=o,this.positiveDefinite=Boolean(a)}isPositiveDefinite(){return this.positiveDefinite}solve(t){t=WrapperMatrix2D.checkMatrix(t);let e=this.L,r=e.rows;if(t.rows!==r)throw new Error("Matrix dimensions do not match");if(!1===this.isPositiveDefinite())throw new Error("Matrix is not positive definite");let i,n,s,o=t.columns,a=t.clone();for(s=0;s<r;s++)for(n=0;n<o;n++){for(i=0;i<s;i++)a.set(s,n,a.get(s,n)-a.get(i,n)*e.get(s,i));a.set(s,n,a.get(s,n)/e.get(s,s))}for(s=r-1;s>=0;s--)for(n=0;n<o;n++){for(i=s+1;i<r;i++)a.set(s,n,a.get(s,n)-a.get(i,n)*e.get(i,s));a.set(s,n,a.get(s,n)/e.get(s,s))}return a}get lowerTriangularMatrix(){return this.L}}class nipals{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t=WrapperMatrix2D.checkMatrix(t);let{Y:r}=e;const{scaleScores:i=!1,maxIterations:n=1e3,terminationCriteria:s=1e-10}=e;let o;if(r){if(!(r=Array.isArray(r)&&"number"==typeof r[0]?Matrix.columnVector(r):WrapperMatrix2D.checkMatrix(r)).isColumnVector()||r.rows!==t.rows)throw new Error("Y must be a column vector of length X.rows");o=r}else o=t.getColumnVector(0);let a,h,l,u,c=1;for(let e=0;e<n&&c>s;e++)l=(l=t.transpose().mmul(o).div(o.transpose().mmul(o).get(0,0))).div(l.norm()),a=t.mmul(l).div(l.transpose().mmul(l).get(0,0)),e>0&&(c=a.clone().sub(u).pow(2).sum()),u=a.clone(),r?(h=(h=r.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0))).div(h.norm()),o=r.mmul(h).div(h.transpose().mmul(h).get(0,0))):o=a;if(r){let e=t.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0));e=e.div(e.norm());let i=t.clone().sub(a.clone().mmul(e.transpose())),n=o.transpose().mmul(a).div(a.transpose().mmul(a).get(0,0)),s=r.clone().sub(a.clone().mulS(n.get(0,0)).mmul(h.transpose()));this.t=a,this.p=e.transpose(),this.w=l.transpose(),this.q=h,this.u=o,this.s=a.transpose().mmul(a),this.xResidual=i,this.yResidual=s,this.betas=n}else this.w=l.transpose(),this.s=a.transpose().mmul(a).sqrt(),this.t=i?a.clone().div(this.s.get(0,0)):a,this.xResidual=t.sub(a.mmul(l.transpose()))}}var MatrixLib=Object.freeze({__proto__:null,AbstractMatrix:AbstractMatrix,default:Matrix,Matrix:Matrix,wrap:wrap,WrapperMatrix1D:WrapperMatrix1D,WrapperMatrix2D:WrapperMatrix2D,solve:solve,inverse:inverse,determinant:determinant,linearDependencies:linearDependencies,pseudoInverse:pseudoInverse,covariance:covariance,correlation:correlation,SingularValueDecomposition:SingularValueDecomposition,SVD:SingularValueDecomposition,EigenvalueDecomposition:EigenvalueDecomposition,EVD:EigenvalueDecomposition,CholeskyDecomposition:CholeskyDecomposition,CHO:CholeskyDecomposition,LuDecomposition:LuDecomposition,LU:LuDecomposition,QrDecomposition:QrDecomposition,QR:QrDecomposition,Nipals:nipals,NIPALS:nipals,MatrixColumnView:MatrixColumnView,MatrixColumnSelectionView:MatrixColumnSelectionView,MatrixFlipColumnView:MatrixFlipColumnView,MatrixFlipRowView:MatrixFlipRowView,MatrixRowView:MatrixRowView,MatrixRowSelectionView:MatrixRowSelectionView,MatrixSelectionView:MatrixSelectionView,MatrixSubView:MatrixSubView,MatrixTransposeView:MatrixTransposeView});function sum(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0;r<t.length;r++)e+=t[r];return e}function mean(t){return sum(t)/t.length}function toDiscreteDistribution(t,e){let r=new Array(e).fill(0);for(let e=0;e<t.length;++e)r[t[e]]+=1/t.length;return Matrix.rowVector(r)}function giniImpurity(t){if(0===t.length)return 0;let e=toDiscreteDistribution(t,getNumberOfClasses(t)).getRow(0),r=0;for(let t=0;t<e.length;++t)r+=e[t]*e[t];return 1-r}function getNumberOfClasses(t){return t.filter((function(t,e,r){return r.indexOf(t)===e})).map(t=>t+1).reduce((t,e)=>Math.max(t,e))}function giniGain(t,e){let r=0,i=["greater","lesser"];for(let n=0;n<i.length;++n){let s=e[i[n]];r+=giniImpurity(s)*s.length/t.length}return giniImpurity(t)-r}function squaredError(t){let e=t.length,r=mean(t),i=0;for(let n=0;n<e;++n){let e=t[n];i+=(e-r)*(e-r)}return i}function regressionError(t,e){let r=0,i=["greater","lesser"];for(let t=0;t<i.length;++t){r+=squaredError(e[i[t]])}return r}function matrixSplitter(t,e,r,i){let n=[],s=[],o=[],a=[];for(let h=0;h<t.rows;++h)t.get(h,r)<i?(n.push(t.getRow(h)),o.push(e[h])):(s.push(t.getRow(h)),a.push(e[h]));return{greaterX:s,greaterY:a,lesserX:n,lesserY:o}}function mean$1(t,e){return(t+e)/2}function zip(t,e){if(t.length!==e.length)throw new TypeError("Error on zip: the size of a: ".concat(t.length," is different from b: ").concat(e.length));let r=new Array(t.length);for(let i=0;i<t.length;++i)r[i]=[t[i],e[i]];return r}const gainFunctions={gini:giniGain,regression:regressionError},splitFunctions={mean:mean$1};class TreeNode{constructor(t){this.kind=t.kind,this.gainFunction=t.gainFunction,this.splitFunction=t.splitFunction,this.minNumSamples=t.minNumSamples,this.maxDepth=t.maxDepth}bestSplit(t,e){let r,i,n="classifier"===this.kind?-1/0:1/0,s="classifier"===this.kind?(t,e)=>t>e:(t,e)=>t<e;for(let o=0;o<t.rows;++o){let a=t.getRow(o),h=this.featureSplit(a,e);for(let t=0;t<h.length;++t){let l=h[t],u=this.split(a,e,l),c=gainFunctions[this.gainFunction](e,u);s(c,n)&&(r=o,i=l,n=c)}}return{maxGain:n,maxColumn:r,maxValue:i}}split(t,e,r){let i=[],n=[];for(let s=0;s<t.length;++s)t[s]<r?i.push(e[s]):n.push(e[s]);return{greater:n,lesser:i}}featureSplit(t,e){let r=[],i=zip(t,e);i.sort((function(t,e){return t[0]-e[0]}));for(let t=1;t<i.length;++t)i[t-1][1]!==i[t][1]&&r.push(splitFunctions[this.splitFunction](i[t-1][0],i[t][0]));return r}calculatePrediction(t){if("classifier"===this.kind){if(this.distribution=toDiscreteDistribution(t,getNumberOfClasses(t)),0===this.distribution.columns)throw new TypeError("Error on calculate the prediction")}else this.distribution=mean(t)}train(t,e,r,i){if(t.rows<=this.minNumSamples)return void this.calculatePrediction(e);void 0===i&&(i=0);let n=t.transpose(),s=this.bestSplit(n,e);this.splitValue=s.maxValue,this.splitColumn=s.maxColumn,this.gain=s.maxGain;let o=matrixSplitter(t,e,this.splitColumn,this.splitValue);if(r<this.maxDepth&&this.gain>.01&&this.gain!==i&&o.lesserX.length>0&&o.greaterX.length>0){this.left=new TreeNode(this),this.right=new TreeNode(this);let t=new Matrix(o.lesserX),e=new Matrix(o.greaterX);this.left.train(t,o.lesserY,r+1,this.gain),this.right.train(e,o.greaterY,r+1,this.gain)}else this.calculatePrediction(e)}classify(t){return this.right&&this.left?t[this.splitColumn]<this.splitValue?this.left.classify(t):this.right.classify(t):this.distribution}setNodeParameters(t){void 0!==t.distribution?this.distribution=t.distribution.constructor===Array?new Matrix(t.distribution):t.distribution:(this.distribution=void 0,this.splitValue=t.splitValue,this.splitColumn=t.splitColumn,this.gain=t.gain,this.left=new TreeNode(this),this.right=new TreeNode(this),t.left!=={}&&this.left.setNodeParameters(t.left),t.right!=={}&&this.right.setNodeParameters(t.right))}}const defaultOptions={gainFunction:"gini",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class DecisionTreeClassifier{constructor(t,e){!0===t?(this.options=e.options,this.root=new TreeNode(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},defaultOptions,t),this.options.kind="classifier")}train(t,e){this.root=new TreeNode(this.options),t=Matrix.checkMatrix(t),this.root.train(t,e,0,null)}predict(t){t=Matrix.checkMatrix(t);let e=new Array(t.rows);for(let r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r)).maxRowIndex(0)[1];return e}toJSON(){return{options:this.options,root:this.root,name:"DTClassifier"}}static load(t){if("DTClassifier"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new DecisionTreeClassifier(!0,t)}}const defaultOptions$1={gainFunction:"regression",splitFunction:"mean",minNumSamples:3,maxDepth:1/0};class DecisionTreeRegression{constructor(t,e){!0===t?(this.options=e.options,this.root=new TreeNode(e.options),this.root.setNodeParameters(e.root)):(this.options=Object.assign({},defaultOptions$1,t),this.options.kind="regression")}train(t,e){this.root=new TreeNode(this.options),t=void 0!==t[0]&&void 0===t[0].length?Matrix.columnVector(t):Matrix.checkMatrix(t),this.root.train(t,e,0)}predict(t){void 0!==t[0]&&void 0===t[0].length&&(t=Matrix.columnVector(t)),t=Matrix.checkMatrix(t);let e=new Array(t.rows);for(let r=0;r<t.rows;++r)e[r]=this.root.classify(t.getRow(r));return e}toJSON(){return{options:this.options,root:this.root,name:"DTRegression"}}static load(t){if("DTRegression"!==t.name)throw new RangeError("Invalid model:".concat(t.name));return new DecisionTreeRegression(!0,t)}}const SMALLEST_UNSAFE_INTEGER=9007199254740992,LARGEST_SAFE_INTEGER=SMALLEST_UNSAFE_INTEGER-1,UINT32_MAX=-1>>>0,UINT32_SIZE=UINT32_MAX+1,INT32_SIZE=UINT32_SIZE/2,INT32_MAX=INT32_SIZE-1,UINT21_SIZE=1<<21,UINT21_MAX=UINT21_SIZE-1;function int32(t){return 0|t.next()}function add(t,e){return 0===e?t:r=>t(r)+e}function int53(t){const e=0|t.next(),r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r+(e&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}function int53Full(t){for(;;){const e=0|t.next();if(!(4194304&e)){const r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r+(e&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}if(4194304==(8388607&e)&&0==(0|t.next()))return SMALLEST_UNSAFE_INTEGER}}function uint32(t){return t.next()>>>0}function uint53(t){const e=t.next()&UINT21_MAX,r=t.next()>>>0;return e*UINT32_SIZE+r}function uint53Full(t){for(;;){const e=0|t.next();if(!(e&UINT21_SIZE)){const r=t.next()>>>0;return(e&UINT21_MAX)*UINT32_SIZE+r}if(0==(e&UINT21_MAX)&&0==(0|t.next()))return SMALLEST_UNSAFE_INTEGER}}function isPowerOfTwoMinusOne(t){return 0==(t+1&t)}function bitmask(t){return e=>e.next()&t}function downscaleToLoopCheckedRange(t){const e=t+1,r=e*Math.floor(UINT32_SIZE/e);return t=>{let i=0;do{i=t.next()>>>0}while(i>=r);return i%e}}function downscaleToRange(t){return isPowerOfTwoMinusOne(t)?bitmask(t):downscaleToLoopCheckedRange(t)}function isEvenlyDivisibleByMaxInt32(t){return 0==(0|t)}function upscaleWithHighMasking(t){return e=>{const r=e.next()&t,i=e.next()>>>0;return r*UINT32_SIZE+i}}function upscaleToLoopCheckedRange(t){const e=t*Math.floor(SMALLEST_UNSAFE_INTEGER/t);return r=>{let i=0;do{const t=r.next()&UINT21_MAX,e=r.next()>>>0;i=t*UINT32_SIZE+e}while(i>=e);return i%t}}function upscaleWithinU53(t){const e=t+1;if(isEvenlyDivisibleByMaxInt32(e)){const t=(e/UINT32_SIZE|0)-1;if(isPowerOfTwoMinusOne(t))return upscaleWithHighMasking(t)}return upscaleToLoopCheckedRange(e)}function upscaleWithinI53AndLoopCheck(t,e){return r=>{let i=0;do{const t=0|r.next(),e=r.next()>>>0;i=(t&UINT21_MAX)*UINT32_SIZE+e+(t&UINT21_SIZE?-SMALLEST_UNSAFE_INTEGER:0)}while(i<t||i>e);return i}}function integer(t,e){if(t=Math.floor(t),e=Math.floor(e),t<-SMALLEST_UNSAFE_INTEGER||!isFinite(t))throw new RangeError("Expected min to be at least ".concat(-SMALLEST_UNSAFE_INTEGER));if(e>SMALLEST_UNSAFE_INTEGER||!isFinite(e))throw new RangeError("Expected max to be at most ".concat(SMALLEST_UNSAFE_INTEGER));const r=e-t;return r<=0||!isFinite(r)?()=>t:r===UINT32_MAX?0===t?uint32:add(int32,t+INT32_SIZE):r<UINT32_MAX?add(downscaleToRange(r),t):r===LARGEST_SAFE_INTEGER?add(uint53,t):r<LARGEST_SAFE_INTEGER?add(upscaleWithinU53(r),t):e-1-t===LARGEST_SAFE_INTEGER?add(uint53Full,t):t===-SMALLEST_UNSAFE_INTEGER&&e===SMALLEST_UNSAFE_INTEGER?int53Full:t===-SMALLEST_UNSAFE_INTEGER&&e===LARGEST_SAFE_INTEGER?int53:t===-LARGEST_SAFE_INTEGER&&e===SMALLEST_UNSAFE_INTEGER?add(int53,1):e===SMALLEST_UNSAFE_INTEGER?add(upscaleWithinI53AndLoopCheck(t-1,e-1),1):upscaleWithinI53AndLoopCheck(t,e)}const DEFAULT_STRING_POOL="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-";function string(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:DEFAULT_STRING_POOL;const e=t.length;if(!e)throw new Error("Expected pool not to be an empty string");const r=integer(0,e-1);return(e,i)=>{let n="";for(let s=0;s<i;++s){const i=r(e);n+=t.charAt(i)}return n}}const LOWER_HEX_POOL="0123456789abcdef",lowerHex=string(LOWER_HEX_POOL),upperHex=string(LOWER_HEX_POOL.toUpperCase()),stringRepeat=(()=>{try{if("xxx"==="x".repeat(3))return(t,e)=>t.repeat(e)}catch(t){}return(t,e)=>{let r="";for(;e>0;)1&e&&(r+=t),e>>=1,t+=t;return r}})(),nativeMath={next:()=>Math.random()*UINT32_SIZE|0},I32Array=(()=>{try{const t=new ArrayBuffer(4),e=new Int32Array(t);if(e[0]=INT32_SIZE,e[0]===-INT32_SIZE)return Int32Array}catch(t){}return Array})();function createEntropy(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:nativeMath,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:16;const r=[];r.push(0|(new Date).getTime());for(let i=1;i<e;++i)r[i]=0|t.next();return r}const imul=(()=>{try{if(-5===Math.imul(UINT32_MAX,5))return Math.imul}catch(t){}return(t,e)=>{const r=65535&t,i=65535&e;return r*i+((t>>>16&65535)*i+r*(e>>>16&65535)<<16>>>0)|0}})(),ARRAY_SIZE=624,ARRAY_MAX=ARRAY_SIZE-1,M=397,ARRAY_SIZE_MINUS_M=ARRAY_SIZE-M,A=2567483615;class MersenneTwister19937{constructor(){this.data=new I32Array(ARRAY_SIZE),this.index=0,this.uses=0}static seed(t){return(new MersenneTwister19937).seed(t)}static seedWithArray(t){return(new MersenneTwister19937).seedWithArray(t)}static autoSeed(){return MersenneTwister19937.seedWithArray(createEntropy())}next(){(0|this.index)>=ARRAY_SIZE&&(refreshData(this.data),this.index=0);const t=this.data[this.index];return this.index=this.index+1|0,this.uses+=1,0|temper(t)}getUseCount(){return this.uses}discard(t){if(t<=0)return this;for(this.uses+=t,(0|this.index)>=ARRAY_SIZE&&(refreshData(this.data),this.index=0);t+this.index>ARRAY_SIZE;)t-=ARRAY_SIZE-this.index,refreshData(this.data),this.index=0;return this.index=this.index+t|0,this}seed(t){let e=0;this.data[0]=e=0|t;for(let t=1;t<ARRAY_SIZE;t=t+1|0)this.data[t]=e=imul(e^e>>>30,1812433253)+t|0;return this.index=ARRAY_SIZE,this.uses=0,this}seedWithArray(t){return this.seed(19650218),seedWithArray(this.data,t),this}}function refreshData(t){let e=0,r=0;for(;(0|e)<ARRAY_SIZE_MINUS_M;e=e+1|0)r=t[e]&INT32_SIZE|t[e+1|0]&INT32_MAX,t[e]=t[e+M|0]^r>>>1^(1&r?A:0);for(;(0|e)<ARRAY_MAX;e=e+1|0)r=t[e]&INT32_SIZE|t[e+1|0]&INT32_MAX,t[e]=t[e-ARRAY_SIZE_MINUS_M|0]^r>>>1^(1&r?A:0);r=t[ARRAY_MAX]&INT32_SIZE|t[0]&INT32_MAX,t[ARRAY_MAX]=t[M-1]^r>>>1^(1&r?A:0)}function temper(t){return t^=t>>>11,t^=t<<7&2636928640,(t^=t<<15&4022730752)^t>>>18}function seedWithArray(t,e){let r=1,i=0;const n=e.length;let s=0|Math.max(n,ARRAY_SIZE),o=0|t[0];for(;(0|s)>0;--s)t[r]=o=(t[r]^imul(o^o>>>30,1664525))+(0|e[i])+(0|i)|0,++i,(0|(r=r+1|0))>ARRAY_MAX&&(t[0]=t[ARRAY_MAX],r=1),i>=n&&(i=0);for(s=ARRAY_MAX;(0|s)>0;--s)t[r]=o=(t[r]^imul(o^o>>>30,1566083941))-r|0,(0|(r=r+1|0))>ARRAY_MAX&&(t[0]=t[ARRAY_MAX],r=1);t[0]=INT32_SIZE}function checkFloat(t){return t>0&&t<=1}function examplesBaggingWithReplacement(t,e,r){let i,n=integer(0,t.rows-1);if(void 0===r)i=MersenneTwister19937.autoSeed();else{if(!Number.isInteger(r))throw new RangeError("Expected seed must be undefined or integer not ".concat(r));i=MersenneTwister19937.seed(r)}let s=new Array(t.rows),o=new Array(t.rows);for(let r=0;r<t.rows;++r){let a=n(i);s[r]=t.getRow(a),o[r]=e[a]}return{X:new Matrix(s),y:o}}function featureBagging(t,e,r,i){if(t.columns<e)throw new RangeError("N should be less or equal to the number of columns of X");let n,s=integer(0,t.columns-1);if(void 0===i)n=MersenneTwister19937.autoSeed();else{if(!Number.isInteger(i))throw new RangeError("Expected seed must be undefined or integer not ".concat(i));n=MersenneTwister19937.seed(i)}let o,a,h=new Matrix(t.rows,e);if(r){o=new Array(e);for(let r=0;r<e;++r)a=s(n),o[r]=a,h.setColumn(r,t.getColumn(a))}else{o=new Set,a=s(n);for(let r=0;r<e;++r){for(;o.has(a);)a=s(n);h.setColumn(r,t.getColumn(a)),o.add(a)}o=Array.from(o)}return{X:h,usedIndex:o}}class RandomForestBase{constructor(t,e){if(!0===t){this.replacement=e.replacement,this.maxFeatures=e.maxFeatures,this.nEstimators=e.nEstimators,this.treeOptions=e.treeOptions,this.isClassifier=e.isClassifier,this.seed=e.seed,this.n=e.n,this.indexes=e.indexes,this.useSampleBagging=e.useSampleBagging;let t=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression;this.estimators=e.estimators.map(e=>t.load(e))}else this.replacement=t.replacement,this.maxFeatures=t.maxFeatures,this.nEstimators=t.nEstimators,this.treeOptions=t.treeOptions,this.isClassifier=t.isClassifier,this.seed=t.seed,this.useSampleBagging=t.useSampleBagging}train(t,e){if(t=Matrix.checkMatrix(t),this.maxFeatures=this.maxFeatures||t.columns,checkFloat(this.maxFeatures))this.n=Math.floor(t.columns*this.maxFeatures);else{if(!Number.isInteger(this.maxFeatures))throw new RangeError("Cannot process the maxFeatures parameter ".concat(this.maxFeatures));if(this.maxFeatures>t.columns)throw new RangeError("The maxFeatures parameter should be less than ".concat(t.columns));this.n=this.maxFeatures}let r;r=this.isClassifier?DecisionTreeClassifier:DecisionTreeRegression,this.estimators=new Array(this.nEstimators),this.indexes=new Array(this.nEstimators);for(let i=0;i<this.nEstimators;++i){let n=this.useSampleBagging?examplesBaggingWithReplacement(t,e,this.seed):{X:t,y:e},s=n.X,o=n.y;s=(n=featureBagging(s,this.n,this.replacement,this.seed)).X,this.indexes[i]=n.usedIndex,this.estimators[i]=new r(this.treeOptions),this.estimators[i].train(s,o)}}selection(t){throw new Error("Abstract method 'selection' not implemented!")}predict(t){let e=new Array(this.nEstimators);t=Matrix.checkMatrix(t);for(let r=0;r<this.nEstimators;++r){let i=new MatrixColumnSelectionView(t,this.indexes[r]);e[r]=this.estimators[r].predict(i)}e=new MatrixTransposeView(new WrapperMatrix2D(e));let r=new Array(e.rows);for(let t=0;t<e.rows;++t)r[t]=this.selection(e.getRow(t));return r}toJSON(){return{indexes:this.indexes,n:this.n,replacement:this.replacement,maxFeatures:this.maxFeatures,nEstimators:this.nEstimators,treeOptions:this.treeOptions,isClassifier:this.isClassifier,seed:this.seed,estimators:this.estimators.map(t=>t.toJSON()),useSampleBagging:this.useSampleBagging}}}const defaultOptions$2={maxFeatures:1,replacement:!0,nEstimators:10,seed:42,useSampleBagging:!1};class RandomForestClassifier extends RandomForestBase{constructor(t,e){!0===t?super(!0,e.baseModel):((t=Object.assign({},defaultOptions$2,t)).isClassifier=!0,super(t))}selection(t){return mode(t)}toJSON(){return{baseModel:super.toJSON(),name:"RFClassifier"}}static load(t){if("RFClassifier"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new RandomForestClassifier(!0,t)}}function mode(t){return t.sort((e,r)=>t.filter(t=>t===e).length-t.filter(t=>t===r).length).pop()}var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(t,e){return t(e={exports:{}},e.exports),e.exports}var medianQuickselect_min=createCommonjsModule((function(t){!function(){function e(t){for(var e=0,n=t.length-1,s=void 0,o=void 0,a=void 0,h=i(e,n);;){if(n<=e)return t[h];if(n==e+1)return t[e]>t[n]&&r(t,e,n),t[h];for(t[s=i(e,n)]>t[n]&&r(t,s,n),t[e]>t[n]&&r(t,e,n),t[s]>t[e]&&r(t,s,e),r(t,s,e+1),o=e+1,a=n;;){do{o++}while(t[e]>t[o]);do{a--}while(t[a]>t[e]);if(a<o)break;r(t,o,a)}r(t,e,a),a<=h&&(e=o),a>=h&&(n=a-1)}}var r=function(t,e,r){var i;return i=[t[r],t[e]],t[e]=i[0],t[r]=i[1],i},i=function(t,e){return~~((t+e)/2)};t.exports?t.exports=e:window.median=e}()}));function median(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");return medianQuickselect_min(t.slice())}const selectionMethods={mean:mean,median:median},defaultOptions$3={maxFeatures:1,replacement:!1,nEstimators:10,treeOptions:{},selectionMethod:"mean",seed:42,useSampleBagging:!1};class RandomForestRegression extends RandomForestBase{constructor(t,e){if(!0===t)super(!0,e.baseModel),this.selectionMethod=e.selectionMethod;else{if("mean"!==(t=Object.assign({},defaultOptions$3,t)).selectionMethod&&"median"!==t.selectionMethod)throw new RangeError("Unsupported selection method ".concat(t.selectionMethod));t.isClassifier=!1,super(t),this.selectionMethod=t.selectionMethod}}selection(t){return selectionMethods[this.selectionMethod](t)}toJSON(){return{baseModel:super.toJSON(),selectionMethod:this.selectionMethod,name:"RFRegression"}}static load(t){if("RFRegression"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new RandomForestRegression(!0,t)}}class PCA{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!0===t){const t=e;return this.center=t.center,this.scale=t.scale,this.means=t.means,this.stdevs=t.stdevs,this.U=Matrix.checkMatrix(t.U),this.S=t.S,this.R=t.R,void(this.excludedFeatures=t.excludedFeatures||[])}t=new Matrix(t);const{isCovarianceMatrix:r=!1,method:i="SVD",nCompNIPALS:n=2,center:s=!0,scale:o=!1,ignoreZeroVariance:a=!1}=e;if(this.center=s,this.scale=o,this.means=null,this.stdevs=null,this.excludedFeatures=[],r)this._computeFromCovarianceMatrix(t);else switch(this._adjust(t,a),i){case"covarianceMatrix":{const e=new MatrixTransposeView(t).mmul(t).div(t.rows-1);this._computeFromCovarianceMatrix(e);break}case"NIPALS":this._computeWithNIPALS(t,n);break;case"SVD":{const e=new SingularValueDecomposition(t,{computeLeftSingularVectors:!1,computeRightSingularVectors:!0,autoTranspose:!0});this.U=e.rightSingularVectors;const r=e.diagonal,i=[];for(const e of r)i.push(e*e/(t.rows-1));this.S=i;break}default:throw new Error("unknown method: ".concat(i))}}static load(t){if("string"!=typeof t.name)throw new TypeError("model must have a name property");if("PCA"!==t.name)throw new RangeError("invalid model: ".concat(t.name));return new PCA(!0,t)}predict(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{nComponents:r=this.U.columns}=e;if(t=new Matrix(t),this.center&&(t.subRowVector(this.means),this.scale)){for(let e of this.excludedFeatures)t.removeColumn(e);t.divRowVector(this.stdevs)}var i=t.mmul(this.U);return i.subMatrix(0,i.rows-1,0,r-1)}invert(t){var e=(t=Matrix.checkMatrix(t)).mmul(this.U.transpose());return this.center&&(this.scale&&e.mulRowVector(this.stdevs),e.addRowVector(this.means)),e}getExplainedVariance(){var t=0;for(const e of this.S)t+=e;return this.S.map(e=>e/t)}getCumulativeVariance(){for(var t=this.getExplainedVariance(),e=1;e<t.length;e++)t[e]+=t[e-1];return t}getEigenvectors(){return this.U}getEigenvalues(){return this.S}getStandardDeviations(){return this.S.map(t=>Math.sqrt(t))}getLoadings(){return this.U.transpose()}toJSON(){return{name:"PCA",center:this.center,scale:this.scale,means:this.means,stdevs:this.stdevs,U:this.U,S:this.S,excludedFeatures:this.excludedFeatures}}_adjust(t,e){if(this.center){const r=t.mean("column"),i=this.scale?t.standardDeviation("column",{mean:r}):null;if(this.means=r,t.subRowVector(r),this.scale){for(let r=0;r<i.length;r++)if(0===i[r]){if(!e)throw new RangeError("Cannot scale the dataset (standard deviation is zero at index ".concat(r));t.removeColumn(r),i.splice(r,1),this.excludedFeatures.push(r),r--}this.stdevs=i,t.divRowVector(i)}}}_computeFromCovarianceMatrix(t){const e=new EigenvalueDecomposition(t,{assumeSymmetric:!0});this.U=e.eigenvectorMatrix,this.U.flipRows(),this.S=e.realEigenvalues,this.S.reverse()}_computeWithNIPALS(t,e){this.U=new Matrix(e,t.columns),this.S=[];let r=t;for(let t=0;t<e;t++){let e=new nipals(r);this.U.setRow(t,e.w.transpose()),this.S.push(Math.pow(e.s.get(0,0),2)),r=e.xResidual}this.U=this.U.transpose()}}function squaredEuclidean(t,e){let r=0;for(let i=0;i<t.length;i++)r+=(t[i]-e[i])*(t[i]-e[i]);return r}function euclidean(t,e){return Math.sqrt(squaredEuclidean(t,e))}var euclidean$1=Object.freeze({__proto__:null,squaredEuclidean:squaredEuclidean,euclidean:euclidean});function distanceMatrix(t,e){const r=getMatrix(t.length);for(let i=0;i<t.length;i++)for(let n=0;n<=i;n++)r[i][n]=e(t[i],t[n]),r[n][i]=r[i][n];return r}function getMatrix(t){const e=[];for(let r=0;r<t;r++){const r=[];e.push(r);for(let e=0;e<t;e++)r.push(0)}return e}var heap=createCommonjsModule((function(t,e){(function(){var e,r,i,n,s,o,a,h,l,u,c,f,m,g,d;i=Math.floor,u=Math.min,r=function(t,e){return t<e?-1:t>e?1:0},l=function(t,e,n,s,o){var a;if(null==n&&(n=0),null==o&&(o=r),n<0)throw new Error("lo must be non-negative");for(null==s&&(s=t.length);n<s;)o(e,t[a=i((n+s)/2)])<0?s=a:n=a+1;return[].splice.apply(t,[n,n-n].concat(e)),e},o=function(t,e,i){return null==i&&(i=r),t.push(e),g(t,0,t.length-1,i)},s=function(t,e){var i,n;return null==e&&(e=r),i=t.pop(),t.length?(n=t[0],t[0]=i,d(t,0,e)):n=i,n},h=function(t,e,i){var n;return null==i&&(i=r),n=t[0],t[0]=e,d(t,0,i),n},a=function(t,e,i){var n;return null==i&&(i=r),t.length&&i(t[0],e)<0&&(e=(n=[t[0],e])[0],t[0]=n[1],d(t,0,i)),e},n=function(t,e){var n,s,o,a,h,l;for(null==e&&(e=r),h=[],s=0,o=(a=function(){l=[];for(var e=0,r=i(t.length/2);0<=r?e<r:e>r;0<=r?e++:e--)l.push(e);return l}.apply(this).reverse()).length;s<o;s++)n=a[s],h.push(d(t,n,e));return h},m=function(t,e,i){var n;if(null==i&&(i=r),-1!==(n=t.indexOf(e)))return g(t,0,n,i),d(t,n,i)},c=function(t,e,i){var s,o,h,l,u;if(null==i&&(i=r),!(o=t.slice(0,e)).length)return o;for(n(o,i),h=0,l=(u=t.slice(e)).length;h<l;h++)s=u[h],a(o,s,i);return o.sort(i).reverse()},f=function(t,e,i){var o,a,h,c,f,m,g,d,p;if(null==i&&(i=r),10*e<=t.length){if(!(h=t.slice(0,e).sort(i)).length)return h;for(a=h[h.length-1],c=0,m=(g=t.slice(e)).length;c<m;c++)i(o=g[c],a)<0&&(l(h,o,0,null,i),h.pop(),a=h[h.length-1]);return h}for(n(t,i),p=[],f=0,d=u(e,t.length);0<=d?f<d:f>d;0<=d?++f:--f)p.push(s(t,i));return p},g=function(t,e,i,n){var s,o,a;for(null==n&&(n=r),s=t[i];i>e&&n(s,o=t[a=i-1>>1])<0;)t[i]=o,i=a;return t[i]=s},d=function(t,e,i){var n,s,o,a,h;for(null==i&&(i=r),s=t.length,h=e,o=t[e],n=2*e+1;n<s;)(a=n+1)<s&&!(i(t[n],t[a])<0)&&(n=a),t[e]=t[n],n=2*(e=n)+1;return t[e]=o,g(t,h,e,i)},e=function(){function t(t){this.cmp=null!=t?t:r,this.nodes=[]}return t.push=o,t.pop=s,t.replace=h,t.pushpop=a,t.heapify=n,t.updateItem=m,t.nlargest=c,t.nsmallest=f,t.prototype.push=function(t){return o(this.nodes,t,this.cmp)},t.prototype.pop=function(){return s(this.nodes,this.cmp)},t.prototype.peek=function(){return this.nodes[0]},t.prototype.contains=function(t){return-1!==this.nodes.indexOf(t)},t.prototype.replace=function(t){return h(this.nodes,t,this.cmp)},t.prototype.pushpop=function(t){return a(this.nodes,t,this.cmp)},t.prototype.heapify=function(){return n(this.nodes,this.cmp)},t.prototype.updateItem=function(t){return m(this.nodes,t,this.cmp)},t.prototype.clear=function(){return this.nodes=[]},t.prototype.empty=function(){return 0===this.nodes.length},t.prototype.size=function(){return this.nodes.length},t.prototype.clone=function(){var e;return(e=new t).nodes=this.nodes.slice(0),e},t.prototype.toArray=function(){return this.nodes.slice(0)},t.prototype.insert=t.prototype.push,t.prototype.top=t.prototype.peek,t.prototype.front=t.prototype.peek,t.prototype.has=t.prototype.contains,t.prototype.copy=t.prototype.clone,t}(),t.exports=e}).call(commonjsGlobal)})),heap$1=heap;class Cluster{constructor(){this.children=[],this.height=0,this.size=1,this.index=-1,this.isLeaf=!1}cut(t){if("number"!=typeof t)throw new TypeError("threshold must be a number");if(t<0)throw new RangeError("threshold must be a positive number");let e=[this];const r=[];for(;e.length>0;){const i=e.shift();t>=i.height?r.push(i):e=e.concat(i.children)}return r}group(t){if(!Number.isInteger(t)||t<1)throw new RangeError("groups must be a positive integer");const e=new heap$1((t,e)=>e.height-t.height);for(e.push(this);e.size()<t;){var r=e.pop();if(0===r.children.length)break;r.children.forEach(t=>e.push(t))}var i=new Cluster;return i.children=e.toArray(),i.height=this.height,i}traverse(t){!function t(e,r){if(r(e),e.children)for(const i of e.children)t(i,r)}(this,t)}indices(){const t=[];return this.traverse(e=>{e.isLeaf&&t.push(e.index)}),t}}function singleLink(t,e){return Math.min(t,e)}function completeLink(t,e){return Math.max(t,e)}function averageLink(t,e,r,i,n){return i/(i+n)*t+n/(i+n)*e}function weightedAverageLink(t,e){return(t+e)/2}function centroidLink(t,e,r,i,n){return i/(i+n)*t+n/(i+n)*e+-i*n/(i+n)**2*r}function medianLink(t,e,r){return t/2+e/2-r/4}function wardLink(t,e,r,i,n,s){return(i+s)/(i+n+s)*t+(n+s)/(i+n+s)*e+-s/(i+n+s)*r}function wardLink2(t,e,r,i,n,s){const o=(i+s)/(i+n+s),a=(n+s)/(i+n+s),h=-s/(i+n+s);return Math.sqrt(o*t*t+a*e*e+h*r*r)}function agnes(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{distanceFunction:r=euclidean,method:i="complete",isDistanceMatrix:n=!1}=e;let s;n||(t=distanceMatrix(t,r));let o=new Matrix(t);const a=o.rows;if("string"==typeof i)switch(i.toLowerCase()){case"single":s=singleLink;break;case"complete":s=completeLink;break;case"average":case"upgma":s=averageLink;break;case"wpgma":s=weightedAverageLink;break;case"centroid":case"upgmc":s=centroidLink;break;case"median":case"wpgmc":s=medianLink;break;case"ward":s=wardLink;break;case"ward2":s=wardLink2;break;default:throw new RangeError("unknown clustering method: ".concat(i))}else if("function"!=typeof i)throw new TypeError("method must be a string or function");let h=[];for(let t=0;t<a;t++){const e=new Cluster;e.isLeaf=!0,e.index=t,h.push(e)}for(let t=0;t<a-1;t++){const[t,e,r]=getSmallestDistance(o),i=h[t],n=h[e],a=new Cluster;a.size=i.size+n.size,a.children.push(i,n),a.height=r;const l=[a],u=new Matrix(o.rows-1,o.rows-1),c=r=>getPreviousIndex(r,Math.min(t,e),Math.max(t,e));for(let a=1;a<u.rows;a++){const f=c(a),m=h[f];l.push(m);for(let h=0;h<a;h++)if(0===h){const l=s(o.get(t,f),o.get(f,e),r,i.size,n.size,m.size);u.set(a,h,l),u.set(h,a,l)}else{const t=o.get(f,c(h));u.set(a,h,t),u.set(h,a,t)}}h=l,o=u}return h[0]}function getSmallestDistance(t){let e=1/0,r=0,i=0;for(let n=1;n<t.rows;n++)for(let s=0;s<n;s++)t.get(n,s)<e&&(e=t.get(n,s),r=n,i=s);return[r,i,e]}function getPreviousIndex(t,e,r){return(t-=1)>=e&&t++,t>=r&&t++,t}var index=Object.freeze({__proto__:null,agnes:agnes});const defaultOptions$4={distanceFunction:squaredEuclidean};function nearestVector(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:defaultOptions$4;const i=r.distanceFunction||defaultOptions$4.distanceFunction,n=r.similarityFunction||defaultOptions$4.similarityFunction;let s=-1;if("function"==typeof n){let r=Number.MIN_VALUE;for(let i=0;i<t.length;i++){const o=n(e,t[i]);o>r&&(r=o,s=i)}}else{if("function"!=typeof i)throw new Error("A similarity or distance function it's required");{let r=Number.MAX_VALUE;for(let n=0;n<t.length;n++){const o=i(e,t[n]);o<r&&(r=o,s=n)}}}return s}function calculateDistanceMatrix(t,e){for(var r=new Array(t.length),i=0;i<t.length;++i)for(var n=i;n<t.length;++n){r[i]||(r[i]=new Array(t.length)),r[n]||(r[n]=new Array(t.length));const s=e(t[i],t[n]);r[i][n]=s,r[n][i]=s}return r}function updateClusterID(t,e,r,i){for(var n=0;n<t.length;n++)r[n]=nearestVector(e,t[n],{distanceFunction:i});return r}function updateCenters(t,e,r,i){const n=e[0].length;for(var s=new Array(i),o=new Array(i),a=0;a<i;a++){s[a]=new Array(n),o[a]=0;for(var h=0;h<n;h++)s[a][h]=0}for(var l=0;l<e.length;l++){o[r[l]]++;for(var u=0;u<n;u++)s[r[l]][u]+=e[l][u]}for(var c=0;c<i;c++)for(var f=0;f<n;f++)o[c]?s[c][f]/=o[c]:s[c][f]=t[c][f];return s}function hasConverged(t,e,r,i){for(var n=0;n<t.length;n++)if(r(t[n],e[n])>i)return!1;return!0}const LOOP=8,FLOAT_MUL=1/16777216,sh1=15,sh2=18,sh3=11;function multiply_uint32(t,e){const r=65535&(t>>>=0);return((t-r)*(e>>>=0)>>>0)+r*e>>>0}class XSadd{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Date.now();this.state=new Uint32Array(4),this.init(t),this.random=this.getFloat.bind(this)}getUint32(){return this.nextState(),this.state[3]+this.state[2]>>>0}getFloat(){return(this.getUint32()>>>8)*FLOAT_MUL}init(t){if(!Number.isInteger(t))throw new TypeError("seed must be an integer");this.state[0]=t,this.state[1]=0,this.state[2]=0,this.state[3]=0;for(let t=1;t<LOOP;t++)this.state[3&t]^=t+multiply_uint32(1812433253,this.state[t-1&3]^this.state[t-1&3]>>>30>>>0)>>>0;this.periodCertification();for(let t=0;t<LOOP;t++)this.nextState()}periodCertification(){0===this.state[0]&&0===this.state[1]&&0===this.state[2]&&0===this.state[3]&&(this.state[0]=88,this.state[1]=83,this.state[2]=65,this.state[3]=68)}nextState(){let t=this.state[0];t^=t<<sh1,t^=t>>>sh2,t^=this.state[3]<<sh3,this.state[0]=this.state[1],this.state[1]=this.state[2],this.state[2]=this.state[3],this.state[3]=t}}const PROB_TOLERANCE=1e-8;function randomChoice(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Math.random;const{size:i=1,replace:n=!1,probabilities:s}=e;let o,a;if(o="number"==typeof t?getArray(t):t.slice(),s){if(!n)throw new Error("choice with probabilities and no replacement is not implemented");if(s.length!==o.length)throw new Error("the length of probabilities option should be equal to the number of choices");a=[s[0]];for(let t=1;t<s.length;t++)a[t]=a[t-1]+s[t];if(Math.abs(1-a[a.length-1])>PROB_TOLERANCE)throw new Error("probabilities should sum to 1, but instead sums to ".concat(a[a.length-1]))}if(!1===n&&i>o.length)throw new Error("size option is too large");const h=[];for(let t=0;t<i;t++){const t=randomIndex(o.length,r,a);h.push(o[t]),n||o.splice(t,1)}return h}function getArray(t){const e=[];for(let r=0;r<t;r++)e.push(r);return e}function randomIndex(t,e,r){const i=e();if(r){let t=0;for(;i>r[t];)t++;return t}return Math.floor(i*t)}class Random{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Math.random;if("number"==typeof t){const e=new XSadd(t);this.randomGenerator=e.random}else this.randomGenerator=t}choice(t,e){return randomChoice(t,e,this.randomGenerator)}random(){return this.randomGenerator()}randInt(t,e){return void 0===e&&(e=t,t=0),t+Math.floor(this.randomGenerator()*(e-t))}randomSample(t){const e=[];for(let r=0;r<t;r++)e.push(this.random());return e}}function random(t,e,r){return new Random(r).choice(t,{size:e})}function mostDistant(t,e,r,i){const n=new Random(i);var s=new Array(e);if(s[0]=Math.floor(n.random()*t.length),e>1){for(var o={dist:-1,index:-1},a=0;a<t.length;++a)r[s[0]][a]>o.dist&&(o.dist=r[s[0]][a],o.index=a);if(s[1]=o.index,e>2)for(var h=2;h<e;++h){for(var l={dist:-1,index:-1},u=0;u<t.length;++u){for(var c={dist:Number.MAX_VALUE,index:-1},f=0;f<h;++f)r[f][u]<c.dist&&-1===s.indexOf(u)&&(c={dist:r[f][u],index:u});c.dist!==Number.MAX_VALUE&&c.dist>l.dist&&(l=Object.assign({},c))}s[h]=l.index}}return s.map(e=>t[e])}function kmeanspp(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=(t=new Matrix(t)).rows,n=new Random(r.seed),s=[],o=r.localTrials||2+Math.floor(Math.log(e)),a=n.randInt(i);s.push(t.getRow(a));let h=new Matrix(1,t.rows);for(let e=0;e<t.rows;e++)h.set(0,e,squaredEuclidean(t.getRow(e),s[0]));let l=[cumSum(h.getRow(0))];const u=1/l[0][i-1];let c=Matrix.mul(h,u);for(let r=1;r<e;r++){const e=n.choice(i,{replace:!0,size:o,probabilities:c[0]}),a=euclideanDistances(t.selection(e,range(t.columns)),t);let u,f,m;for(let t=0;t<o;t++){const r=Matrix.min(h,[a.getRow(t)]),i=r.sum();(void 0===u||i<f)&&(u=e[t],f=i,m=r)}s[r]=t.getRow(u),l=[cumSum((h=m).getRow(0))],c=Matrix.mul(h,1/l[0][i-1])}return s}function euclideanDistances(t,e){const r=new Matrix(t.rows,e.rows);for(let i=0;i<t.rows;i++)for(let n=0;n<e.rows;n++)r.set(i,n,squaredEuclidean(t.getRow(i),e.getRow(n)));return r}function range(t){let e=[];for(let r=0;r<t;r++)e.push(r);return e}function cumSum(t){let e=[t[0]];for(let r=1;r<t.length;r++)e[r]=e[r-1]+t[r];return e}const distanceSymbol=Symbol("distance");class KMeansResult{constructor(t,e,r,i,n){this.clusters=t,this.centroids=e,this.converged=r,this.iterations=i,this[distanceSymbol]=n}nearest(t){const e=new Array(t.length);return updateClusterID(t,this.centroids.map((function(t){return t.centroid})),e,this[distanceSymbol])}computeInformation(t){for(var e=this.centroids.map((function(t){return{centroid:t,error:0,size:0}})),r=0;r<t.length;r++)e[this.clusters[r]].error+=this[distanceSymbol](t[r],this.centroids[this.clusters[r]]),e[this.clusters[r]].size++;for(var i=0;i<this.centroids.length;i++)e[i].size?e[i].error/=e[i].size:e[i].error=null;return new KMeansResult(this.clusters,e,this.converged,this.iterations,this[distanceSymbol])}}const defaultOptions$5={maxIterations:100,tolerance:1e-6,withIterations:!1,initialization:"kmeans++",distanceFunction:squaredEuclidean};function step(t,e,r,i,n,s){var o=updateCenters(t,e,r=updateClusterID(e,t,r,n.distanceFunction),i),a=hasConverged(o,t,n.distanceFunction,n.tolerance);return new KMeansResult(r,o,a,s,n.distanceFunction)}function*kmeansGenerator(t,e,r,i,n){for(var s,o=!1,a=0;!o&&a<n.maxIterations;)s=step(t,e,r,i,n,++a),yield s.computeInformation(e),o=s.converged,t=s.centroids}function kmeans(t,e,r){if(r=Object.assign({},defaultOptions$5,r),e<=0||e>t.length||!Number.isInteger(e))throw new Error("K should be a positive integer smaller than the number of points");var i;if(Array.isArray(r.initialization)){if(r.initialization.length!==e)throw new Error("The initial centers should have the same length as K");i=r.initialization}else switch(r.initialization){case"kmeans++":i=kmeanspp(t,e,r);break;case"random":i=random(t,e,r.seed);break;case"mostDistant":i=mostDistant(t,e,calculateDistanceMatrix(t,r.distanceFunction),r.seed);break;default:throw new Error('Unknown initialization method: "'.concat(r.initialization,'"'))}0===r.maxIterations&&(r.maxIterations=Number.MAX_VALUE);var n=new Array(t.length);if(r.withIterations)return kmeansGenerator(i,t,n,e,r);for(var s,o=!1,a=0;!o&&a<r.maxIterations;)o=(s=step(i,t,n,e,r,++a)).converged,i=s.centroids;return s.computeInformation(t)}function separateClasses(t,e){for(var r=t.columns,i=0,n=new Array(1e4),s=0;s<e.length;s++)void 0===n[e[s]]&&(n[e[s]]=0,i++),n[e[s]]++;var o=new Array(i),a=new Array(i);for(s=0;s<i;++s)o[s]=new Matrix(n[s],r),a[s]=0;for(s=0;s<t.rows;++s)o[e[s]].setRow(a[e[s]],t.getRow(s)),a[e[s]]++;return o}class GaussianNB{constructor(t,e){t&&(this.means=e.means,this.calculateProbabilities=e.calculateProbabilities)}train(t,e){var r=Math.sqrt(2*Math.PI);if((t=Matrix.checkMatrix(t)).rows!==e.length)throw new RangeError("the size of the training set and the training labels must be the same.");var i=separateClasses(t,e),n=new Array(i.length);this.means=new Array(i.length);for(var s=0;s<i.length;++s){var o=i[s].mean("column"),a=i[s].standardDeviation("column",{mean:o}),h=Math.log(i[s].rows/t.rows);n[s]=new Array(o.length+1),n[s][0]=h;for(var l=1;l<o.length+1;++l){var u=a[l-1];n[s][l]=[1/(r*u),-2*u*u]}this.means[s]=o}this.calculateProbabilities=n}predict(t){if((t=Matrix.checkMatrix(t)).rows===this.calculateProbabilities[0].length)throw new RangeError("the dataset must have the same features as the training set");for(var e=new Array(t.rows),r=0;r<e.length;++r)e[r]=getCurrentClass(t.getRow(r),this.means,this.calculateProbabilities);return e}toJSON(){return{modelName:"NaiveBayes",means:this.means,calculateProbabilities:this.calculateProbabilities}}static load(t){if("NaiveBayes"!==t.modelName)throw new RangeError("The current model is not a Multinomial Naive Bayes, current model:",t.name);return new GaussianNB(!0,t)}}function getCurrentClass(t,e,r){for(var i=0,n=-1,s=0;s<r.length;++s){for(var o=r[s][0],a=1;a<r[0][1].length+1;++a)o+=calculateLogProbability(t[a-1],e[s][a-1],r[s][a][0],r[s][a][1]);(o=Math.exp(o))>i&&(i=o,n=s)}return n}function calculateLogProbability(t,e,r,i){return t-=e,Math.log(r*Math.exp(t*t/i))}class MultinomialNB{constructor(t){t&&(this.conditionalProbability=Matrix.checkMatrix(t.conditionalProbability),this.priorProbability=Matrix.checkMatrix(t.priorProbability))}train(t,e){if((t=Matrix.checkMatrix(t)).rows!==e.length)throw new RangeError("the size of the training set and the training labels must be the same.");var r=separateClasses(t,e);this.priorProbability=new Matrix(r.length,1);for(var i=0;i<r.length;++i)this.priorProbability.set(i,0,Math.log(r[i].rows/t.rows));var n=t.columns;for(this.conditionalProbability=new Matrix(r.length,n),i=0;i<r.length;++i){var s=Matrix.checkMatrix(r[i]),o=s.sum()+n;this.conditionalProbability.setRow(i,Matrix.rowVector(s.sum("column")).add(1).div(o).apply(matrixLog))}}predict(t){t=Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=0;r<t.rows;++r){var i=t.getRowVector(r);const n=Matrix.columnVector(this.conditionalProbability.clone().mulRowVector(i).sum("row"));e[r]=n.add(this.priorProbability).maxIndex()[0]}return e}toJSON(){return{name:"MultinomialNB",priorProbability:this.priorProbability,conditionalProbability:this.conditionalProbability}}static load(t){if("MultinomialNB"!==t.name)throw new RangeError("".concat(t.name," is not a Multinomial Naive Bayes"));return new MultinomialNB(t)}}function matrixLog(t,e){this.set(t,e,Math.log(this.get(t,e)))}var index$1=Object.freeze({__proto__:null,GaussianNB:GaussianNB,MultinomialNB:MultinomialNB});
/*
   * Original code from:
   *
   * k-d Tree JavaScript - V 1.01
   *
   * https://github.com/ubilabs/kd-tree-javascript
   *
   * @author Mircea Pricop <pricop@ubilabs.net>, 2012
   * @author Martin Kleppe <kleppe@ubilabs.net>, 2012
   * @author Ubilabs http://ubilabs.net, 2012
   * @license MIT License <http://www.opensource.org/licenses/mit-license.php>
   */function Node(t,e,r){this.obj=t,this.left=null,this.right=null,this.parent=r,this.dimension=e}class KDTree{constructor(t,e){if(Array.isArray(t)){this.dimensions=new Array(t[0].length);for(var r=0;r<this.dimensions.length;r++)this.dimensions[r]=r;this.root=buildTree(t,0,null,this.dimensions)}else this.dimensions=t.dimensions,this.root=t,restoreParent(this.root);this.metric=e}toJSON(){const t=toJSONImpl(this.root);return t.dimensions=this.dimensions,t}nearest(t,e,r){const i=this.metric,n=this.dimensions;var s;const o=new BinaryHeap((function(t){return-t[1]}));if(r)for(s=0;s<e;s+=1)o.push([null,r]);this.root&&function r(s){const a=n[s.dimension],h=i(t,s.obj),l={};var u,c,f,m;function g(t,r){o.push([t,r]),o.size()>e&&o.pop()}for(m=0;m<n.length;m+=1)m===s.dimension?l[n[m]]=t[n[m]]:l[n[m]]=s.obj[n[m]];c=i(l,s.obj),null!==s.right||null!==s.left?(r(u=null===s.right?s.left:null===s.left?s.right:t[a]<s.obj[a]?s.left:s.right),(o.size()<e||h<o.peek()[1])&&g(s,h),(o.size()<e||Math.abs(c)<o.peek()[1])&&null!==(f=u===s.left?s.right:s.left)&&r(f)):(o.size()<e||h<o.peek()[1])&&g(s,h)}(this.root);const a=[];for(s=0;s<Math.min(e,o.content.length);s+=1)o.content[s][0]&&a.push([o.content[s][0].obj,o.content[s][1]]);return a}}function toJSONImpl(t){const e=new Node(t.obj,t.dimension,null);return t.left&&(e.left=toJSONImpl(t.left)),t.right&&(e.right=toJSONImpl(t.right)),e}function buildTree(t,e,r,i){const n=e%i.length;if(0===t.length)return null;if(1===t.length)return new Node(t[0],n,r);t.sort((t,e)=>t[i[n]]-e[i[n]]);const s=Math.floor(t.length/2),o=new Node(t[s],n,r);return o.left=buildTree(t.slice(0,s),e+1,o,i),o.right=buildTree(t.slice(s+1),e+1,o,i),o}function restoreParent(t){t.left&&(t.left.parent=t,restoreParent(t.left)),t.right&&(t.right.parent=t,restoreParent(t.right))}class BinaryHeap{constructor(t){this.content=[],this.scoreFunction=t}push(t){this.content.push(t),this.bubbleUp(this.content.length-1)}pop(){var t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.sinkDown(0)),t}peek(){return this.content[0]}size(){return this.content.length}bubbleUp(t){for(var e=this.content[t];t>0;){const r=Math.floor((t+1)/2)-1,i=this.content[r];if(!(this.scoreFunction(e)<this.scoreFunction(i)))break;this.content[r]=e,this.content[t]=i,t=r}}sinkDown(t){for(var e=this.content.length,r=this.content[t],i=this.scoreFunction(r);;){var n=2*(t+1),s=n-1,o=null;if(s<e){var a=this.content[s],h=this.scoreFunction(a);h<i&&(o=s)}if(n<e){var l=this.content[n];this.scoreFunction(l)<(null===o?i:h)&&(o=n)}if(null===o)break;this.content[t]=this.content[o],this.content[o]=r,t=o}}}class KNN{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!0===t){const t=e;return this.kdTree=new KDTree(t.kdTree,r),this.k=t.k,this.classes=new Set(t.classes),void(this.isEuclidean=t.isEuclidean)}const i=new Set(e),{distance:n=euclidean,k:s=i.size+1}=r,o=new Array(t.length);for(var a=0;a<o.length;++a)o[a]=t[a].slice();for(a=0;a<e.length;++a)o[a].push(e[a]);this.kdTree=new KDTree(o,n),this.k=s,this.classes=i,this.isEuclidean=n===euclidean}static load(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:euclidean;if("KNN"!==t.name)throw new Error("invalid model: ".concat(t.name));if(!t.isEuclidean&&e===euclidean)throw new Error("a custom distance function was used to create the model. Please provide it again");if(t.isEuclidean&&e!==euclidean)throw new Error("the model was created with the default distance function. Do not load it with another one");return new KNN(!0,t,e)}toJSON(){return{name:"KNN",kdTree:this.kdTree,k:this.k,classes:Array.from(this.classes),isEuclidean:this.isEuclidean}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return getSinglePrediction(this,t);if(Array.isArray(t[0])&&"number"==typeof t[0][0]){const r=new Array(t.length);for(var e=0;e<t.length;e++)r[e]=getSinglePrediction(this,t[e]);return r}}throw new TypeError("dataset to predict must be an array or a matrix")}}function getSinglePrediction(t,e){var r=t.kdTree.nearest(e,t.k),i={},n=-1,s=-1,o=r[0][0].length-1;for(var a of t.classes)i[a]=0;for(var h=0;h<r.length;++h){var l=r[h][0][o],u=++i[l];u>s&&(n=l,s=u)}return n}function norm(t){return Math.sqrt(t.clone().apply(pow2array).sum())}function pow2array(t,e){this.set(t,e,this.get(t,e)**2)}function initializeMatrices(t,e){if(e)for(var r=0;r<t.length;++r)for(var i=0;i<t[r].length;++i){var n=t[r][i];t[r][i]=null!==n?new Matrix(t[r][i]):void 0}else for(r=0;r<t.length;++r)t[r]=new Matrix(t[r]);return t}class PLS{constructor(t,e){if(!0===t)this.meanX=e.meanX,this.stdDevX=e.stdDevX,this.meanY=e.meanY,this.stdDevY=e.stdDevY,this.PBQ=Matrix.checkMatrix(e.PBQ),this.R2X=e.R2X,this.scale=e.scale,this.scaleMethod=e.scaleMethod,this.tolerance=e.tolerance;else{var{tolerance:r=1e-5,scale:i=!0}=t;this.tolerance=r,this.scale=i,this.latentVectors=t.latentVectors}}train(t,e){if(t=Matrix.checkMatrix(t),e=Matrix.checkMatrix(e),t.length!==e.length)throw new RangeError("The number of X rows must be equal to the number of Y rows");this.meanX=t.mean("column"),this.stdDevX=t.standardDeviation("column",{mean:this.meanX,unbiased:!0}),this.meanY=e.mean("column"),this.stdDevY=e.standardDeviation("column",{mean:this.meanY,unbiased:!0}),this.scale&&(t=t.clone().subRowVector(this.meanX).divRowVector(this.stdDevX),e=e.clone().subRowVector(this.meanY).divRowVector(this.stdDevY)),void 0===this.latentVectors&&(this.latentVectors=Math.min(t.rows-1,t.columns));for(var r=t.rows,i=t.columns,n=e.rows,s=e.columns,o=t.clone().mul(t).sum(),a=e.clone().mul(e).sum(),h=this.tolerance,l=this.latentVectors,u=Matrix.zeros(r,l),c=Matrix.zeros(i,l),f=Matrix.zeros(n,l),m=Matrix.zeros(s,l),g=Matrix.zeros(l,l),d=c.clone(),p=0;norm(e)>h&&p<l;){for(var w=t.transpose(),x=e.transpose(),M=maxSumColIndex(t.clone().mul(t)),y=maxSumColIndex(e.clone().mul(e)),v=t.getColumnVector(M),b=e.getColumnVector(y),S=Matrix.zeros(r,1);norm(v.clone().sub(S))>h;){var A=w.mmul(b);A.div(norm(A)),S=v,v=t.mmul(A);var E=x.mmul(v);E.div(norm(E)),b=e.mmul(E)}S=v;var R=w.mmul(S),k=S.transpose().mmul(S).get(0,0),C=R.div(k),T=norm(C);C.div(T),S.mul(T),A.mul(T),R=b.transpose().mmul(S),k=S.transpose().mmul(S).get(0,0);var N=R.div(k).get(0,0);t.sub(S.mmul(C.transpose())),e.sub(S.clone().mul(N).mmul(E.transpose())),u.setColumn(p,S),c.setColumn(p,C),f.setColumn(p,b),m.setColumn(p,E),d.setColumn(p,A),g.set(p,p,N),p++}p--,u=u.subMatrix(0,u.rows-1,0,p),c=c.subMatrix(0,c.rows-1,0,p),f=f.subMatrix(0,f.rows-1,0,p),m=m.subMatrix(0,m.rows-1,0,p),d=d.subMatrix(0,d.rows-1,0,p),g=g.subMatrix(0,p,0,p),this.ssqYcal=a,this.E=t,this.F=e,this.T=u,this.P=c,this.U=f,this.Q=m,this.W=d,this.B=g,this.PBQ=c.mmul(g).mmul(m.transpose()),this.R2X=S.transpose().mmul(S).mmul(C.transpose().mmul(C)).div(o).get(0,0)}predict(t){var e=Matrix.checkMatrix(t);this.scale&&(e=e.subRowVector(this.meanX).divRowVector(this.stdDevX));var r=e.mmul(this.PBQ);return r=r.mulRowVector(this.stdDevY).addRowVector(this.meanY)}getExplainedVariance(){return this.R2X}toJSON(){return{name:"PLS",R2X:this.R2X,meanX:this.meanX,stdDevX:this.stdDevX,meanY:this.meanY,stdDevY:this.stdDevY,PBQ:this.PBQ,tolerance:this.tolerance,scale:this.scale}}static load(t){if("PLS"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));return new PLS(!0,t)}}function maxSumColIndex(t){return Matrix.rowVector(t.sum("column")).maxIndex()[0]}class KOPLS{constructor(t,e){if(!0===t)this.trainingSet=new Matrix(e.trainingSet),this.YLoadingMat=new Matrix(e.YLoadingMat),this.SigmaPow=new Matrix(e.SigmaPow),this.YScoreMat=new Matrix(e.YScoreMat),this.predScoreMat=initializeMatrices(e.predScoreMat,!1),this.YOrthLoadingVec=initializeMatrices(e.YOrthLoadingVec,!1),this.YOrthEigen=e.YOrthEigen,this.YOrthScoreMat=initializeMatrices(e.YOrthScoreMat,!1),this.toNorm=initializeMatrices(e.toNorm,!1),this.TURegressionCoeff=initializeMatrices(e.TURegressionCoeff,!1),this.kernelX=initializeMatrices(e.kernelX,!0),this.kernel=e.kernel,this.orthogonalComp=e.orthogonalComp,this.predictiveComp=e.predictiveComp;else{if(void 0===t.predictiveComponents)throw new RangeError("no predictive components found!");if(void 0===t.orthogonalComponents)throw new RangeError("no orthogonal components found!");if(void 0===t.kernel)throw new RangeError("no kernel found!");this.orthogonalComp=t.orthogonalComponents,this.predictiveComp=t.predictiveComponents,this.kernel=t.kernel}}train(t,e){t=Matrix.checkMatrix(t),e=Matrix.checkMatrix(e),this.trainingSet=t.clone();var r=this.kernel.compute(t),i=Matrix.eye(r.rows,r.rows,1),n=r;r=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)r[t]=new Array(this.orthogonalComp+1);r[0][0]=n;var s=new SingularValueDecomposition(e.transpose().mmul(r[0][0]).mmul(e),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1}),o=s.leftSingularVectors,a=s.diagonalMatrix;o=o.subMatrix(0,o.rows-1,0,this.predictiveComp-1),a=a.subMatrix(0,this.predictiveComp-1,0,this.predictiveComp-1);var h=e.mmul(o),l=new Array(this.orthogonalComp+1),u=new Array(this.orthogonalComp+1),c=new Array(this.orthogonalComp),f=new Array(this.orthogonalComp),m=new Array(this.orthogonalComp),g=new Array(this.orthogonalComp),d=Matrix.pow(a,-.5);d.apply((function(t,e){this.get(t,e)===1/0&&this.set(t,e,0)}));for(var p=0;p<this.orthogonalComp;++p){l[p]=r[0][p].transpose().mmul(h).mmul(d);var w=l[p].transpose();u[p]=inverse(w.mmul(l[p])).mmul(w).mmul(h);var x=(s=new SingularValueDecomposition(w.mmul(Matrix.sub(r[p][p],l[p].mmul(w))).mmul(l[p]),{computeLeftSingularVectors:!0,computeRightSingularVectors:!1})).leftSingularVectors,M=s.diagonalMatrix;f[p]=x.subMatrix(0,x.rows-1,0,0),m[p]=M.get(0,0),c[p]=Matrix.sub(r[p][p],l[p].mmul(w)).mmul(l[p]).mmul(f[p]).mul(Math.pow(m[p],-.5));var y=c[p].transpose();g[p]=Matrix.sqrt(y.mmul(c[p])),c[p]=c[p].divRowVector(g[p]);var v=Matrix.sub(i,c[p].mmul(c[p].transpose()));r[0][p+1]=r[0][p].mmul(v),r[p+1][p+1]=v.mmul(r[p][p]).mmul(v)}var b=l[this.orthogonalComp]=r[0][this.orthogonalComp].transpose().mmul(h).mmul(d),S=b.transpose();u[this.orthogonalComp]=inverse(S.mmul(b)).mmul(S).mmul(h),this.YLoadingMat=o,this.SigmaPow=d,this.YScoreMat=h,this.predScoreMat=l,this.YOrthLoadingVec=f,this.YOrthEigen=m,this.YOrthScoreMat=c,this.toNorm=g,this.TURegressionCoeff=u,this.kernelX=r}predict(t){var e=this.kernel.compute(t,this.trainingSet),r=e;e=new Array(this.orthogonalComp+1);for(let t=0;t<this.orthogonalComp+1;t++)e[t]=new Array(this.orthogonalComp+1);e[0][0]=r;var i,n=new Array(this.orthogonalComp),s=new Array(this.orthogonalComp);for(i=0;i<this.orthogonalComp;++i){s[i]=e[i][0].mmul(this.YScoreMat).mmul(this.SigmaPow),n[i]=Matrix.sub(e[i][i],s[i].mmul(this.predScoreMat[i].transpose())).mmul(this.predScoreMat[i]).mmul(this.YOrthLoadingVec[i]).mul(Math.pow(this.YOrthEigen[i],-.5)),n[i]=n[i].divRowVector(this.toNorm[i]);var o=this.YOrthScoreMat[i].transpose();e[i+1][0]=Matrix.sub(e[i][0],n[i].mmul(o).mmul(this.kernelX[0][i].transpose()));var a=Matrix.sub(e[i][0],e[i][i].mmul(this.YOrthScoreMat[i]).mmul(o)),h=n[i].mmul(o).mmul(this.kernelX[i][i]),l=h.mmul(this.YOrthScoreMat[i]).mmul(o);e[i+1][i+1]=a.sub(h).add(l)}return s[i]=e[i][0].mmul(this.YScoreMat).mmul(this.SigmaPow),{prediction:s[i].mmul(this.TURegressionCoeff[i]).mmul(this.YLoadingMat.transpose()),predScoreMat:s,predYOrthVectors:n}}toJSON(){return{name:"K-OPLS",YLoadingMat:this.YLoadingMat,SigmaPow:this.SigmaPow,YScoreMat:this.YScoreMat,predScoreMat:this.predScoreMat,YOrthLoadingVec:this.YOrthLoadingVec,YOrthEigen:this.YOrthEigen,YOrthScoreMat:this.YOrthScoreMat,toNorm:this.toNorm,TURegressionCoeff:this.TURegressionCoeff,kernelX:this.kernelX,trainingSet:this.trainingSet,orthogonalComp:this.orthogonalComp,predictiveComp:this.predictiveComp}}static load(t,e){if("K-OPLS"!==t.name)throw new RangeError("Invalid model: ".concat(t.name));if(!e)throw new RangeError("You must provide a kernel for the model!");return t.kernel=e,new KOPLS(!0,t)}}class ConfusionMatrix{constructor(t,e){if(t.length!==t[0].length)throw new Error("Confusion matrix must be square");if(e.length!==t.length)throw new Error("Confusion matrix and labels should have the same length");this.labels=e,this.matrix=t}static fromLabels(t,e){let r,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(e.length!==t.length)throw new Error("predicted and actual must have the same length");r=i.labels?new Set(i.labels):new Set([...t,...e]),r=Array.from(r),i.sort&&r.sort(i.sort);const n=Array.from({length:r.length});for(let t=0;t<n.length;t++)n[t]=new Array(n.length),n[t].fill(0);for(let i=0;i<e.length;i++){const s=r.indexOf(t[i]),o=r.indexOf(e[i]);s>=0&&o>=0&&n[s][o]++}return new ConfusionMatrix(n,r)}getMatrix(){return this.matrix}getLabels(){return this.labels}getTotalCount(){let t=0;for(var e=0;e<this.matrix.length;e++)for(var r=0;r<this.matrix.length;r++)t+=this.matrix[e][r];return t}getTrueCount(){for(var t=0,e=0;e<this.matrix.length;e++)t+=this.matrix[e][e];return t}getFalseCount(){return this.getTotalCount()-this.getTrueCount()}getTruePositiveCount(t){const e=this.getIndex(t);return this.matrix[e][e]}getTrueNegativeCount(t){const e=this.getIndex(t);for(var r=0,i=0;i<this.matrix.length;i++)for(var n=0;n<this.matrix.length;n++)i!==e&&n!==e&&(r+=this.matrix[i][n]);return r}getFalsePositiveCount(t){const e=this.getIndex(t);for(var r=0,i=0;i<this.matrix.length;i++)i!==e&&(r+=this.matrix[i][e]);return r}getFalseNegativeCount(t){const e=this.getIndex(t);for(var r=0,i=0;i<this.matrix.length;i++)i!==e&&(r+=this.matrix[e][i]);return r}getPositiveCount(t){return this.getTruePositiveCount(t)+this.getFalseNegativeCount(t)}getNegativeCount(t){return this.getTrueNegativeCount(t)+this.getFalsePositiveCount(t)}getIndex(t){const e=this.labels.indexOf(t);if(-1===e)throw new Error("The label does not exist");return e}getTruePositiveRate(t){return this.getTruePositiveCount(t)/this.getPositiveCount(t)}getTrueNegativeRate(t){return this.getTrueNegativeCount(t)/this.getNegativeCount(t)}getPositivePredictiveValue(t){const e=this.getTruePositiveCount(t);return e/(e+this.getFalsePositiveCount(t))}getNegativePredictiveValue(t){const e=this.getTrueNegativeCount(t);return e/(e+this.getFalseNegativeCount(t))}getFalseNegativeRate(t){return 1-this.getTruePositiveRate(t)}getFalsePositiveRate(t){return 1-this.getTrueNegativeRate(t)}getFalseDiscoveryRate(t){const e=this.getFalsePositiveCount(t);return e/(e+this.getTruePositiveCount(t))}getFalseOmissionRate(t){const e=this.getFalseNegativeCount(t);return e/(e+this.getTruePositiveCount(t))}getF1Score(t){const e=this.getTruePositiveCount(t);return 2*e/(2*e+this.getFalsePositiveCount(t)+this.getFalseNegativeCount(t))}getMatthewsCorrelationCoefficient(t){const e=this.getTruePositiveCount(t),r=this.getTrueNegativeCount(t),i=this.getFalsePositiveCount(t),n=this.getFalseNegativeCount(t);return(e*r-i*n)/Math.sqrt((e+i)*(e+n)*(r+i)*(r+n))}getInformedness(t){return this.getTruePositiveRate(t)+this.getTrueNegativeRate(t)-1}getMarkedness(t){return this.getPositivePredictiveValue(t)+this.getNegativePredictiveValue(t)-1}getConfusionTable(t){return[[this.getTruePositiveCount(t),this.getFalseNegativeCount(t)],[this.getFalsePositiveCount(t),this.getTrueNegativeCount(t)]]}getAccuracy(){let t=0,e=0;for(var r=0;r<this.matrix.length;r++)for(var i=0;i<this.matrix.length;i++)r===i?t+=this.matrix[r][i]:e+=this.matrix[r][i];return t/(t+e)}getCount(t,e){const r=this.getIndex(t),i=this.getIndex(e);return this.matrix[r][i]}get accuracy(){return this.getAccuracy()}get total(){return this.getTotalCount()}}var src$1=ConfusionMatrix;const defaultOptions$6={mode:"index"};var src$2=function*(t,e,r){r=Object.assign({},defaultOptions$6,r);for(var i,n,s,o=new Array(e),a=new Array(t),h=new Array(e),l=new Array(e+2),u=0;u<e;u++)o[u]=u,h[u]=u<e-t?0:1;for(u=0;u<t;u++)a[u]=e-t+u;for(u=0;u<l.length;u++)l[u]=0===u?e+1:u<=e-t?0:u<=e?u-e+t:-2;function c(){var t,e,r;for(e=1;l[e]<=0;)e++;if(0===l[e-1]){for(t=e-1;1!==t;t--)l[t]=-1;l[e]=0,i=s=0,l[1]=1,n=e-1}else{e>1&&(l[e-1]=0);do{e++}while(l[e]>0);for(r=e-1,t=e;0===l[t];)l[t++]=-1;if(-1===l[t])l[t]=l[r],s=l[r]-1,i=t-1,n=r-1,l[r]=-1;else{if(t===l[0])return 0;l[e]=l[t],s=l[t]-1,l[t]=0,i=e-1,n=t-1}}return 1}if("index"===r.mode)for(yield a.slice();c();)a[s]=o[i],yield a.slice();else{if("mask"!==r.mode)throw new Error("Invalid mode");for(yield h.slice();c();)h[i]=1,h[n]=0,yield h.slice()}};const CV={};function check(t,e){if(t.length!==e.length)throw new Error("features and labels should have the same length")}function initMatrix(t,e){return new Array(t).fill(0).map(()=>new Array(e).fill(0))}function getDistinct(t){var e=new Set;for(let r=0;r<t.length;r++)e.add(t[r]);return Array.from(e)}function validate(t,e,r,i,n,s,o,a){const{testFeatures:h,trainFeatures:l,testLabels:u,trainLabels:c}=getTrainTest(e,r,n,s);var f;t.prototype.train?(f=new t(i)).train(l,c):f=new t(l,c,i),updateConfusionMatrix(o,u,f.predict(h),a)}function validateWithCallback(t,e,r,i,n,s,o){const{testFeatures:a,trainFeatures:h,testLabels:l,trainLabels:u}=getTrainTest(t,e,r,i);updateConfusionMatrix(n,l,o(h,u,a),s)}function updateConfusionMatrix(t,e,r,i){for(var n=0;n<r.length;n++){const s=i.indexOf(e[n]),o=i.indexOf(r[n]);(s<0||o<0)&&console.warn("ignore unknown predicted label ".concat(r[n])),t[s][o]++}}function getTrainTest(t,e,r,i){return{testFeatures:r.map((function(e){return t[e]})),trainFeatures:i.map((function(e){return t[e]})),testLabels:r.map((function(t){return e[t]})),trainLabels:i.map((function(t){return e[t]}))}}CV.leaveOneOut=function(t,e,r,i){if("function"==typeof r){var n=r;return r=e,e=t,CV.leavePOut(e,r,1,n)}return CV.leavePOut(t,e,r,i,1)},CV.leavePOut=function(t,e,r,i,n){if("function"==typeof i){var s=i;n=r,r=e,e=t}check(e,r);const o=getDistinct(r),a=initMatrix(o.length,o.length);var h=e.length,l=src$2(n,h),u=new Array(h);for(let t=0;t<h;t++)u[t]=t;for(const n of l){var c=u.slice();for(let t=n.length-1;t>=0;t--)c.splice(n[t],1);s?validateWithCallback(e,r,n,c,a,o,s):validate(t,e,r,i,n,c,a,o)}return new src$1(a,o)},CV.kFold=function(t,e,r,i,n){if("function"==typeof i){var s=i;n=r,r=e,e=t}check(e,r);const o=getDistinct(r),a=initMatrix(o.length,o.length);for(var h=e.length,l=new Array(h),u=0;u<h;u++)l[u]=u;for(var c=Math.floor(h/n),f=[],m=[];l.length;){var g=Math.floor(Math.random()*l.length);f.push(l[g]),l.splice(g,1),f.length===c&&(m.push(f),f=[])}for(f.length&&m.push(f),m=m.slice(0,n),u=0;u<m.length;u++){for(var d=m[u],p=[],w=0;w<m.length;w++)w!==u&&(p=p.concat(m[w]));s?validateWithCallback(e,r,d,p,a,o,s):validate(t,e,r,i,d,p,a,o)}return new src$1(a,o)};var src$3=CV;function logistic(t){return 1/(1+Math.exp(-t))}function expELU(t,e){return t<0?e*(Math.exp(t)-1):t}function softExponential(t,e){return e<0?-Math.log(1-e*(t+e))/e:e>0?(Math.exp(e*t)-1)/e+e:t}function softExponentialPrime(t,e){return e<0?1/(1-e*(e+t)):Math.exp(e*t)}const ACTIVATION_FUNCTIONS={tanh:{activation:Math.tanh,derivate:t=>1-t*t},identity:{activation:t=>t,derivate:()=>1},logistic:{activation:logistic,derivate:t=>logistic(t)*(1-logistic(t))},arctan:{activation:Math.atan,derivate:t=>1/(t*t+1)},softsign:{activation:t=>t/(1+Math.abs(t)),derivate:t=>1/((1+Math.abs(t))*(1+Math.abs(t)))},relu:{activation:t=>t<0?0:t,derivate:t=>t<0?0:1},softplus:{activation:t=>Math.log(1+Math.exp(t)),derivate:t=>1/(1+Math.exp(-t))},bent:{activation:t=>(Math.sqrt(t*t+1)-1)/2+t,derivate:t=>t/(2*Math.sqrt(t*t+1))+1},sinusoid:{activation:Math.sin,derivate:Math.cos},sinc:{activation:t=>0===t?1:Math.sin(t)/t,derivate:t=>0===t?0:Math.cos(t)/t-Math.sin(t)/(t*t)},gaussian:{activation:t=>Math.exp(-t*t),derivate:t=>-2*t*Math.exp(-t*t)},"parametric-relu":{activation:(t,e)=>t<0?e*t:t,derivate:(t,e)=>t<0?e:1},"exponential-elu":{activation:expELU,derivate:(t,e)=>t<0?expELU(t,e)+e:1},"soft-exponential":{activation:softExponential,derivate:softExponentialPrime}};class Layer{constructor(t){this.inputSize=t.inputSize,this.outputSize=t.outputSize,this.regularization=t.regularization,this.epsilon=t.epsilon,this.activation=t.activation,this.activationParam=t.activationParam;var e=ACTIVATION_FUNCTIONS[t.activation],r=e.activation.length,i=r>1?r=>e.activation(r,t.activationParam):e.activation,n=r>1?r=>e.derivate(r,t.activationParam):e.derivate;this.activationFunction=function(t,e){this.set(t,e,i(this.get(t,e)))},this.derivate=function(t,e){this.set(t,e,n(this.get(t,e)))},t.model?(this.W=Matrix.Matrix.checkMatrix(t.W),this.b=Matrix.Matrix.checkMatrix(t.b)):(this.W=Matrix.Matrix.rand(this.inputSize,this.outputSize),this.b=Matrix.Matrix.zeros(1,this.outputSize),this.W.apply((function(e,r){this.set(e,r,this.get(e,r)/Math.sqrt(t.inputSize))})))}forward(t){var e=t.mmul(this.W).addRowVector(this.b);return e.apply(this.activationFunction),this.a=e.clone(),e}backpropagation(t,e){this.dW=e.transpose().mmul(t),this.db=Matrix.Matrix.rowVector(t.sum("column"));var r=e.clone();return t.mmul(this.W.transpose()).mul(r.apply(this.derivate))}update(){this.dW.add(this.W.clone().mul(this.regularization)),this.W.add(this.dW.mul(-this.epsilon)),this.b.add(this.db.mul(-this.epsilon))}toJSON(){return{model:"Layer",inputSize:this.inputSize,outputSize:this.outputSize,regularization:this.regularization,epsilon:this.epsilon,activation:this.activation,W:this.W,b:this.b}}static load(t){if("Layer"!==t.model)throw new RangeError("the current model is not a Layer model");return new Layer(t)}}class OutputLayer extends Layer{constructor(t){super(t),this.activationFunction=function(t,e){this.set(t,e,Math.exp(this.get(t,e)))}}static load(t){if("Layer"!==t.model)throw new RangeError("the current model is not a Layer model");return new OutputLayer(t)}}class FeedForwardNeuralNetworks{constructor(t){if((t=t||{}).model){this.hiddenLayers=t.hiddenLayers,this.iterations=t.iterations,this.learningRate=t.learningRate,this.regularization=t.regularization,this.dicts=t.dicts,this.activation=t.activation,this.activationParam=t.activationParam,this.model=new Array(t.layers.length);for(var e=0;e<this.model.length-1;++e)this.model[e]=Layer.load(t.layers[e]);this.model[this.model.length-1]=OutputLayer.load(t.layers[this.model.length-1])}else this.hiddenLayers=t.hiddenLayers||[10],this.iterations=t.iterations||50,this.learningRate=t.learningRate||.01,this.regularization=t.regularization||.01,this.activation=t.activation||"tanh",this.activationParam=t.activationParam||1,this.activation in Object.keys(ACTIVATION_FUNCTIONS)||(this.activation="tanh")}buildNetwork(t,e){var r=this.hiddenLayers.length-1+2;this.model=new Array(r),this.model[0]=new Layer({inputSize:t,outputSize:this.hiddenLayers[0],activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate});for(var i=1;i<this.hiddenLayers.length;++i)this.model[i]=new Layer({inputSize:this.hiddenLayers[i-1],outputSize:this.hiddenLayers[i],activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate});this.model[r-1]=new OutputLayer({inputSize:this.hiddenLayers[this.hiddenLayers.length-1],outputSize:e,activation:this.activation,activationParam:this.activationParam,regularization:this.regularization,epsilon:this.learningRate})}train(t,e){t=Matrix.Matrix.checkMatrix(t),this.dicts=dictOutputs(e);var r=t.columns,i=Object.keys(this.dicts.inputs).length;this.model||this.buildNetwork(r,i);for(var n=0;n<this.iterations;++n){var s=this.propagate(t);this.backpropagation(t,e,s)}}propagate(t){for(var e=t,r=0;r<this.model.length;++r)e=this.model[r].forward(e);return e.divColumnVector(e.sum("row"))}backpropagation(t,e,r){for(var i=0;i<r.rows;++i)r.set(i,this.dicts.inputs[e[i]],r.get(i,this.dicts.inputs[e[i]])-1);var n=r;for(i=this.model.length-1;i>=0;--i){var s=i>0?this.model[i-1].a:t;n=this.model[i].backpropagation(n,s)}for(i=0;i<this.model.length;++i)this.model[i].update()}predict(t){t=Matrix.Matrix.checkMatrix(t);for(var e=new Array(t.rows),r=this.propagate(t),i=0;i<t.rows;++i)e[i]=this.dicts.outputs[r.maxRowIndex(i)[1]];return e}toJSON(){for(var t={model:"FNN",hiddenLayers:this.hiddenLayers,iterations:this.iterations,learningRate:this.learningRate,regularization:this.regularization,activation:this.activation,activationParam:this.activationParam,dicts:this.dicts,layers:new Array(this.model.length)},e=0;e<this.model.length;++e)t.layers[e]=this.model[e].toJSON();return t}static load(t){if("FNN"!==t.model)throw new RangeError("the current model is not a feed forward network");return new FeedForwardNeuralNetworks(t)}}function dictOutputs(t){for(var e={},r={},i=0,n=0;n<t.length;n+=1)void 0===e[t[n]]&&(e[t[n]]=i,r[i]=t[n],i++);return{inputs:e,outputs:r}}var FeedForwardNeuralNetwork=FeedForwardNeuralNetworks;function NodeSquare(t,e,r,i){this.x=t,this.y=e,this.weights=r,this.som=i,this.neighbors={}}NodeSquare.prototype.adjustWeights=function(t,e,r){for(var i=0,n=this.weights.length;i<n;i++)this.weights[i]+=e*r*(t[i]-this.weights[i])},NodeSquare.prototype.getDistance=function(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))},NodeSquare.prototype.getDistanceTorus=function(t){var e=Math.abs(this.x-t.x),r=Math.abs(this.y-t.y);return Math.max(Math.min(e,this.som.gridDim.x-e),Math.min(r,this.som.gridDim.y-r))},NodeSquare.prototype.getNeighbors=function(t){if(!this.neighbors[t]){var e,r,i,n;if(this.neighbors[t]=new Array(2),this[t]>0?e=this[t]-1:this.som.torus&&(e=this.som.gridDim[t]-1),void 0!==e)"x"===t?(r=e,i=this.y):(r=this.x,i=e),this.neighbors[t][0]=this.som.nodes[r][i];this[t]<this.som.gridDim[t]-1?n=this[t]+1:this.som.torus&&(n=0),void 0!==n&&("x"===t?(r=n,i=this.y):(r=this.x,i=n),this.neighbors[t][1]=this.som.nodes[r][i])}return this.neighbors[t]},NodeSquare.prototype.getPos=function(t,e){var r,i,n=this.getNeighbors(t),s=this.som.distance;n[0]?n[1]?s(e,n[0].weights)<s(e,n[1].weights)?(r=n[0],i=-1):(r=n[1],i=1):(r=n[0],i=-1):(r=n[1],i=1);var o=1-s(e,this.weights),a=1-s(e,r.weights);return.5+.5*((o-a)/(2-o-a))*i},NodeSquare.prototype.getPosition=function(t){return[this.getPos("x",t),this.getPos("y",t)]};var nodeSquare=NodeSquare;function NodeHexagonal(t,e,r,i){nodeSquare.call(this,t,e,r,i),this.hX=t-Math.floor(e/2),this.z=0-this.hX-e}NodeHexagonal.prototype=new nodeSquare,NodeHexagonal.prototype.constructor=NodeHexagonal,NodeHexagonal.prototype.getDistance=function(t){return Math.max(Math.abs(this.hX-t.hX),Math.abs(this.y-t.y),Math.abs(this.z-t.z))},NodeHexagonal.prototype.getDistanceTorus=function(t){var e=Math.abs(this.hX-t.hX),r=Math.abs(this.y-t.y),i=Math.abs(this.z-t.z);return Math.max(Math.min(e,this.som.gridDim.x-e),Math.min(r,this.som.gridDim.y-r),Math.min(i,this.som.gridDim.z-i))},NodeHexagonal.prototype.getPosition=function(){throw new Error("Unimplemented : cannot get position of the points for hexagonal grid")};var nodeHexagonal=NodeHexagonal,defaultOptions$7={fields:3,randomizer:Math.random,distance:squareEuclidean,iterations:10,learningRate:.1,gridType:"rect",torus:!0,method:"random"};function SOM(t,e,r,i){for(var n in this.x=t,this.y=e,r=r||{},this.options={},defaultOptions$7)r.hasOwnProperty(n)?this.options[n]=r[n]:this.options[n]=defaultOptions$7[n];if("number"==typeof this.options.fields)this.numWeights=this.options.fields;else{if(!Array.isArray(this.options.fields))throw new Error("Invalid fields definition");this.numWeights=this.options.fields.length;var s=getConverters(this.options.fields);this.extractor=s.extractor,this.creator=s.creator}if("rect"===this.options.gridType)this.nodeType=nodeSquare,this.gridDim={x:t,y:e};else{this.nodeType=nodeHexagonal;var o=this.x-Math.floor(this.y/2);this.gridDim={x:o,y:this.y,z:-(0-o-this.y)}}if(this.torus=this.options.torus,this.distanceMethod=this.torus?"getDistanceTorus":"getDistance",this.distance=this.options.distance,this.maxDistance=getMaxDistance(this.distance,this.numWeights),!0!==i){if(!(t>0&&e>0))throw new Error("x and y must be positive");this.times={findBMU:0,adjust:0},this.randomizer=this.options.randomizer,this.iterationCount=0,this.iterations=this.options.iterations,this.startLearningRate=this.learningRate=this.options.learningRate,this.mapRadius=Math.floor(Math.max(t,e)/2),this.algorithmMethod=this.options.method,this._initNodes(),this.done=!1}else this.done=!0}function getConverters(t){for(var e=t.length,r=new Array(e),i=new Array(e),n=0;n<e;n++)r[n]=getNormalizer(t[n].range),i[n]=getDenormalizer(t[n].range);return{extractor:function(i){for(var n=new Array(e),s=0;s<e;s++)n[s]=r[s](i[t[s].name]);return n},creator:function(r){for(var n={},s=0;s<e;s++)n[t[s].name]=i[s](r[s]);return n}}}function getNormalizer(t){return function(e){return(e-t[0])/(t[1]-t[0])}}function getDenormalizer(t){return function(e){return t[0]+e*(t[1]-t[0])}}function squareEuclidean(t,e){for(var r=0,i=0,n=t.length;i<n;i++)r+=(t[i]-e[i])*(t[i]-e[i]);return r}function getRandomValue(t,e){return t[Math.floor(e()*t.length)]}function getMaxDistance(t,e){for(var r=new Array(e),i=new Array(e),n=0;n<e;n++)r[n]=0,i[n]=1;return t(r,i)}SOM.load=function loadModel(model,distance){if("SOM"===model.name){var x=model.data.length,y=model.data[0].length;distance?model.options.distance=distance:model.options.distance&&(model.options.distance=eval("("+model.options.distance+")"));var som=new SOM(x,y,model.options,!0);som.nodes=new Array(x);for(var i=0;i<x;i++){som.nodes[i]=new Array(y);for(var j=0;j<y;j++)som.nodes[i][j]=new som.nodeType(i,j,model.data[i][j],som)}return som}throw new Error("expecting a SOM model")},SOM.prototype.export=function(t){if(!this.done)throw new Error("model is not ready yet");var e={name:"SOM"};e.options={fields:this.options.fields,gridType:this.options.gridType,torus:this.options.torus},e.data=new Array(this.x);for(var r=0;r<this.x;r++){e.data[r]=new Array(this.y);for(var i=0;i<this.y;i++)e.data[r][i]=this.nodes[r][i].weights}return t&&(e.options.distance=this.distance.toString()),e},SOM.prototype._initNodes=function(){var t,e,r,i=Date.now();for(this.nodes=new Array(this.x),t=0;t<this.x;t++)for(this.nodes[t]=new Array(this.y),e=0;e<this.y;e++){var n=new Array(this.numWeights);for(r=0;r<this.numWeights;r++)n[r]=this.randomizer();this.nodes[t][e]=new this.nodeType(t,e,n,this)}this.times.initNodes=Date.now()-i},SOM.prototype.setTraining=function(t){if(this.trainingSet)throw new Error("training set has already been set");var e,r=Date.now(),i=t,n=t.length;if(this.extractor)for(i=new Array(n),e=0;e<n;e++)i[e]=this.extractor(t[e]);this.numIterations=this.iterations*n,"random"===this.algorithmMethod?this.timeConstant=this.numIterations/Math.log(this.mapRadius):this.timeConstant=n/Math.log(this.mapRadius),this.trainingSet=i,this.times.setTraining=Date.now()-r},SOM.prototype.trainOne=function(){return!this.done&&(this.numIterations-- >0?("random"===this.algorithmMethod?(t=this.mapRadius*Math.exp(-this.iterationCount/this.timeConstant),e=getRandomValue(this.trainingSet,this.randomizer),this._adjust(e,t),this.learningRate=this.startLearningRate*Math.exp(-this.iterationCount/this.numIterations)):(r=-Math.floor(this.iterationCount/this.trainingSet.length),t=this.mapRadius*Math.exp(r/this.timeConstant),e=this.trainingSet[this.iterationCount%this.trainingSet.length],this._adjust(e,t),(this.iterationCount+1)%this.trainingSet.length==0&&(this.learningRate=this.startLearningRate*Math.exp(r/Math.floor(this.numIterations/this.trainingSet.length)))),this.iterationCount++,!0):(this.done=!0,!1));var t,e,r},SOM.prototype._adjust=function(t,e){var r,i,n,s,o=Date.now(),a=this._findBestMatchingUnit(t),h=Date.now();this.times.findBMU+=h-o;var l=Math.floor(e),u=a.x-l,c=a.x+l,f=a.y-l,m=a.y+l;for(r=u;r<=c;r++){var g=r;for(r<0?g+=this.x:r>=this.x&&(g-=this.x),i=f;i<=m;i++){var d=i;i<0?d+=this.y:i>=this.y&&(d-=this.y),(n=a[this.distanceMethod](this.nodes[g][d]))<e&&(s=Math.exp(-n/(2*e)),this.nodes[g][d].adjustWeights(t,this.learningRate,s))}}this.times.adjust+=Date.now()-h},SOM.prototype.train=function(t){if(!this.done)for(this.setTraining(t);this.trainOne(););},SOM.prototype.getConvertedNodes=function(){for(var t=new Array(this.x),e=0;e<this.x;e++){t[e]=new Array(this.y);for(var r=0;r<this.y;r++){var i=this.nodes[e][r];t[e][r]=this.creator?this.creator(i.weights):i.weights}}return t},SOM.prototype._findBestMatchingUnit=function(t){for(var e,r,i=1/0,n=0;n<this.x;n++)for(var s=0;s<this.y;s++)(r=this.distance(this.nodes[n][s].weights,t))<i&&(i=r,e=this.nodes[n][s]);return e},SOM.prototype.predict=function(t,e){if("boolean"==typeof t&&(e=t,t=null),t||(t=this.trainingSet),Array.isArray(t)&&(Array.isArray(t[0])||"object"==typeof t[0])){var r=this;return t.map((function(t){return r._predict(t,e)}))}return this._predict(t,e)},SOM.prototype._predict=function(t,e){Array.isArray(t)||(t=this.extractor(t));var r=this._findBestMatchingUnit(t),i=[r.x,r.y];return e&&(i[2]=r.getPosition(t)),i},SOM.prototype.getQuantizationError=function(){for(var t=this.getFit(),e=t.length,r=0,i=0;i<e;i++)r+=t[i];return r/e},SOM.prototype.getFit=function(t){t||(t=this.trainingSet);for(var e,r=t.length,i=new Array(r),n=0;n<r;n++)e=this._findBestMatchingUnit(t[n]),i[n]=Math.sqrt(this.distance(t[n],e.weights));return i};var src$4=SOM;function maybeToPrecision(t,e){return t<0?(t=0-t,"- ".concat("number"==typeof e?t.toPrecision(e):t.toString())):"number"==typeof e?t.toPrecision(e):t.toString()}function checkArraySize(t,e){if(!Array.isArray(t)||!Array.isArray(e))throw new TypeError("x and y must be arrays");if(t.length!==e.length)throw new RangeError("x and y arrays must have the same length")}class BaseRegression{constructor(){if(new.target===BaseRegression)throw new Error("BaseRegression must be subclassed")}predict(t){if("number"==typeof t)return this._predict(t);if(Array.isArray(t)){const e=[];for(let r=0;r<t.length;r++)e.push(this._predict(t[r]));return e}throw new TypeError("x must be a number or array")}_predict(){throw new Error("_predict must be implemented")}train(){}toString(){return""}toLaTeX(){return""}score(t,e){if(!Array.isArray(t)||!Array.isArray(e)||t.length!==e.length)throw new Error("x and y must be arrays of the same length");const r=t.length,i=new Array(r);for(let e=0;e<r;e++)i[e]=this._predict(t[e]);let n=0,s=0,o=0,a=0,h=0,l=0,u=0;for(let t=0;t<r;t++)n+=i[t],s+=e[t],h+=i[t]*i[t],l+=e[t]*e[t],u+=i[t]*e[t],0!==e[t]&&(o+=(e[t]-i[t])*(e[t]-i[t])/e[t]),a+=(e[t]-i[t])*(e[t]-i[t]);const c=(r*u-n*s)/Math.sqrt((r*h-n*n)*(r*l-s*s));return{r:c,r2:c*c,chi2:o,rmsd:Math.sqrt(a/r)}}}class PolynomialRegression extends BaseRegression{constructor(t,e,r){super(),!0===t?(this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients):(checkArraySize(t,e),regress(this,t,e,r))}_predict(t){let e=0;for(let r=0;r<this.powers.length;r++)e+=this.coefficients[r]*Math.pow(t,this.powers[r]);return e}toJSON(){return{name:"polynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",i="",n=" * ";e&&(r="^{",i="}",n="");let s="",o="";for(let e=0;e<this.coefficients.length;e++)o="",0!==this.coefficients[e]&&(o=0===this.powers[e]?maybeToPrecision(this.coefficients[e],t):1===this.powers[e]?"".concat(maybeToPrecision(this.coefficients[e],t)+n,"x"):"".concat(maybeToPrecision(this.coefficients[e],t)+n,"x").concat(r).concat(this.powers[e]).concat(i),this.coefficients[e]>0&&e!==this.coefficients.length-1?o=" + ".concat(o):e!==this.coefficients.length-1&&(o=" ".concat(o))),s=o+s;return"+"===s.charAt(0)&&(s=s.slice(1)),"f(x) = ".concat(s)}static load(t){if("polynomialRegression"!==t.name)throw new TypeError("not a polynomial regression model");return new PolynomialRegression(!0,t)}}function regress(t,e,r,i){const n=e.length;let s;if(Array.isArray(i))i=(s=i).length;else{i++,s=new Array(i);for(let t=0;t<i;t++)s[t]=t}const o=new Matrix(n,i),a=new Matrix([r]);for(let t=0;t<i;t++)for(let r=0;r<n;r++)0===s[t]?o.set(r,t,1):o.set(r,t,Math.pow(e[r],s[t]));const h=new MatrixTransposeView(o),l=h.mmul(o),u=h.mmul(new MatrixTransposeView(a));t.degree=i-1,t.powers=s,t.coefficients=solve(l,u).to1DArray()}class SimpleLinearRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=[e.intercept,e.slope]):(checkArraySize(t,e),regress$1(this,t,e))}toJSON(){return{name:"simpleLinearRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){let e="f(x) = ";if(0!==this.slope){const r=maybeToPrecision(this.slope,t);if(e+="".concat("1"===r?"":"".concat(r," * "),"x"),0!==this.intercept){const r=Math.abs(this.intercept),i=r===this.intercept?"+":"-";e+=" ".concat(i," ").concat(maybeToPrecision(r,t))}}else e+=maybeToPrecision(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("simpleLinearRegression"!==t.name)throw new TypeError("not a SLR model");return new SimpleLinearRegression(!0,t)}}function regress$1(t,e,r){const i=e.length;let n=0,s=0,o=0,a=0;for(let t=0;t<i;t++)n+=e[t],s+=r[t],o+=e[t]*e[t],a+=e[t]*r[t];const h=i*a-n*s;t.slope=h/(i*o-n*n),t.intercept=1/i*s-t.slope*(1/i)*n,t.coefficients=[t.intercept,t.slope]}class ExponentialRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(checkArraySize(t,e),regress$2(this,t,e))}_predict(t){return this.B*Math.exp(t*this.A)}toJSON(){return{name:"exponentialRegression",A:this.A,B:this.B}}toString(t){return"f(x) = ".concat(maybeToPrecision(this.B,t)," * e^(").concat(maybeToPrecision(this.A,t)," * x)")}toLaTeX(t){return this.A>=0?"f(x) = ".concat(maybeToPrecision(this.B,t),"e^{").concat(maybeToPrecision(this.A,t),"x}"):"f(x) = \\frac{".concat(maybeToPrecision(this.B,t),"}{e^{").concat(maybeToPrecision(-this.A,t),"x}}")}static load(t){if("exponentialRegression"!==t.name)throw new TypeError("not a exponential regression model");return new ExponentialRegression(!0,t)}}function regress$2(t,e,r){const i=e.length,n=new Array(i);for(let t=0;t<i;t++)n[t]=Math.log(r[t]);const s=new SimpleLinearRegression(e,n);t.A=s.slope,t.B=Math.exp(s.intercept)}class PowerRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.A=e.A,this.B=e.B):(checkArraySize(t,e),regress$3(this,t,e))}_predict(t){return this.A*Math.pow(t,this.B)}toJSON(){return{name:"powerRegression",A:this.A,B:this.B}}toString(t){return"f(x) = ".concat(maybeToPrecision(this.A,t)," * x^").concat(maybeToPrecision(this.B,t))}toLaTeX(t){let e="";return e=(e=this.B>=0?"f(x) = ".concat(maybeToPrecision(this.A,t),"x^{").concat(maybeToPrecision(this.B,t),"}"):"f(x) = \\frac{".concat(maybeToPrecision(this.A,t),"}{x^{").concat(maybeToPrecision(-this.B,t),"}}")).replace(/e([+-]?[0-9]+)/g,"e^{$1}")}static load(t){if("powerRegression"!==t.name)throw new TypeError("not a power regression model");return new PowerRegression(!0,t)}}function regress$3(t,e,r){const i=e.length,n=new Array(i),s=new Array(i);for(let t=0;t<i;t++)n[t]=Math.log(e[t]),s[t]=Math.log(r[t]);const o=new SimpleLinearRegression(n,s);t.A=Math.exp(o.intercept),t.B=o.slope}class MultivariateLinearRegression{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{intercept:i=!0,statistics:n=!0}=r;if(this.statistics=n,!0===t)this.weights=e.weights,this.inputs=e.inputs,this.outputs=e.outputs,this.intercept=e.intercept;else{t=new Matrix(t),e=new Matrix(e),i&&t.addColumn(new Array(t.rows).fill(1));let r=t.transpose();const s=r.mmul(t),o=r.mmul(e),a=new SingularValueDecomposition(s).inverse(),h=o.transpose().mmul(a).transpose();if(this.weights=h.to2DArray(),this.inputs=t.columns,this.outputs=e.columns,i&&this.inputs--,this.intercept=i,n){const r=t.mmul(h),i=e.clone().addM(r.neg()).to2DArray().map(t=>Math.pow(t[0],2)).reduce((t,e)=>t+e)/(e.rows-t.columns);this.stdError=Math.sqrt(i),this.stdErrorMatrix=pseudoInverse(s).mul(i),this.stdErrors=this.stdErrorMatrix.diagonal().map(t=>Math.sqrt(t)),this.tStats=this.weights.map((t,e)=>0===this.stdErrors[e]?0:t[0]/this.stdErrors[e])}}}predict(t){if(Array.isArray(t)){if("number"==typeof t[0])return this._predict(t);if(Array.isArray(t[0])){const e=new Array(t.length);for(let r=0;r<t.length;r++)e[r]=this._predict(t[r]);return e}}else if(Matrix.isMatrix(t)){const e=new Matrix(t.rows,this.outputs);for(let r=0;r<t.rows;r++)e.setRow(r,this._predict(t.getRow(r)));return e}throw new TypeError("x must be a matrix or array of numbers")}_predict(t){const e=new Array(this.outputs);if(this.intercept)for(let t=0;t<this.outputs;t++)e[t]=this.weights[this.inputs][t];else e.fill(0);for(let r=0;r<this.inputs;r++)for(let i=0;i<this.outputs;i++)e[i]+=this.weights[r][i]*t[r];return e}score(){throw new Error("score method is not implemented yet")}toJSON(){return{name:"multivariateLinearRegression",weights:this.weights,inputs:this.inputs,outputs:this.outputs,intercept:this.intercept,summary:this.statistics?{regressionStatistics:{standardError:this.stdError,observations:this.outputs},variables:this.weights.map((t,e)=>({label:e===this.weights.length-1?"Intercept":"X Variable ".concat(e+1),coefficients:t,standardError:this.stdErrors[e],tStat:this.tStats[e]}))}:void 0}}static load(t){if("multivariateLinearRegression"!==t.name)throw new Error("not a MLR model");return new MultivariateLinearRegression(!0,t)}}const{squaredEuclidean:squaredEuclidean$1}=euclidean$1,defaultOptions$8={sigma:1};class GaussianKernel{constructor(t){t=Object.assign({},defaultOptions$8,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=squaredEuclidean$1(t,e);return Math.exp(-r/this.divisor)}}var gaussianKernel=GaussianKernel;const defaultOptions$9={degree:1,constant:1,scale:1};class PolynomialKernel{constructor(t){t=Object.assign({},defaultOptions$9,t),this.degree=t.degree,this.constant=t.constant,this.scale=t.scale}compute(t,e){for(var r=0,i=0;i<t.length;i++)r+=t[i]*e[i];return Math.pow(this.scale*r+this.constant,this.degree)}}var polynomialKernel=PolynomialKernel;const defaultOptions$a={alpha:.01,constant:-Math.E};class SigmoidKernel{constructor(t){t=Object.assign({},defaultOptions$a,t),this.alpha=t.alpha,this.constant=t.constant}compute(t,e){for(var r=0,i=0;i<t.length;i++)r+=t[i]*e[i];return Math.tanh(this.alpha*r+this.constant)}}var sigmoidKernel=SigmoidKernel;const defaultOptions$b={sigma:1,degree:1};class ANOVAKernel{constructor(t){t=Object.assign({},defaultOptions$b,t),this.sigma=t.sigma,this.degree=t.degree}compute(t,e){for(var r=0,i=Math.min(t.length,e.length),n=1;n<=i;++n)r+=Math.pow(Math.exp(-this.sigma*Math.pow(Math.pow(t[n-1],n)-Math.pow(e[n-1],n),2)),this.degree);return r}}var anovaKernel=ANOVAKernel;const{squaredEuclidean:squaredEuclidean$2}=euclidean$1,defaultOptions$c={sigma:1};class CauchyKernel{constructor(t){t=Object.assign({},defaultOptions$c,t),this.sigma=t.sigma}compute(t,e){return 1/(1+squaredEuclidean$2(t,e)/(this.sigma*this.sigma))}}var cauchyKernel=CauchyKernel;const{euclidean:euclidean$2}=euclidean$1,defaultOptions$d={sigma:1};class ExponentialKernel{constructor(t){t=Object.assign({},defaultOptions$d,t),this.sigma=t.sigma,this.divisor=2*t.sigma*t.sigma}compute(t,e){const r=euclidean$2(t,e);return Math.exp(-r/this.divisor)}}var exponentialKernel=ExponentialKernel;class HistogramIntersectionKernel{compute(t,e){for(var r=Math.min(t.length,e.length),i=0,n=0;n<r;++n)i+=Math.min(t[n],e[n]);return i}}var histogramIntersectionKernel=HistogramIntersectionKernel;const{euclidean:euclidean$3}=euclidean$1,defaultOptions$e={sigma:1};class LaplacianKernel{constructor(t){t=Object.assign({},defaultOptions$e,t),this.sigma=t.sigma}compute(t,e){const r=euclidean$3(t,e);return Math.exp(-r/this.sigma)}}var laplacianKernel=LaplacianKernel;const{squaredEuclidean:squaredEuclidean$3}=euclidean$1,defaultOptions$f={constant:1};class MultiquadraticKernel{constructor(t){t=Object.assign({},defaultOptions$f,t),this.constant=t.constant}compute(t,e){return Math.sqrt(squaredEuclidean$3(t,e)+this.constant*this.constant)}}var multiquadraticKernel=MultiquadraticKernel;const{squaredEuclidean:squaredEuclidean$4}=euclidean$1,defaultOptions$g={constant:1};class RationalQuadraticKernel{constructor(t){t=Object.assign({},defaultOptions$g,t),this.constant=t.constant}compute(t,e){const r=squaredEuclidean$4(t,e);return 1-r/(r+this.constant)}}var rationalQuadraticKernel=RationalQuadraticKernel;const{Matrix:Matrix$1,MatrixTransposeView:MatrixTransposeView$1}=Matrix,kernelType={gaussian:gaussianKernel,rbf:gaussianKernel,polynomial:polynomialKernel,poly:polynomialKernel,anova:anovaKernel,cauchy:cauchyKernel,exponential:exponentialKernel,histogram:histogramIntersectionKernel,min:histogramIntersectionKernel,laplacian:laplacianKernel,multiquadratic:multiquadraticKernel,rational:rationalQuadraticKernel,sigmoid:sigmoidKernel,mlp:sigmoidKernel};class Kernel{constructor(t,e){if(this.kernelType=t,"linear"!==t)if("string"==typeof t){t=t.toLowerCase();var r=kernelType[t];if(!r)throw new Error("unsupported kernel type: ".concat(t));this.kernelFunction=new r(e)}else{if("object"!=typeof t||"function"!=typeof t.compute)throw new TypeError("first argument must be a valid kernel type or instance");this.kernelFunction=t}}compute(t,e){if(t=Matrix$1.checkMatrix(t),e=void 0===e?t:Matrix$1.checkMatrix(e),"linear"===this.kernelType)return t.mmul(new MatrixTransposeView$1(e));const r=new Matrix$1(t.rows,e.rows);if(t===e)for(let e=0;e<t.rows;e++)for(let i=e;i<t.rows;i++){const n=this.kernelFunction.compute(t.getRow(e),t.getRow(i));r.set(e,i,n),r.set(i,e,n)}else for(let i=0;i<t.rows;i++)for(let n=0;n<e.rows;n++)r.set(i,n,this.kernelFunction.compute(t.getRow(i),e.getRow(n)));return r}}var kernel=Kernel;class TheilSenRegression extends BaseRegression{constructor(t,e){super(),!0===t?(this.slope=e.slope,this.intercept=e.intercept,this.coefficients=e.coefficients):(checkArraySize(t,e),theilSen(this,t,e))}toJSON(){return{name:"TheilSenRegression",slope:this.slope,intercept:this.intercept}}_predict(t){return this.slope*t+this.intercept}computeX(t){return(t-this.intercept)/this.slope}toString(t){var e="f(x) = ";if(this.slope){var r=maybeToPrecision(this.slope,t);if(e+="".concat(Math.abs(r-1)<1e-5?"":"".concat(r," * "),"x"),this.intercept){var i=Math.abs(this.intercept),n=i===this.intercept?"+":"-";e+=" ".concat(n," ").concat(maybeToPrecision(i,t))}}else e+=maybeToPrecision(this.intercept,t);return e}toLaTeX(t){return this.toString(t)}static load(t){if("TheilSenRegression"!==t.name)throw new TypeError("not a Theil-Sen model");return new TheilSenRegression(!0,t)}}function theilSen(t,e,r){let i=e.length,n=new Array(i*i),s=0;for(let t=0;t<i;++t)for(let o=t+1;o<i;++o)e[t]!==e[o]&&(n[s++]=(r[o]-r[t])/(e[o]-e[t]));n.length=s;let o=median(n),a=new Array(i);for(let t=0;t<i;++t)a[t]=r[t]-o*e[t];t.slope=o,t.intercept=median(a),t.coefficients=[t.intercept,t.slope]}class RobustPolynomialRegression extends BaseRegression{constructor(t,e,r){super(),!0===t?(this.degree=e.degree,this.powers=e.powers,this.coefficients=e.coefficients):(checkArraySize(t,e),robustPolynomial(this,t,e,r))}toJSON(){return{name:"robustPolynomialRegression",degree:this.degree,powers:this.powers,coefficients:this.coefficients}}_predict(t){return predict(t,this.powers,this.coefficients)}toString(t){return this._toFormula(t,!1)}toLaTeX(t){return this._toFormula(t,!0)}_toFormula(t,e){let r="^",i="",n=" * ";e&&(r="^{",i="}",n="");let s="",o="";for(let e=0;e<this.coefficients.length;e++)o="",0!==this.coefficients[e]&&(o=0===this.powers[e]?maybeToPrecision(this.coefficients[e],t):1===this.powers[e]?"".concat(maybeToPrecision(this.coefficients[e],t)+n,"x"):"".concat(maybeToPrecision(this.coefficients[e],t)+n,"x").concat(r).concat(this.powers[e]).concat(i),this.coefficients[e]>0&&e!==this.coefficients.length-1?o=" + ".concat(o):e!==this.coefficients.length-1&&(o=" ".concat(o))),s=o+s;return"+"===s.charAt(0)&&(s=s.slice(1)),"f(x) = ".concat(s)}static load(t){if("robustPolynomialRegression"!==t.name)throw new TypeError("not a RobustPolynomialRegression model");return new RobustPolynomialRegression(!0,t)}}function robustPolynomial(t,e,r,i){let n=Array(i).fill(0).map((t,e)=>e);const s=getRandomTuples(e,r,i);for(var o,a=0;a<s.length;a++){for(var h=calcCoefficients(s[a],n),l=e.slice(),u=0;u<e.length;u++)l[u]=r[u]-predict(e[u],n,h),l[u]={residual:l[u]*l[u],coefficients:h};var c=residualsMedian(l);(!o||c.residual<o.residual)&&(o=c)}t.degree=i,t.powers=n,t.coefficients=o.coefficients}function getRandomTuples(t,e,r){for(var i=Math.floor(t.length/r),n=new Array(i),s=0;s<t.length;s++){for(var o=Math.floor(Math.random()*i),a=0;a<t.length;){if(!n[o]){n[o]=[{x:t[s],y:e[s]}];break}if(n[o].length<r){n[o].push({x:t[s],y:e[s]});break}a++,o=(o+1)%i}if(a===t.length)return n}return n}function calcCoefficients(t,e){for(var r=t.slice(),i=t.slice(),n=0;n<r.length;n++){i[n]=[t[n].y],r[n]=new Array(e.length);for(var s=0;s<e.length;s++)r[n][s]=Math.pow(t[n].x,e[s])}return solve(r,i).to1DArray()}function predict(t,e,r){let i=0;for(let n=0;n<e.length;n++)i+=r[n]*Math.pow(t,e[n]);return i}function residualsMedian(t){t.sort((t,e)=>t.residual-e.residual);var e=t.length,r=Math.floor(e/2);return e%2==0?t[r-1]:t[r]}function errorCalculation(t,e,r){var i=0;const n=r(e);for(var s=0;s<t.x.length;s++)i+=Math.abs(t.y[s]-n(t.x[s]));return i}function gradientFunction(t,e,r,i,n){const s=r.length,o=t.x.length;for(var a=new Array(s),h=0;h<s;h++){a[h]=new Array(o);var l=r.concat();l[h]+=i;for(var u=n(l),c=0;c<o;c++)a[h][c]=e[c]-u(t.x[c])}return new Matrix(a)}function matrixFunction(t,e){const r=t.x.length;for(var i=new Array(r),n=0;n<r;n++)i[n]=[t.y[n]-e[n]];return new Matrix(i)}function step$1(t,e,r,i,n){var s=r*i*i,o=Matrix.eye(e.length,e.length,s);const a=n(e);var h=t.x.map(t=>a(t)),l=gradientFunction(t,h,e,i,n),u=matrixFunction(t,h),c=inverse(o.add(l.mmul(l.transpose())));return(e=(e=new Matrix([e])).sub(c.mmul(l).mmul(u).mul(i).transpose())).to1DArray()}function levenbergMarquardt(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{maxIterations:i=100,gradientDifference:n=.1,damping:s=0,errorTolerance:o=.01,minValues:a,maxValues:h,initialValues:l}=r;if(s<=0)throw new Error("The damping option must be a positive number");if(!t.x||!t.y)throw new Error("The data parameter must have x and y elements");if(!Array.isArray(t.x)||t.x.length<2||!Array.isArray(t.y)||t.y.length<2)throw new Error("The data parameter elements must be an array with more than 2 points");if(t.x.length!==t.y.length)throw new Error("The data parameter elements must have the same size");var u=l||new Array(e.length).fill(1);let c=u.length;if(h=h||new Array(c).fill(Number.MAX_SAFE_INTEGER),a=a||new Array(c).fill(Number.MIN_SAFE_INTEGER),h.length!==a.length)throw new Error("minValues and maxValues must be the same size");if(!Array.isArray(u))throw new Error("initialValues must be an array");for(var f=errorCalculation(t,u,e),m=f<=o,g=0;g<i&&!m;g++){u=step$1(t,u,s,n,e);for(let t=0;t<c;t++)u[t]=Math.min(Math.max(a[t],u[t]),h[t]);if(f=errorCalculation(t,u,e),isNaN(f))break;m=f<=o}return{parameterValues:u,parameterError:f,iterations:g}}function selection(t,e){let r=[];for(let i=0;i<e.length;i++)r[i]=t[e[i]];return r}function sortCollectionSet(t){let e,r=t.map((t,e)=>{let r=BigInt(0);return t.forEach(t=>r|=BigInt(1)<<BigInt(t)),{value:t,index:e,key:r}}).sort((t,e)=>t.key-e.key<0?-1:1),i=[],n=[];for(let t of r)t.key!==e&&(e=t.key,n.push([]),i.push(t.value)),n[n.length-1].push(t.index);return{values:i,indices:n}}function cssls(t,e,r,i,n){let s=Matrix.zeros(i,n);if(null===r){let r=new CholeskyDecomposition(t);if(!0===r.isPositiveDefinite())s=r.solve(e);else{let r=new LuDecomposition(t);s=!1===r.isSingular()?r.solve(Matrix.eye(i)).mmul(e):solve(t,e,{useSVD:!0})}}else{let o=sortCollectionSet(r).values,a=sortCollectionSet(r).indices;if(1===o.length&&0===o[0].length&&a[0].length===n)return s;if(1===o.length&&o[0].length===i&&a[0].length===n){let r=new CholeskyDecomposition(t);if(!0===r.isPositiveDefinite())s=r.solve(e);else{let r=new LuDecomposition(t);s=!1===r.isSingular()?r.solve(Matrix.eye(i)).mmul(e):solve(t,e,{useSVD:!0})}}else for(let r=0;r<o.length;r++){let i,n=a[r],h=o[r],l=new CholeskyDecomposition(t.selection(h,h));if(!0===l.isPositiveDefinite())i=l.solve(e.selection(h,n));else{let r=new LuDecomposition(t.selection(h,h));i=!1===r.isSingular()?r.solve(Matrix.eye(h.length)).mmul(e.selection(h,n)):solve(t.selection(h,h),e.selection(h,n),{useSVD:!0})}for(let t=0;t<i.rows;t++)for(let e=0;e<i.columns;e++)s.set(h[t],n[e],i.get(t,e))}}return s}function initialisation(t,e){let r=t.rows,i=t.columns,n=e.columns;if(e.rows!==r)throw new Error("ERROR: matrix size not compatible");let s=Matrix.zeros(i,n),o=t.transpose().mmul(t),a=t.transpose().mmul(e),h=cssls(o,a,null,i,n),l=[];for(let t=0;t<n;t++){l[t]=[];for(let e=0;e<i;e++)h.get(e,t)>0?l[t].push(e):h.set(e,t,0)}let u=[];for(let t=0;t<n;t++)l[t].length!==i&&u.push(t);let c=h.clone();return{n:r,l:i,p:n,iter:0,W:s,XtX:o,XtY:a,K:h,Pset:l,Fset:u,D:c}}function setDifference(t,e){let r=[];for(let i of t)e.includes(i)||r.push(i);return r}function optimality(t,e,r,i,n,s,o,a,h,l,u){if(t===e)throw new Error("Maximum number of iterations exceeded");let c=i.subMatrixColumn(n).subtract(r.mmul(a.subMatrixColumn(n)));for(let t=0;t<n.length;t++)o.setColumn(n[t],c.subMatrixColumn([t]));let f=[],m=[];for(let t=0;t<h;t++)m.push(t);for(let t=0;t<n.length;t++){let e=setDifference(m,s[n[t]]);0===e.length?f.push(n[t]):o.selection(e,[n[t]]).max()<=0&&f.push(n[t])}if(0!==(n=setDifference(n,f)).length){for(let t=0;t<n.length;t++){for(let e=0;e<h;e++)s[n[t]].includes(e)&&o.set(e,n[t],-1/0);s[n[t]].push(o.subMatrixColumn(n).maxColumnIndex(t)[0])}for(let t=0;t<n.length;t++)u.setColumn(n[t],a.getColumn(n[t]))}for(let t=0;t<l;t++)s[t].sort((t,e)=>t-e);return{Pset:s,Fset:n,W:o}}function fcnnls(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t=Matrix.checkMatrix(t),e=Matrix.checkMatrix(e);let{l:i,p:n,iter:s,W:o,XtX:a,XtY:h,K:l,Pset:u,Fset:c,D:f}=initialisation(t,e);const{maxIterations:m=3*t.columns}=r;for(;c.length>0;){let t=cssls(a,h.subMatrixColumn(c),selection(u,c),i,c.length);for(let e=0;e<i;e++)for(let r=0;r<c.length;r++)l.set(e,c[r],t.get(e,r));let e=[];for(let r=0;r<c.length;r++)for(let n=0;n<i;n++)if(t.get(n,r)<0){e.push(r);break}let r=selection(c,e);if(r.length>0){let e=r.length,n=Matrix.ones(i,e);for(;e>0&&s<m;){s++,n.mul(1/0);let o=[[],[]],c=[[],[]];for(let t=0;t<e;t++)for(let e=0;e<u[r[t]].length;e++)l.get(u[r[t]][e],r[t])<0&&(o[0].push(u[r[t]][e]),o[1].push(t),c[0].push(u[r[t]][e]),c[1].push(r[t]));for(let t=0;t<o[0].length;t++)n.set(o[0][t],o[1][t],f.get(c[0][t],c[1][t])/(f.get(c[0][t],c[1][t])-l.get(c[0][t],c[1][t])));let m=[],g=[];for(let t=0;t<e;t++)m[t]=n.minColumn(t),g[t]=n.minColumnIndex(t)[0];m=Matrix.rowVector(m);for(let t=0;t<i;t++)n.setSubMatrix(m,t,0);let d=new Matrix(i,e);d=f.subMatrixColumn(r).subtract(n.subMatrix(0,i-1,0,e-1).mul(f.subMatrixColumn(r).subtract(l.subMatrixColumn(r))));for(let t=0;t<e;t++)f.setColumn(r[t],d.subMatrixColumn([t]));let p=[g,r];for(let t=0;t<e;t++)f.set(p[0][t],p[1][t],0);for(let t=0;t<e;t++)u[r[t]].splice(u[r[t]].findIndex(e=>e===g[t]),1);t=cssls(a,h.subMatrixColumn(r),selection(u,r),i,e);for(let i=0;i<e;i++)l.setColumn(r[i],t.subMatrixColumn([i]));r=[];for(let t=0;t<l.columns;t++)for(let e=0;e<i;e++)if(l.get(e,t)<0){r.push(t);break}e=r.length}}let g=optimality(s,m,a,h,c,u,o,l,i,n,f);u=g.Pset,c=g.Fset,o=g.W}return l}function fcnnlsVector(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1===Array.isArray(e))throw new TypeError("y must be a 1D Array");return fcnnls(t,Matrix.columnVector(e),r).to1DArray()}var index$2=Object.freeze({__proto__:null,fcnnls:fcnnls,fcnnlsVector:fcnnlsVector}),binarySearch=function(t,e,r,i,n){var s,o;if(void 0===i)i=0;else if((i|=0)<0||i>=t.length)throw new RangeError("invalid lower bound");if(void 0===n)n=t.length-1;else if((n|=0)<i||n>=t.length)throw new RangeError("invalid upper bound");for(;i<=n;)if((o=+r(t[s=i+(n-i>>>1)],e,s,t))<0)i=s+1;else{if(!(o>0))return s;n=s-1}return~i};function assertNumber(t){if("number"!=typeof t||Number.isNaN(t))throw new TypeError("Expected a number")}var ascending=(t,e)=>(assertNumber(t),assertNumber(e),t-e),descending=(t,e)=>(assertNumber(t),assertNumber(e),e-t),numSort={ascending:ascending,descending:descending},index$3=Object.freeze({__proto__:null,default:numSort,__moduleExports:numSort,ascending:ascending,descending:descending});const largestPrime=2147483647,primeNumbers=[largestPrime,5,11,23,47,97,197,397,797,1597,3203,6421,12853,25717,51437,102877,205759,411527,823117,1646237,3292489,6584983,13169977,26339969,52679969,105359939,210719881,421439783,842879579,1685759167,433,877,1759,3527,7057,14143,28289,56591,113189,226379,452759,905551,1811107,3622219,7244441,14488931,28977863,57955739,115911563,231823147,463646329,927292699,1854585413,953,1907,3821,7643,15287,30577,61169,122347,244703,489407,978821,1957651,3915341,7830701,15661423,31322867,62645741,125291483,250582987,501165979,1002331963,2004663929,1039,2081,4177,8363,16729,33461,66923,133853,267713,535481,1070981,2141977,4283963,8567929,17135863,34271747,68543509,137087021,274174111,548348231,1096696463,31,67,137,277,557,1117,2237,4481,8963,17929,35863,71741,143483,286973,573953,1147921,2295859,4591721,9183457,18366923,36733847,73467739,146935499,293871013,587742049,1175484103,599,1201,2411,4831,9677,19373,38747,77509,155027,310081,620171,1240361,2480729,4961459,9922933,19845871,39691759,79383533,158767069,317534141,635068283,1270136683,311,631,1277,2557,5119,10243,20507,41017,82037,164089,328213,656429,1312867,2625761,5251529,10503061,21006137,42012281,84024581,168049163,336098327,672196673,1344393353,3,7,17,37,79,163,331,673,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,43,89,179,359,719,1439,2879,5779,11579,23159,46327,92657,185323,370661,741337,1482707,2965421,5930887,11861791,23723597,47447201,94894427,189788857,379577741,759155483,1518310967,379,761,1523,3049,6101,12203,24407,48817,97649,195311,390647,781301,1562611,3125257,6250537,12501169,25002389,50004791,100009607,200019221,400038451,800076929,1600153859,13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683,539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407,276172823,552345671,1104691373,19,41,83,167,337,677,1361,2729,5471,10949,21911,43853,87719,175447,350899,701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557,359339171,718678369,1437356741,53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269,234539,469099,938207,1876417,3752839,7505681,15011389,30022781,60045577,120091177,240182359,480364727,960729461,1921458943];function nextPrime(t){let e=binarySearch(primeNumbers,t,ascending);return e<0&&(e=~e),primeNumbers[e]}primeNumbers.sort(ascending);const FREE=0,FULL=1,REMOVED=2,defaultInitialCapacity=150,defaultMinLoadFactor=1/6,defaultMaxLoadFactor=2/3;class HashTable{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(t instanceof HashTable)return this.table=t.table.slice(),this.values=t.values.slice(),this.state=t.state.slice(),this.minLoadFactor=t.minLoadFactor,this.maxLoadFactor=t.maxLoadFactor,this.distinct=t.distinct,this.freeEntries=t.freeEntries,this.lowWaterMark=t.lowWaterMark,void(this.highWaterMark=t.maxLoadFactor);const e=void 0===t.initialCapacity?defaultInitialCapacity:t.initialCapacity;if(e<0)throw new RangeError("initial capacity must not be less than zero: ".concat(e));const r=void 0===t.minLoadFactor?defaultMinLoadFactor:t.minLoadFactor,i=void 0===t.maxLoadFactor?defaultMaxLoadFactor:t.maxLoadFactor;if(r<0||r>=1)throw new RangeError("invalid minLoadFactor: ".concat(r));if(i<=0||i>=1)throw new RangeError("invalid maxLoadFactor: ".concat(i));if(r>=i)throw new RangeError("minLoadFactor (".concat(r,") must be smaller than maxLoadFactor (").concat(i,")"));let n=e;0===(n=nextPrime(n=n/i|0))&&(n=1),this.table=newArray$1(n),this.values=newArray$1(n),this.state=newArray$1(n),this.minLoadFactor=r,this.maxLoadFactor=n===largestPrime?1:i,this.distinct=0,this.freeEntries=n,this.lowWaterMark=0,this.highWaterMark=chooseHighWaterMark(n,this.maxLoadFactor)}clone(){return new HashTable(this)}get size(){return this.distinct}get(t){const e=this.indexOfKey(t);return e<0?0:this.values[e]}set(t,e){let r=this.indexOfInsertion(t);if(r<0)return r=-r-1,this.values[r]=e,!1;if(this.distinct>this.highWaterMark){const r=chooseGrowCapacity(this.distinct+1,this.minLoadFactor,this.maxLoadFactor);return this.rehash(r),this.set(t,e)}if(this.table[r]=t,this.values[r]=e,this.state[r]===FREE&&this.freeEntries--,this.state[r]=FULL,this.distinct++,this.freeEntries<1){const t=chooseGrowCapacity(this.distinct+1,this.minLoadFactor,this.maxLoadFactor);this.rehash(t)}return!0}remove(t,e){const r=this.indexOfKey(t);return!(r<0)&&(this.state[r]=REMOVED,this.distinct--,e||this.maybeShrinkCapacity(),!0)}delete(t,e){const r=this.indexOfKey(t);return!(r<0)&&(this.state[r]=FREE,this.distinct--,e||this.maybeShrinkCapacity(),!0)}maybeShrinkCapacity(){if(this.distinct<this.lowWaterMark){const t=chooseShrinkCapacity(this.distinct,this.minLoadFactor,this.maxLoadFactor);this.rehash(t)}}containsKey(t){return this.indexOfKey(t)>=0}indexOfKey(t){const e=this.table,r=this.state,i=this.table.length,n=2147483647&t;let s=n%i,o=n%(i-2);for(0===o&&(o=1);r[s]!==FREE&&(r[s]===REMOVED||e[s]!==t);)(s-=o)<0&&(s+=i);return r[s]===FREE?-1:s}containsValue(t){return this.indexOfValue(t)>=0}indexOfValue(t){const e=this.values,r=this.state;for(var i=0;i<r.length;i++)if(r[i]===FULL&&e[i]===t)return i;return-1}indexOfInsertion(t){const e=this.table,r=this.state,i=e.length,n=2147483647&t;let s=n%i,o=n%(i-2);for(0===o&&(o=1);r[s]===FULL&&e[s]!==t;)(s-=o)<0&&(s+=i);if(r[s]===REMOVED){const n=s;for(;r[s]!==FREE&&(r[s]===REMOVED||e[s]!==t);)(s-=o)<0&&(s+=i);r[s]===FREE&&(s=n)}return r[s]===FULL?-s-1:s}ensureCapacity(t){if(this.table.length<t){const e=nextPrime(t);this.rehash(e)}}rehash(t){const e=this.table.length;if(t<=this.distinct)throw new Error("Unexpected");const r=this.table,i=this.values,n=this.state,s=newArray$1(t),o=newArray$1(t),a=newArray$1(t);this.lowWaterMark=chooseLowWaterMark(t,this.minLoadFactor),this.highWaterMark=chooseHighWaterMark(t,this.maxLoadFactor),this.table=s,this.values=o,this.state=a,this.freeEntries=t-this.distinct;for(var h=0;h<e;h++)if(n[h]===FULL){var l=r[h],u=this.indexOfInsertion(l);s[u]=l,o[u]=i[h],a[u]=FULL}}forEachKey(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.table[e]))return!1;return!0}forEachValue(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.values[e]))return!1;return!0}forEachPair(t){for(var e=0;e<this.state.length;e++)if(this.state[e]===FULL&&!t(this.table[e],this.values[e]))return!1;return!0}}function chooseLowWaterMark(t,e){return t*e|0}function chooseHighWaterMark(t,e){return Math.min(t-2,t*e|0)}function chooseGrowCapacity(t,e,r){return nextPrime(Math.max(t+1,4*t/(3*e+r)|0))}function chooseShrinkCapacity(t,e,r){return nextPrime(Math.max(t+1,4*t/(e+3*r)|0))}function newArray$1(t){return Array(t).fill(0)}class SparseMatrix{constructor(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(t instanceof SparseMatrix){const e=t;this._init(e.rows,e.columns,e.elements.clone(),e.threshold)}else if(Array.isArray(t)){const o=t;t=o.length,r=e||{},e=o[0].length,this._init(t,e,new HashTable(r),r.threshold);for(var i=0;i<t;i++)for(var n=0;n<e;n++){var s=o[i][n];this.threshold&&Math.abs(s)<this.threshold&&(s=0),0!==s&&this.elements.set(i*e+n,o[i][n])}}else this._init(t,e,new HashTable(r),r.threshold)}_init(t,e,r,i){this.rows=t,this.columns=e,this.elements=r,this.threshold=i||0}static eye(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t;const r=Math.min(t,e),i=new SparseMatrix(t,e,{initialCapacity:r});for(var n=0;n<r;n++)i.set(n,n,1);return i}clone(){return new SparseMatrix(this)}to2DArray(){const t=new Array(this.rows);for(var e=0;e<this.rows;e++){t[e]=new Array(this.columns);for(var r=0;r<this.columns;r++)t[e][r]=this.get(e,r)}return t}isSquare(){return this.rows===this.columns}isSymmetric(){if(!this.isSquare())return!1;var t=!0;return this.forEachNonZero((e,r,i)=>this.get(r,e)!==i?(t=!1,!1):i),t}bandWidth(){let t=this.columns,e=-1;return this.forEachNonZero((r,i,n)=>{let s=r-i;return t=Math.min(t,s),e=Math.max(e,s),n}),e-t}isBanded(t){return this.bandWidth()<=t}get cardinality(){return this.elements.size}get size(){return this.rows*this.columns}get(t,e){return this.elements.get(t*this.columns+e)}set(t,e,r){return this.threshold&&Math.abs(r)<this.threshold&&(r=0),0===r?this.elements.remove(t*this.columns+e):this.elements.set(t*this.columns+e,r),this}mmul(t){this.columns!==t.rows&&console.warn("Number of columns of left matrix are not equal to number of rows of right matrix.");const e=this.rows,r=t.columns,i=new SparseMatrix(e,r);return this.forEachNonZero((e,r,n)=>(t.forEachNonZero((t,s,o)=>(r===t&&i.set(e,s,i.get(e,s)+n*o),o)),n)),i}kroneckerProduct(t){const e=this.rows,r=this.columns,i=t.rows,n=t.columns,s=new SparseMatrix(e*i,r*n,{initialCapacity:this.cardinality*t.cardinality});return this.forEachNonZero((e,r,o)=>(t.forEachNonZero((t,a,h)=>(s.set(i*e+t,n*r+a,o*h),h)),o)),s}forEachNonZero(t){return this.elements.forEachPair((e,r)=>{const i=e/this.columns|0,n=e%this.columns;let s=t(i,n,r);return!1!==s&&(this.threshold&&Math.abs(s)<this.threshold&&(s=0),s!==r&&(0===s?this.elements.remove(e,!0):this.elements.set(e,s)),!0)}),this.elements.maybeShrinkCapacity(),this}getNonZeros(){const t=this.cardinality,e=new Array(t),r=new Array(t),i=new Array(t);var n=0;return this.forEachNonZero((t,s,o)=>(e[n]=t,r[n]=s,i[n]=o,n++,o)),{rows:e,columns:r,values:i}}setThreshold(t){return 0!==t&&t!==this.threshold&&(this.threshold=t,this.forEachNonZero((t,e,r)=>r)),this}transpose(){let t=new SparseMatrix(this.columns,this.rows,{initialCapacity:this.cardinality});return this.forEachNonZero((e,r,i)=>(t.set(r,e,i),i)),t}}SparseMatrix.prototype.klass="Matrix",SparseMatrix.identity=SparseMatrix.eye,SparseMatrix.prototype.tensorProduct=SparseMatrix.prototype.kroneckerProduct;var inplaceOperator="\n(function %name%(value) {\n    if (typeof value === 'number') return this.%name%S(value);\n    return this.%name%M(value);\n})\n",inplaceOperatorScalar="\n(function %name%S(value) {\n    this.forEachNonZero((i, j, v) => v %op% value);\n    return this;\n})\n",inplaceOperatorMatrix="\n(function %name%M(matrix) {\n    matrix.forEachNonZero((i, j, v) => {\n        this.set(i, j, this.get(i, j) %op% v);\n        return v;\n    });\n    return this;\n})\n",staticOperator="\n(function %name%(matrix, value) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%(value);\n})\n",inplaceMethod="\n(function %name%() {\n    this.forEachNonZero((i, j, v) => %method%(v));\n    return this;\n})\n",staticMethod="\n(function %name%(matrix) {\n    var newMatrix = new SparseMatrix(matrix);\n    return newMatrix.%name%();\n})\n";const operators=[["+","add"],["-","sub","subtract"],["*","mul","multiply"],["/","div","divide"],["%","mod","modulus"],["&","and"],["|","or"],["^","xor"],["<<","leftShift"],[">>","signPropagatingRightShift"],[">>>","rightShift","zeroFillRightShift"]];for(const operator of operators)for(let i=1;i<operator.length;i++)SparseMatrix.prototype[operator[i]]=eval(fillTemplateFunction(inplaceOperator,{name:operator[i],op:operator[0]})),SparseMatrix.prototype["".concat(operator[i],"S")]=eval(fillTemplateFunction(inplaceOperatorScalar,{name:"".concat(operator[i],"S"),op:operator[0]})),SparseMatrix.prototype["".concat(operator[i],"M")]=eval(fillTemplateFunction(inplaceOperatorMatrix,{name:"".concat(operator[i],"M"),op:operator[0]})),SparseMatrix[operator[i]]=eval(fillTemplateFunction(staticOperator,{name:operator[i]}));var methods=[["~","not"]];["abs","acos","acosh","asin","asinh","atan","atanh","cbrt","ceil","clz32","cos","cosh","exp","expm1","floor","fround","log","log1p","log10","log2","round","sign","sin","sinh","sqrt","tan","tanh","trunc"].forEach((function(t){methods.push(["Math.".concat(t),t])}));for(const method of methods)for(let i=1;i<method.length;i++)SparseMatrix.prototype[method[i]]=eval(fillTemplateFunction(inplaceMethod,{name:method[i],method:method[0]})),SparseMatrix[method[i]]=eval(fillTemplateFunction(staticMethod,{name:method[i]}));function fillTemplateFunction(t,e){for(const r in e)t=t.replace(new RegExp("%".concat(r,"%"),"g"),e[r]);return t}function additiveSymmetric(t,e){for(var r=0,i=t.length,n=0;r<i;r++)n+=(t[r]-e[r])*(t[r]-e[r])*(t[r]+e[r])/(t[r]*e[r]);return 2*n}function avg(t,e){for(var r=t.length,i=0,n=0,s=0,o=0;o<r;o++)n+=s=Math.abs(t[o]-e[o]),i<s&&(i=s);return(i+n)/2}function bhattacharyya(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.sqrt(t[n]*e[n]);return-Math.log(i)}function canberra(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.abs(t[n]-e[n])/(t[n]+e[n]);return i}function chebyshev(t,e){for(var r=t.length,i=0,n=0,s=0;s<r;s++)i<(n=Math.abs(t[s]-e[s]))&&(i=n);return i}function clark(t,e){for(var r=0,i=t.length,n=0;r<i;r++)n+=Math.sqrt((t[r]-e[r])*(t[r]-e[r])/((t[r]+e[r])*(t[r]+e[r])));return 2*n}function czekanowskiSimilarity(t,e){for(var r=0,i=0,n=0;n<t.length;n++)r+=Math.min(t[n],e[n]),i+=t[n]+e[n];return 2*r/i}function czekanowskiDistance(t,e){return 1-czekanowskiSimilarity(t,e)}function dice(t,e){for(var r=t.length,i=0,n=0,s=0,o=0;o<r;o++)i+=t[o]*t[o],n+=e[o]*e[o],s+=(t[o]-e[o])*(t[o]-e[o]);return s/(i+n)}function divergence(t,e){for(var r=0,i=t.length,n=0;r<i;r++)n+=(t[r]-e[r])*(t[r]-e[r])/((t[r]+e[r])*(t[r]+e[r]));return 2*n}function fidelity(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.sqrt(t[n]*e[n]);return i}function gower(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.abs(t[n]-e[n]);return i/r}function harmonicMean(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=t[n]*e[n]/(t[n]+e[n]);return 2*i}function hellinger(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.sqrt(t[n]*e[n]);return 2*Math.sqrt(1-i)}function innerProduct(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=t[n]*e[n];return i}function intersection(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.min(t[n],e[n]);return 1-i}function jaccard(t,e){for(var r=t.length,i=0,n=0,s=0,o=0,a=0;a<r;a++)i+=t[a]*e[a],n+=t[a]*t[a],s+=e[a]*e[a],o+=(t[a]-e[a])*(t[a]-e[a]);return o/(n+s-i)}function jeffreys(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=(t[n]-e[n])*Math.log(t[n]/e[n]);return i}function jensenDifference(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=(t[n]*Math.log(t[n])+e[n]*Math.log(e[n]))/2-(t[n]+e[n])/2*Math.log((t[n]+e[n])/2);return i}function jensenShannon(t,e){for(var r=t.length,i=0,n=0,s=0;s<r;s++)i+=t[s]*Math.log(2*t[s]/(t[s]+e[s])),n+=e[s]*Math.log(2*e[s]/(t[s]+e[s]));return(i+n)/2}function kdivergence(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=t[n]*Math.log(2*t[n]/(t[n]+e[n]));return i}function kulczynski(t,e){for(var r=t.length,i=0,n=0,s=0;s<r;s++)i+=Math.abs(t[s]-e[s]),n+=Math.min(t[s],e[s]);return i/n}function kullbackLeibler(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=t[n]*Math.log(t[n]/e[n]);return i}function kumarHassebrook(t,e){for(var r=t.length,i=0,n=0,s=0,o=0;o<r;o++)i+=t[o]*e[o],n+=t[o]*t[o],s+=e[o]*e[o];return i/(n+s-i)}function kumarJohnson(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.pow(t[n]*t[n]-e[n]*e[n],2)/(2*Math.pow(t[n]*e[n],1.5));return i}function lorentzian(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.log(Math.abs(t[n]-e[n])+1);return i}function manhattan(t,e){for(var r=0,i=t.length,n=0;r<i;r++)n+=Math.abs(t[r]-e[r]);return n}function matusita(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=Math.sqrt(t[n]*e[n]);return Math.sqrt(2-2*i)}function minkowski(t,e,r){for(var i=0,n=t.length,s=0;i<n;i++)s+=Math.pow(Math.abs(t[i]-e[i]),r);return Math.pow(s,1/r)}function motyka(t,e){for(var r=t.length,i=0,n=0,s=0;s<r;s++)i+=Math.min(t[s],e[s]),n+=t[s]+e[s];return 1-i/n}function neyman(t,e){for(var r=0,i=t.length,n=0;r<i;r++)n+=(t[r]-e[r])*(t[r]-e[r])/t[r];return n}function pearson(t,e){for(var r=0,i=t.length,n=0;r<i;r++)n+=(t[r]-e[r])*(t[r]-e[r])/e[r];return n}function probabilisticSymmetric(t,e){for(var r=0,i=t.length,n=0;r<i;r++)n+=(t[r]-e[r])*(t[r]-e[r])/(t[r]+e[r]);return 2*n}function ruzicka(t,e){for(var r=t.length,i=0,n=0,s=0;s<r;s++)i+=Math.min(t[s],e[s]),n+=Math.max(t[s],e[s]);return i/n}function soergel(t,e){for(var r=t.length,i=0,n=0,s=0;s<r;s++)i+=Math.abs(t[s]-e[s]),n+=Math.max(t[s],e[s]);return i/n}function sorensen(t,e){for(var r=t.length,i=0,n=0,s=0;s<r;s++)i+=Math.abs(t[s]-e[s]),n+=t[s]+e[s];return i/n}function squared(t,e){for(var r=0,i=t.length,n=0;r<i;r++)n+=(t[r]-e[r])*(t[r]-e[r])/(t[r]+e[r]);return n}function squaredChord(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=(Math.sqrt(t[n])-Math.sqrt(e[n]))*(Math.sqrt(t[n])-Math.sqrt(e[n]));return i}function taneja(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=(t[n]+e[n])/2*Math.log((t[n]+e[n])/(2*Math.sqrt(t[n]*e[n])));return i}function tanimoto(t,e,r){if(r){for(var i=0,n=0,s=0;s<t.length;s++)i+=t[s]&&e[s],n+=t[s]||e[s];return 0===n?1:i/n}for(var o=t.length,a=0,h=0,l=0,u=0;u<o;u++)a+=t[u],h+=e[u],l+=Math.min(t[u],e[u]);return 1-(a+h-2*l)/(a+h-l)}function tanimoto$1(t,e,r){if(r)return 1-tanimoto(t,e,r);for(var i=t.length,n=0,s=0,o=0,a=0;a<i;a++)n+=t[a],s+=e[a],o+=Math.min(t[a],e[a]);return(n+s-2*o)/(n+s-o)}function topsoe(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=t[n]*Math.log(2*t[n]/(t[n]+e[n]))+e[n]*Math.log(2*e[n]/(t[n]+e[n]));return i}function waveHedges(t,e){for(var r=t.length,i=0,n=0;n<r;n++)i+=1-Math.min(t[n],e[n])/Math.max(t[n],e[n]);return i}var distances=Object.freeze({__proto__:null,euclidean:euclidean,squaredEuclidean:squaredEuclidean,additiveSymmetric:additiveSymmetric,avg:avg,bhattacharyya:bhattacharyya,canberra:canberra,chebyshev:chebyshev,clark:clark,czekanowski:czekanowskiDistance,dice:dice,divergence:divergence,fidelity:fidelity,gower:gower,harmonicMean:harmonicMean,hellinger:hellinger,innerProduct:innerProduct,intersection:intersection,jaccard:jaccard,jeffreys:jeffreys,jensenDifference:jensenDifference,jensenShannon:jensenShannon,kdivergence:kdivergence,kulczynski:kulczynski,kullbackLeibler:kullbackLeibler,kumarHassebrook:kumarHassebrook,kumarJohnson:kumarJohnson,lorentzian:lorentzian,manhattan:manhattan,matusita:matusita,minkowski:minkowski,motyka:motyka,neyman:neyman,pearson:pearson,probabilisticSymmetric:probabilisticSymmetric,ruzicka:ruzicka,soergel:soergel,sorensen:sorensen,squared:squared,squaredChord:squaredChord,taneja:taneja,tanimoto:tanimoto$1,topsoe:topsoe,waveHedges:waveHedges});function createTree(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};var r=t[0];const{minWindow:i=.16,threshold:n=.01,from:s=r[0],to:o=r[r.length-1]}=e;return mainCreateTree(t[0],t[1],s,o,i,n)}function mainCreateTree(t,e,r,i,n,s){if(i-r<n)return null;var o=binarySearch(t,r,ascending);o<0&&(o=~o);for(var a=0,h=0,l=o;l<t.length&&!(t[l]>=i);l++)a+=e[l],h+=t[l]*e[l];return a<s?null:(h/=a)-r<1e-6||i-h<1e-6?null:h-r<n/4?mainCreateTree(t,e,h,i,n,s):i-h<n/4?mainCreateTree(t,e,r,h,n,s):new Tree(a,h,mainCreateTree(t,e,r,h,n,s),mainCreateTree(t,e,h,i,n,s))}class Tree{constructor(t,e,r,i){this.sum=t,this.center=e,this.left=r,this.right=i}}function getSimilarity(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{alpha:i=.1,beta:n=.33,gamma:s=.001}=r;return null===t||null===e?0:(Array.isArray(t)&&(t=createTree(t)),Array.isArray(e)&&(e=createTree(e)),n*(i*Math.min(t.sum,e.sum)/Math.max(t.sum,e.sum)+(1-i)*Math.exp(-s*Math.abs(t.center-e.center)))+(1-n)*(getSimilarity(t.left,e.left,r)+getSimilarity(t.right,e.right,r))/2)}function treeSimilarity(t,e){return getSimilarity(t,e,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}function getFunction(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(e,r)=>getSimilarity(e,r,t)}var index$4=Object.freeze({__proto__:null,treeSimilarity:treeSimilarity,getFunction:getFunction,createTree:createTree});function cosine(t,e){for(var r=t.length,i=0,n=0,s=0,o=0;o<r;o++)i+=t[o]*e[o],n+=t[o]*t[o],s+=e[o]*e[o];return i/(Math.sqrt(n)*Math.sqrt(s))}function dice$1(t,e){return 1-dice(t,e)}function intersection$1(t,e){return 1-intersection(t,e)}function jaccard$1(t,e){return 1-jaccard(t,e)}function kulczynski$1(t,e){return 1/kulczynski(t,e)}function motyka$1(t,e){return 1-motyka(t,e)}function pearson$1(t,e){for(var r=mean(t),i=mean(e),n=new Array(t.length),s=new Array(e.length),o=0;o<n.length;o++)n[o]=t[o]-r,s[o]=e[o]-i;return cosine(n,s)}function squaredChord$1(t,e){return 1-squaredChord(t,e)}var similarities=Object.freeze({__proto__:null,tree:index$4,cosine:cosine,czekanowski:czekanowskiSimilarity,dice:dice$1,intersection:intersection$1,jaccard:jaccard$1,kulczynski:kulczynski$1,motyka:motyka$1,pearson:pearson$1,squaredChord:squaredChord$1,tanimoto:tanimoto}),acc=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=(t.tn[i]+t.tp[i])/(e-1);return r},err=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.fn[i]+t.fp[i]/(e-1);return r},fpr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.fp[i]/t.nNeg;return r},tpr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.tp[i]/t.nPos;return r},fnr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.fn[i]/t.nPos;return r},tnr=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.tn[i]/t.nNeg;return r},ppv=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.fp[i]+t.tp[i]!==0?t.tp[i]/(t.fp[i]+t.tp[i]):0;return r},npv=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.fn[i]+t.tn[i]!==0?t.tn[i]/(t.fn[i]+t.tn[i]):0;return r},pcfall=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.fp[i]+t.tp[i]!==0?1-t.tp[i]/(t.fp[i]+t.tp[i]):1;return r},pcmiss=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.fn[i]+t.tn[i]!==0?1-t.tn[i]/(t.fn[i]+t.tn[i]):1;return r},lift=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=0!==t.nPosPred[i]?t.tp[i]/t.nPos/(t.nPosPred[i]/t.nSamples):0;return r},rpp=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.nPosPred[i]/t.nSamples;return r},rnp=t=>{const e=t.cutoffs.length,r=new Array(e);for(var i=0;i<e;i++)r[i]=t.nNegPred[i]/t.nSamples;return r},threshold=t=>{const e=t.cutoffs.slice();return e[0]=e[1],e},measures={acc:acc,err:err,fpr:fpr,tpr:tpr,fnr:fnr,tnr:tnr,ppv:ppv,npv:npv,pcfall:pcfall,pcmiss:pcmiss,lift:lift,rpp:rpp,rnp:rnp,threshold:threshold};class Performance{constructor(t,e,r){if(r=r||{},t.length!==e.length||t[0].length!==e[0].length)throw new Error("dimensions of prediction and target do not match");const i=t.length,n=t[0].length,s=!r.max,o=[];if(r.all)for(var a=0;a<i;a++)for(var h=0;h<n;h++)o.push({pred:t[a][h],targ:e[a][h]});else{if(i<3||i!==n)throw new Error('When "all" option is false, the prediction matrix must be square and have at least 3 columns');for(a=0;a<i-1;a++)for(h=a+1;h<n;h++)o.push({pred:t[a][h],targ:e[a][h]})}s?o.sort((t,e)=>t.pred-e.pred):o.sort((t,e)=>e.pred-t.pred);const l=this.cutoffs=[s?Number.MIN_VALUE:Number.MAX_VALUE],u=this.fp=[0],c=this.tp=[0];var f=0,m=0,g=o[0].pred,d=0,p=0;for(a=0;a<o.length;a++)o[a].pred!==g&&(l.push(g),u.push(p),c.push(d),g=o[a].pred),o[a].targ?(f++,d++):(m++,p++);l.push(g),u.push(p),c.push(d);const w=l.length,x=this.fn=new Array(w),M=this.tn=new Array(w),y=this.nPosPred=new Array(w),v=this.nNegPred=new Array(w);for(a=0;a<w;a++)x[a]=f-c[a],M[a]=m-u[a],y[a]=c[a]+u[a],v[a]=M[a]+x[a];this.nPos=f,this.nNeg=m,this.nSamples=f+m}getMeasure(t){if("string"!=typeof t)throw new Error("No measure specified");if(!measures[t])throw new Error("The specified measure (".concat(t,") does not exist"));return measures[t](this)}getAURC(){const t=this.cutoffs.length,e=new Array(t),r=new Array(t);for(var i=0;i<t;i++)e[i]=this.fp[i]/this.nNeg,r[i]=this.tp[i]/this.nPos;var n=0;for(i=1;i<t;i++)n+=.5*(e[i]-e[i-1])*(r[i]+r[i-1]);return n}getAUDC(){const t=this.cutoffs.length,e=new Array(t),r=new Array(t);for(var i=0;i<t;i++)e[i]=this.fn[i]/this.nPos,r[i]=this.fp[i]/this.nNeg;var n=0;for(i=1;i<t;i++)n+=.5*(e[i]+e[i-1])*(r[i]-r[i-1]);return n}getDistribution(t){t=t||{};for(var e=this.cutoffs.length,r=t.xMin||Math.floor(100*this.cutoffs[e-1])/100,i=t.xMax||Math.ceil(100*this.cutoffs[1])/100,n=t.interval||Math.floor((i-r)/20*1e7-1)/1e7,s=[],o=[],a=[],h=[],l=[],u=this.tp[e-1],c=0,f=this.fp[e-1],m=0,g=r,d=e-1;g<=i;g+=n){for(;this.cutoffs[d]<g;)d--;s.push(g);var p=u-c-this.tp[d],w=f-m-this.fp[d];c+=p,m+=w,o.push(w),a.push(p),h.push(100-(f-this.fp[d])/f*100),l.push(100-(u-this.tp[d])/u*100)}return{xLabels:s,interValues:o,intraValues:a,interCumPercent:h,intraCumPercent:l}}}Performance.names={acc:"Accuracy",err:"Error rate",fpr:"False positive rate",tpr:"True positive rate",fnr:"False negative rate",tnr:"True negative rate",ppv:"Positive predictive value",npv:"Negative predictive value",pcfall:"Prediction-conditioned fallout",pcmiss:"Prediction-conditioned miss",lift:"Lift value",rpp:"Rate of positive predictions",rnp:"Rate of negative predictions",threshold:"Threshold"};var src$5=Performance,defaultOptions$h={size:1,value:0};function arrayCase(t,e){var r=t.length;"number"==typeof e.size&&(e.size=[e.size,e.size]);var i,n,s=r+e.size[0]+e.size[1];if(e.output){if(e.output.length!==s)throw new RangeError("Wrong output size");i=e.output}else i=new Array(s);if("circular"===e.value)for(n=0;n<s;n++)n<e.size[0]?i[n]=t[(r-e.size[0]%r+n)%r]:n<e.size[0]+r?i[n]=t[n-e.size[0]]:i[n]=t[(n-e.size[0])%r];else if("replicate"===e.value)for(n=0;n<s;n++)n<e.size[0]?i[n]=t[0]:n<e.size[0]+r?i[n]=t[n-e.size[0]]:i[n]=t[r-1];else if("symmetric"===e.value){if(e.size[0]>r||e.size[1]>r)throw new RangeError("expanded value should not be bigger than the data length");for(n=0;n<s;n++)n<e.size[0]?i[n]=t[e.size[0]-1-n]:n<e.size[0]+r?i[n]=t[n-e.size[0]]:i[n]=t[2*r+e.size[0]-n-1]}else for(n=0;n<s;n++)n<e.size[0]?i[n]=e.value:n<e.size[0]+r?i[n]=t[n-e.size[0]]:i[n]=e.value;return i}function matrixCase(t,e){throw void 0===e.size[0]&&(e.size=[e.size,e.size,e.size,e.size]),new Error("matrix not supported yet, sorry")}function padArray(t,e){if(e=Object.assign({},defaultOptions$h,e),Array.isArray(t))return Array.isArray(t[0])?matrixCase(t,e):arrayCase(t,e);throw new TypeError("data should be an array")}var src$6=padArray;const defaultOptions$i={windowSize:5,derivative:1,polynomial:2,pad:"none",padValue:"replicate"};function savitzkyGolay(t,e,r){if((r=Object.assign({},defaultOptions$i,r)).windowSize%2==0||r.windowSize<5||!Number.isInteger(r.windowSize))throw new RangeError("Invalid window size (should be odd and at least 5 integer number)");if(r.derivative<0||!Number.isInteger(r.derivative))throw new RangeError("Derivative should be a positive integer");if(r.polynomial<1||!Number.isInteger(r.polynomial))throw new RangeError("Polynomial should be a positive integer");let i,n,s=Math.floor(r.windowSize/2);"pre"===r.pad&&(t=src$6(t,{size:s,value:r.padValue}));let o=new Array(t.length-2*s);if(5!==r.windowSize||2!==r.polynomial||1!==r.derivative&&2!==r.derivative){let t=Matrix.ones(r.windowSize,r.polynomial+1),e=-(r.windowSize-1)/2;for(let r=0;r<t.rows;r++)for(let i=0;i<t.columns;i++)e+1===0&&0===i||t.set(r,i,Math.pow(e+r,i));let s=new MatrixTransposeView(t);i=(i=inverse(s.mmul(t)).mmul(s)).getRow(r.derivative),n=1}else 1===r.derivative?(i=[-2,-1,0,1,2],n=10):(i=[2,-1,-2,-1,2],n=7);let a=n*Math.pow(e,r.derivative);for(let e=s;e<t.length-s;e++){let r=0;for(let n=0;n<i.length;n++)r+=i[n]*t[n+e-s]/a;o[e-s]=r}return"post"===r.pad&&(o=src$6(o,{size:s,value:r.padValue})),o}for(var ans=new Array(256),i=0;i<256;i++){for(var num=i,c=0;num;)num&=num-1,c++;ans[i]=c}var creator=ans;function count(t){for(var e=0,r=0;r<t.length;r++)e+=creator[255&t[r]]+creator[t[r]>>8&255]+creator[t[r]>>16&255]+creator[t[r]>>24&255];return e}function and(t,e){for(var r=new Array(t.length),i=0;i<t.length;i++)r[i]=t[i]&e[i];return r}function or(t,e){for(var r=new Array(t.length),i=0;i<t.length;i++)r[i]=t[i]|e[i];return r}function xor(t,e){for(var r=new Array(t.length),i=0;i<t.length;i++)r[i]=t[i]^e[i];return r}function not(t){for(var e=new Array(t.length),r=0;r<e.length;r++)e[r]=~t[r];return e}function getBit(t,e){var r=1<<31-e%32;return Boolean(t[e>>5]&r)}function setBit(t,e,r){var i=e>>5,n=1<<31-e%32;return t[i]=r?n|t[i]:~n&t[i],t}function toBinaryString(t){for(var e="",r=0;r<t.length;r++){var i=(t[r]>>>0).toString(2);e+="00000000000000000000000000000000".substr(i.length)+i}return e}function parseBinaryString(t){for(var e=t.length/32,r=new Array(e),i=0;i<e;i++)r[i]=0|parseInt(t.substr(32*i,32),2);return r}function toHexString(t){for(var e="",r=0;r<t.length;r++){var i=(t[r]>>>0).toString(16);e+="00000000".substr(i.length)+i}return e}function parseHexString(t){for(var e=t.length/8,r=new Array(e),i=0;i<e;i++)r[i]=0|parseInt(t.substr(8*i,8),16);return r}function toDebug(t){for(var e=toBinaryString(t),r="",i=0;i<t.length;i++){r+="0000".substr((32*i).toString(16).length)+(32*i).toString(16)+":";for(var n=0;n<32;n+=4)r+=" "+e.substr(32*i+n,4);i<t.length-1&&(r+="\n")}return r}var src$7={count:count,and:and,or:or,xor:xor,not:not,getBit:getBit,setBit:setBit,toBinaryString:toBinaryString,parseBinaryString:parseBinaryString,toHexString:toHexString,parseHexString:parseHexString,toDebug:toDebug};function mode$1(t){if(!src(t))throw new TypeError("input must be an array");if(0===t.length)throw new TypeError("input must not be empty");for(var e=0,r=0,i=0,n={},s=0;s<t.length;++s){var o=t[s];(i=n[o])?(n[o]++,i++):n[o]=i=1,i>r&&(r=i,e=t[s])}return e}function norm$1(t){var e=(arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}).algorithm,r=void 0===e?"absolute":e;if(!Array.isArray(t))throw new Error("input must be an array");if(0===t.length)throw new Error("input must not be empty");switch(r.toLowerCase()){case"absolute":var i=absoluteSum(t);return 0===i?t.slice(0):t.map((function(t){return t/i}));case"max":var n=max(t);return 0===n?t.slice(0):t.map((function(t){return t/n}));case"sum":var s=sum(t);return 0===s?t.slice(0):t.map((function(t){return t/s}));default:throw new Error("norm: unknown algorithm: ".concat(r))}}function absoluteSum(t){for(var e=0,r=0;r<t.length;r++)e+=Math.abs(t[r]);return e}function _typeof(t){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function sequentialFill(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("object"!==_typeof(t)||src(t)||(e=t,t=[]),!src(t))throw new TypeError("input must be an array");var r=e,i=r.from,n=void 0===i?0:i,s=r.to,o=void 0===s?10:s,a=r.size,h=void 0===a?t.length:a,l=r.step;if(h&&l)throw new Error("step is defined by the array size");if(h||(h=l?Math.floor((o-n)/l)+1:o-n+1),!l&&h&&(l=(o-n)/(h-1)),Array.isArray(t)){t.length=0;for(var u=0;u<h;u++)t.push(n),n+=l}else{if(t.length!==h)throw new Error("sequentialFill typed array must have the correct length");for(var c=0;c<h;c++)t[c]=n,n+=l}return t}function variance(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!src(t))throw new TypeError("input must be an array");for(var r=e.unbiased,i=void 0===r||r,n=e.mean,s=void 0===n?mean(t):n,o=0,a=0;a<t.length;a++){var h=t[a]-s;o+=h*h}return i?o/(t.length-1):o/t.length}function standardDeviation(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Math.sqrt(variance(t,e))}function mergeByCentroids(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{window:i=.01}=r;for(var n={x:e.slice(),y:new Array(e.length).fill(0)},s=0,o=0;s<t.x.length&&o<e.length;){var a=t.x[s]-e[o];Math.abs(a)<i?n.y[o]+=t.y[s++]:a<0?s++:o++}return n}function closestX(t,e){const{x:r,y:i}=t,{target:n=r[0],reverse:s=!1}=e;let o;return(o=binarySearch(r,n,s?descending:ascending))>=0?{x:r[o],y:i[o]}:0!==(o=~o)&&Math.abs(r[o]-n)>.5||o===r.length?{x:r[o-1],y:i[o-1]}:{x:r[o],y:i[o]}}function covariance$1(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:i}=t,{unbiased:n=!0}=e,s=mean(r),o=mean(i);var a=0;for(let t=0;t<r.length;t++)a+=(r[t]-s)*(i[t]-o);return n?a/(r.length-1):a/r.length}function maxMerge(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:i}=t,{groupWidth:n=.001}=e;for(var s={x:[],y:[]},o={x:[],y:[]},a=0,h=0;h<r.length;)0===a||r[h]-s.x[a-1]>n?(o.x.push(r[h]),o.y.push(i[h]),s.x.push(r[h]),s.y.push(i[h]),h++,a++):(i[h]>o.y[a-1]&&(o.x[a-1]=r[h],o.y[a-1]=i[h]),s.x[a-1]=r[h],s.y[a-1]+=i[h],h++);return s.x=o.x.slice(),s}function maxY(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:i}=t;let{from:n={index:0},to:s={index:r.length},reverse:o=!1}=e;void 0!==n.value&&void 0===n.index&&(n.index=calculateIndex(n.value,r,o)),void 0!==s.value&&void 0===s.index&&(s.index=calculateIndex(s.value,r,o));for(var a,h=Number.MIN_VALUE,l=n.index;l<s.index;l++)h<i[l]&&(h=i[l],a=l);return{index:a,value:h}}function calculateIndex(t,e,r){let i;if((i=binarySearch(e,t,r?descending:ascending))<0)throw new Error("the value ".concat(t," doesn't belongs to the abscissa value"));return i}function sortX(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:i}=t,{reverse:n=!1}=e;var s;s=n?(t,e)=>e.x-t.x:(t,e)=>t.x-e.x;for(var o=r.map((t,e)=>({x:t,y:i[e]})).sort(s),a={x:r.slice(),y:i.slice()},h=0;h<r.length;h++)a.x[h]=o[h].x,a.y[h]=o[h].y;return a}function uniqueX(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{x:e,y:r}=t;if(e.length<2)return;if(e.length!==r.length)throw new Error("The X and Y arrays mush have the same length");let i=e[0],n=0;for(let t=1;t<e.length;t++)i!==e[t]&&(n++,i=e[t],e[n]=e[t],t!==n&&(r[n]=0)),t!==n&&(r[n]+=r[t]);e.length=n+1,r.length=n+1}function weightedMerge(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:i}=t,{groupWidth:n=.001}=e;for(var s={x:[],y:[]},o={x:[],y:[]},a=0,h=0;h<r.length;)0===a||r[h]-s.x[a-1]>n?(o.x.push(r[h]*i[h]),o.y.push(i[h]),s.x.push(r[h]),s.y.push(i[h]),h++,a++):(o.x[a-1]+=r[h]*i[h],o.y[a-1]+=i[h],s.x[a-1]=r[h],s.y[a-1]+=i[h],h++);for(var l=0;l<s.x.length;l++)s.x[l]=o.x[l]/o.y[l];return s}function integral(t,e,r,i){return.5*r*e*e+i*e-(.5*r*t*t+i*t)}function equallySpacedSmooth(t,e,r,i,n){var s=t.length,o=(i-r)/(n-1),a=o/2,h=new Array(n),l=t[1]-t[0],u=t[s-1]-t[s-2],c=r-a,f=r+a,m=Number.MIN_VALUE,g=0,d=t[0]-l,p=0,w=0,x=0,M=0,y=0,v=0,b=0,S=0;t:for(;;){for(m<=c&&c<=d&&(y=w+(A=integral(0,c-m,x,g)));d-f>=0;){var A=integral(0,f-m,x,g);if(v=w+A,h[S++]=(v-y)/o,S===n)break t;c=f,f+=o,y=v}w+=integral(m,d,x,M),m=d,g=p,b<s?(d=t[b],p=e[b],b++):b===s&&(d+=u,p=0),M=-(x=(p-g)/(d-m))*m+g}return h}function equallySpacedSlot(t,e,r,i,n){var s=t.length,o=(i-r)/(n-1),a=o/2,h=t[t.length-1]-t[t.length-2],l=r-a,u=new Array(n),c=l,f=l+o,m=-Number.MAX_VALUE,g=0,d=t[0],p=e[0],w=0,x=!0,M=0,y=0,v=1,b=0;t:for(;;){if(m>=d)throw new Error("x must be an increasing serie");for(;m-f>0;){if(x&&(y++,x=!1),u[b]=y<=0?0:M/y,++b===n)break t;c=f,f+=o,M=0,y=0}m>c&&(M+=g,y++),(m===-Number.MAX_VALUE||w>1)&&y--,m=d,g=p,v<s?(d=t[v],p=e[v],v++):(d+=h,p=0,w++)}return u}function getZones(t,e,r){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];t>e&&([t,e]=[e,t]),i=i.filter(t=>void 0!==t.from&&void 0!==t.to),(i=JSON.parse(JSON.stringify(i))).forEach(t=>{t.from>t.to&&([t.to,t.from]=[t.from,t.to])}),i.sort((t,e)=>t.from-e.from),i.forEach(r=>{r.from<t&&(r.from=t),r.to>e&&(r.to=e)});for(let t=0;t<i.length-1;t++)i[t].to>i[t+1].from&&(i[t].to=i[t+1].from);if(!(i=i.filter(t=>t.from<t.to))||0===i.length)return[{from:t,to:e,numberOfPoints:r}];let n=i.reduce((t,e)=>t+=e.to-e.from,0),s=(e-t-n)/r,o=[],a=t,h=0;for(let t of i){let e=Math.round((t.from-a)/s);h+=e,e>0&&o.push({from:a,to:t.from,numberOfPoints:e}),a=t.to}return r-h>0&&o.push({from:a,to:e,numberOfPoints:r-h}),o}function equallySpaced(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{x:r,y:i}=t,n=r.length,s=!1;r.length>1&&r[0]>r[1]&&(r=r.slice().reverse(),i=i.slice().reverse(),s=!0);let{from:o=r[0],to:a=r[n-1],variant:h="smooth",numberOfPoints:l=100,exclusions:u=[]}=e;if(n!==i.length)throw new RangeError("the x and y vector doesn't have the same size.");if("number"!=typeof o||isNaN(o))throw new RangeError("'from' option must be a number");if("number"!=typeof a||isNaN(a))throw new RangeError("'to' option must be a number");if("number"!=typeof l||isNaN(l))throw new RangeError("'numberOfPoints' option must be a number");if(l<2)throw new RangeError("'numberOfPoints' option must be greater than 1");let c=getZones(o,a,l,u),f=[],m=[];for(let t of c){let e=processZone(r,i,t.from,t.to,t.numberOfPoints,h);f=f.concat(e.x),m=m.concat(e.y)}return s?o<a?{x:f.reverse(),y:m.reverse()}:{x:f,y:m}:o<a?{x:f,y:m}:{x:f.reverse(),y:m.reverse()}}function processZone(t,e,r,i,n,s){if(n<1)throw new RangeError("the number of points must be at least 1");var o="slot"===s?equallySpacedSlot(t,e,r,i,n):equallySpacedSmooth(t,e,r,i,n);return{x:sequentialFill({from:r,to:i,size:n}),y:o}}function getZones$1(t,e){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];t>e&&([t,e]=[e,t]),r=r.filter(t=>void 0!==t.from&&void 0!==t.to),(r=JSON.parse(JSON.stringify(r))).forEach(t=>{t.from>t.to&&([t.to,t.from]=[t.from,t.to])}),r.sort((t,e)=>t.from-e.from),r.forEach(r=>{r.from<t&&(r.from=t),r.to>e&&(r.to=e)});for(let t=0;t<r.length-1;t++)r[t].to>r[t+1].from&&(r[t].to=r[t+1].from);if(!(r=r.filter(t=>t.from<t.to))||0===r.length)return[{from:t,to:e}];let i=[],n=t;for(let t of r)n<t.from&&i.push({from:n,to:t.from}),n=t.to;return n<e&&i.push({from:n,to:e}),i}function filterX(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{x:r,y:i}=t,{from:n=r[0],to:s=r[r.length-1],exclusions:o=[]}=e;let a=getZones$1(n,s,o),h=0,l=[],u=[],c=0;for(;c<r.length;){if(r[c]<=a[h].to&&r[c]>=a[h].from)l.push(r[c]),u.push(i[c]);else if(r[c]>a[h].to&&!a[++h])break;c++}return{x:l,y:u}}const{Matrix:Matrix$2,SVD:SVD,EVD:EVD,CholeskyDecomposition:CholeskyDecomposition$1,LuDecomposition:LuDecomposition$1,QrDecomposition:QrDecomposition$1}=MatrixLib,Array$1={min:min,max:max,median:median,mean:mean,mode:mode$1,normed:norm$1,rescale:rescale,sequentialFill:sequentialFill,standardDeviation:standardDeviation,sum:sum,variance:variance},ArrayXY={centroidsMerge:mergeByCentroids,closestX:closestX,covariance:covariance$1,maxMerge:maxMerge,maxY:maxY,sortX:sortX,uniqueX:uniqueX,weightedMerge:weightedMerge,equallySpaced:equallySpaced,filterX:filterX};exports.Array=Array$1,exports.ArrayXY=ArrayXY,exports.BitArray=src$7,exports.CholeskyDecomposition=CholeskyDecomposition$1,exports.ConfusionMatrix=src$1,exports.CrossValidation=src$3,exports.DecisionTreeClassifier=DecisionTreeClassifier,exports.DecisionTreeRegression=DecisionTreeRegression,exports.Distance=distances,exports.EVD=EVD,exports.ExponentialRegression=ExponentialRegression,exports.FCNNLS=index$2,exports.FNN=FeedForwardNeuralNetwork,exports.HClust=index,exports.HashTable=HashTable,exports.KMeans=kmeans,exports.KNN=KNN,exports.KOPLS=KOPLS,exports.Kernel=kernel,exports.LuDecomposition=LuDecomposition$1,exports.Matrix=Matrix$2,exports.MatrixLib=MatrixLib,exports.MultivariateLinearRegression=MultivariateLinearRegression,exports.NaiveBayes=index$1,exports.PCA=PCA,exports.PLS=PLS,exports.Performance=src$5,exports.PolynomialRegression=PolynomialRegression,exports.PowerRegression=PowerRegression,exports.QrDecomposition=QrDecomposition$1,exports.Random=Random,exports.RandomForestClassifier=RandomForestClassifier,exports.RandomForestRegression=RandomForestRegression,exports.RobustPolynomialRegression=RobustPolynomialRegression,exports.SOM=src$4,exports.SVD=SVD,exports.Similarity=similarities,exports.SimpleLinearRegression=SimpleLinearRegression,exports.SparseMatrix=SparseMatrix,exports.TheilSenRegression=TheilSenRegression,exports.XSadd=XSadd,exports.binarySearch=binarySearch,exports.distanceMatrix=distanceMatrix,exports.levenbergMarquardt=levenbergMarquardt,exports.numSort=index$3,exports.padArray=src$6,exports.savitzkyGolay=savitzkyGolay,Object.defineProperty(exports,"__esModule",{value:!0})}));
//# sourceMappingURL=ml.min.js.map
